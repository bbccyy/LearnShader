PS
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// TEXCOORD                10   xyzw        0     NONE   float   xyz 
// TEXCOORD                11   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xyzw        2     NONE   float   xy  
// PRIMITIVE_ID             0   x           3     NONE    uint   x   
// SV_Position              0   xyzw        4      POS   float   xyzw
// SV_IsFrontFace           0   x           5    FFACE    uint   x   
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
// SV_Target                1   xyzw        1   TARGET   float   xyzw
// SV_Target                2   xyzw        2   TARGET   float   xyzw
// SV_Target                3   xyzw        3   TARGET   float   xyzw
// SV_Target                4   xyzw        4   TARGET   float   xyzw
// SV_DepthLessEqual        0    N/A oDepthLE  DEPTHLE   float    YES
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[178], immediateIndexed
dcl_constantbuffer CB1[7], immediateIndexed     ->  区别于 PS_796  ->  当前使用CBV 1318
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_sampler s2, mode_default
dcl_sampler s3, mode_default
dcl_resource_structured t0, 16                          -> Data Buffer 
dcl_resource_texture2d (float,float,float,float) t1     -> Normal Tex rg
dcl_resource_texture2d (float,float,float,float) t2     -> Grass RGBA 
dcl_resource_texture2d (float,float,float,float) t3     -> Purple RGB
dcl_resource_texture2d (float,float,float,float) t4     -> Common Noise R

dcl_input_ps linear centroid v0.xyz         -> NormalWS
dcl_input_ps linear centroid v1.xyzw        -> TangentWS
dcl_input_ps linear v2.xy                   -> UV
dcl_input_ps constant v3.x                  -> PRIMITIVE_ID

dcl_input_ps_siv linear noperspective centroid v4.xyzw, position     -> [pixelIdx.xy, NDC.z, -Clip.w] ? 
dcl_input_ps_sgv constant v5.x, is_front_face 

dcl_output o0.xyzw        未知 -> 类似剪影，基本上只渲染上了天空盒，以及极少数半透明物件(灯笼？)  T:8264 
                          o0 = [混淆后的BaseColor.rgb, 0]
dcl_output o1.xyzw        可能是 normal  A通道在角色上0.66，在某些其他物件上0.33   T:8220
                          o1 = [NormalWS.xyz, t0[PRIMTIVE_ID]]
dcl_output o2.xyzw        未知 -> 偏蓝 且 w分量设置为 0.694118  T:8241  
                          o2 = [NoiseTex.x, CommonNoise.x关联值, NoiseTex.x偏移值, 0.694118]
dcl_output o3.xyzw        可能是 base color -> 存放了 采样base Color 且经过变换后的颜色  T:8222 
                          o3 = [去除强度的BaseColor.rgb, BaseCol与NoiseTex的混淆] 
dcl_output o4.xyzw        未知 -> 似乎区分了角色本体，树叶和建筑 -> 一种 Mask ?    T:8223
                          o4 = [0,0,0,0]   
dcl_output oDepthLE
dcl_temps 8

//获取 BitangentWS -> r0.xyz = Cross(NormalWS，TangentWS) * sign 
mul r0.xyz, v0.yzxy, v1.zxyz
mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx
mul r0.xyz, r0.xyzx, v1.wwww

//r1.x = posPS.z * posPS.w  ->  NDC.z * Clip.w = Clip.z 所有r1.x保存了Clip.z的数值 
//r1.y = 1 
//r1.z = posPS.w  
mov r1.x, v4.z 
mov r1.y, l(1.000000) 
mul r1.xz, r1.xxyx, v4.wwww 

//此处通过采样和解码，似乎是为了获得 Bitangent的朝向w 
imad r2.xy, v3.xxxx, l(35, 35, 0, 0), l(4, 20, 0, 0) 
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r0.w, r2.x, l(12), t0.xxxx 
mul r0.w, r0.w, cb0[140].w 
movc r1.w, v5.x, l(1.000000), l(-1.000000)    -> 根据VFACE判断当前像素所在几何体是正面朝向视点还是背面 
mul r0.w, r0.w, r1.w                          -> 这里赋值r0.w 而r0.xyz是Bitangent 

//采样法线纹理，解码位于切线空间的法线原始数据 
mul r2.xz, v2.xxyx, cb1[4].xxxx     -> UV *= 2，随后拿去采样 Normal 纹理（只有RG通道） -> cb1[4].x = 2 
sample_b_indexable(texture2d)(float,float,float,float) r3.xy, r2.xzxx, t1.xyzw, s0, cb0[142].y
mad r3.xy, r3.xyxx, l(2.000000, 2.000000, 0.000000, 0.000000), l(-1.000000, -1.000000, 0.000000, 0.000000)  从[0,1]转[-1,1]区间 
dp2 r1.w, r3.xyxx, r3.xyxx
add r1.w, -r1.w, l(1.000000)
max r1.w, r1.w, l(0.000000)   -> w在 [0,1] 区间
sqrt r3.z, r1.w               -> 到这里从RG通道中解出了第三个通道B
add r4.xyz, -r3.xyzx, l(0.000000, 0.000000, 1.000000, 0.000000)   -> 这两行add + mad的组合符合 lerp 指令 -> lerp((0,0,1), Norm, Rate)
mad r3.xyz, cb1[4].yyyy, r4.xyzx, r3.xyzx                         -> cb1[4].y = 0 -> (float3(0,0,1) - TexNorm) * Rate + TexNorm
mad r3.xyz, r3.xyzx, cb0[137].wwww, cb0[137].xyzx                 -> 对切线空间法线进行 Scale 和 Offset 等常规操作 
dp3 r1.w, r3.xyzx, r3.xyzx                                        -> 以下 3 行负责 归一化 TexNormal 
rsq r1.w, r1.w
mul r3.xyz, r1.wwww, r3.xyzx 

//应用TBN矩阵将贴图法线转换到世界空间下，随后归一化，调整朝向 
mul r0.xyz, r0.xyzx, r3.yyyy
mad r0.xyz, r3.xxxx, v0.xyzx, r0.xyzx
mad r0.xyz, r3.zzzz, v1.xyzx, r0.xyzx
dp3 r1.w, r0.xyzx, r0.xyzx
rsq r1.w, r1.w
mul r0.xyz, r0.xyzx, r1.wwww    再归一化
mul r0.xyz, r0.wwww, r0.xyzx    调整朝向

mul r3.xyz, cb1[1].xyzx, cb1[4].zzzz    ->  r3.xyz = 0 -> 无意义操作 

//采样 Grass 纹理，获取基础色 
sample_b_indexable(texture2d)(float,float,float,float) r4.xyz, r2.xzxx, t2.xyzw, s1, cb0[142].y 
mul r4.xyz, r4.xyzx, cb1[3].xyzx    -> 对原始颜色调整  cb1[3].xyz = [0.149,0.1098,0.078]  -> 此后称 R4 颜色 
mul r5.xyz, r4.xyzx, cb1[5].yyyy    -> 对调整后的颜色缩放 cb1[5].y = [1]                   -> 此后称 R5 颜色 -> 本质还是 R4 颜色 


dp3 r0.w, l(0.577350, 0.577350, 0.577350, 0.000000), r5.xyzx
mul r1.w, r0.w, l(0.577350)
mad r4.xyz, r4.xyzx, cb1[5].yyyy, -r1.wwww
mul r5.xyz, r4.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000)
mad r5.xyz, r4.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000), -r5.zxyz
sincos r6.x, r7.x, cb1[5].x
mul r5.xyz, r5.xyzx, r6.xxxx
mad r4.xyz, r4.xyzx, r7.xxxx, r5.xyzx
mad r4.xyz, r0.wwww, l(0.577350, 0.577350, 0.577350, 0.000000), r4.xyzx
dp3 r0.w, r4.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000)
add r5.xyz, -r4.xyzx, r0.wwww
mad_sat r4.xyz, cb1[5].zzzz, r5.xyzx, r4.xyzx
sample_b_indexable(texture2d)(float,float,float,float) r2.xz, r2.xzxx, t3.yxzw, s2, cb0[142].y
mul_sat r0.w, r2.x, cb1[6].x


//利用posPS.xy构造顶点噪声 -> 存入 r1.w 
add r5.xy, v4.xyxx, -cb0[129].xyxx    -> cb0[129] = 0,0,0,0
add r5.zw, r5.xxxy, cb0[151].xxxx     -> cb0[151] = 0,0,0,0  可以认为r5.xyzw是对当前fragment在屏幕上的坐标进行前后两次偏移后获得 
ftou r5.zw, r5.zzzw    -> float to unsigned integer 
ishl r1.w, r5.w, l(1)  -> posPS.y << 1
iadd r1.w, r1.w, r5.z  -> posPS.y * 2 + posPS.x 
udiv null, r1.w, r1.w, l(5)   -> (posPS.y * 2 + posPS.x) mod 5 -> 求余数 -> 记为 R1.w (可取值: 0,1,2,3,4) 
utof r1.w, r1.w 


mul r5.xy, r5.xyxx, l(0.015625, 0.015625, 0.000000, 0.000000)
sample_b_indexable(texture2d)(float,float,float,float) r2.w, r5.xyxx, t4.yzwx, s3, cb0[142].y
add r1.w, r1.w, r2.w
mul r1.w, r1.w, cb1[6].y
mul r1.w, r1.w, l(0.166667)
mad r1.y, r1.y, v4.w, l(-24.000000)
div_sat r1.y, r1.y, cb1[6].z
mad r1.y, r1.y, r1.w, r1.z
div r1.y, r1.x, r1.y
min r1.y, r1.y, v4.z
mov_sat r1.w, cb1[5].w
mov_sat r2.xz, r2.xxzx
mad o2.z, r0.w, cb0[138].y, cb0[138].x
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) o1.w, r2.y, l(4), t0.xxxx
mul r0.w, r1.w, l(0.080000)
mad r5.xyz, -r1.wwww, l(0.080000, 0.080000, 0.080000, 0.000000), r4.xyzx
mad r5.xyz, r2.xxxx, r5.xyzx, r0.wwww
mad r6.xyz, -r4.xyzx, r2.xxxx, r4.xyzx
mad r6.xyz, r6.xyzx, cb0[135].wwww, cb0[135].xyzx
mad r5.xyz, r5.xyzx, cb0[136].wwww, cb0[136].xyzx
ne r0.w, l(0.000000, 0.000000, 0.000000, 0.000000), cb0[177].w
mad r7.xyz, r5.xyzx, l(0.450000, 0.450000, 0.450000, 0.000000), r6.xyzx
movc r6.xyz, r0.wwww, r7.xyzx, r6.xyzx
movc r5.xyz, r0.wwww, l(0,0,0,0), r5.xyzx
dp3 r0.w, r5.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000)
mad r7.xyz, r0.wwww, l(2.040400, -4.795100, 2.755200, 0.000000), l(-0.332400, 0.641700, 0.690300, 0.000000)
mad r0.w, r2.z, r7.x, r7.y
mad r0.w, r0.w, r2.z, r7.z
mul r0.w, r2.z, r0.w
max o3.w, r0.w, r2.z
mad r2.yzw, r5.xxyz, l(0.000000, 0.450000, 0.450000, 0.450000), r6.xxyz
max r3.xyz, r3.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)
lt r0.w, l(0.000000), cb0[139].x
if_nz r0.w
  mul r5.xyzw, v4.yyyy, cb0[45].xyzw
  mad r5.xyzw, v4.xxxx, cb0[44].xyzw, r5.xyzw
  mad r5.xyzw, v4.zzzz, cb0[46].xyzw, r5.xyzw
  add r5.xyzw, r5.xyzw, cb0[47].xyzw
  div r5.xyz, r5.xyzx, r5.wwww
  add r6.xyz, r5.xyzx, -cb0[70].xyzx
  dp3 r0.w, -r5.xyzx, -r5.xyzx
  rsq r0.w, r0.w
  mul r5.xyz, r0.wwww, -r5.xyzx
  mad r0.w, -r1.y, r1.z, r1.x
  div r0.w, r0.w, r1.y
  mad r5.xyz, r5.xyzx, r0.wwww, r6.xyzx
  imad r1.xz, v3.xxxx, l(35, 0, 35, 0), l(5, 0, 19, 0)
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r6.xyz, r1.x, l(0), t0.xyzx
  add r6.xyz, r5.xyzx, -r6.xyzx
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r7.xyz, r1.z, l(0), t0.xyzx
  add r7.xyz, r7.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)
  lt r6.xyz, r7.xyzx, |r6.xyzx|
  or r0.w, r6.y, r6.x
  or r0.w, r6.z, r0.w
  dp3 r1.x, r5.xyzx, l(0.577000, 0.577000, 0.577000, 0.000000)
  mul r1.x, r1.x, l(0.002000)
  frc r1.x, r1.x
  lt r1.x, l(0.500000), r1.x
  movc r5.xyz, r1.xxxx, l(0,1.000000,1.000000,0), l(1.000000,1.000000,0,0)
  movc r3.xyz, r0.wwww, r5.xyzx, r3.xyzx
endif 
mad r2.yzw, cb0[144].yyyy, r2.yyzw, r3.xxyz
mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000)
mul o0.xyz, r2.yzwy, cb0[134].yyyy
mov o0.w, l(0)
mov o2.x, r2.x
mov o2.w, l(0.694118)
mov o2.y, r1.w
mov o3.xyz, r4.xyzx
mov o4.xyzw, l(0,0,0,0)
mov oDepthLE, r1.y
ret 
// Approximately 0 instruction slots used
