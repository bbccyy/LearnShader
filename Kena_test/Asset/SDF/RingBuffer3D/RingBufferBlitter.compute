// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RingBuffer3DBlitCS

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#define BLIT_UNIT_SIZEX 8

Texture3D<half> _SrcSDFVolumeTex;
RWTexture3D<half> _SDFVolumeBuffer;

SamplerState my_bilinear_clamp_sampler;

float3 _SrcSDFVolumeTex_InvTexelSize;
float3 _SrcSDFVolumeTex_MinTexelOffset;  //pixel offset from AOI(AreaOfIntreseting) Min position to SrcSDFVolume Min position 

uint3 _SDFVolumeBufferSize;
int3 _MovementTexelDelta;
uint3 _TarSDFVolumeBuffer_MinTexelOffset;

[numthreads(BLIT_UNIT_SIZEX, BLIT_UNIT_SIZEX, BLIT_UNIT_SIZEX)]
void RingBuffer3DBlitCS(
    uint3 GroupId : SV_GroupID,
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID)
{
    float3 SrcCoordinate = float3(DispatchThreadId.xyz) + _SrcSDFVolumeTex_MinTexelOffset + 0.5; 
    SrcCoordinate = SrcCoordinate * _SrcSDFVolumeTex_InvTexelSize;  //to UVW
    float raw = SAMPLE_TEXTURECUBE_LOD(_SrcSDFVolumeTex, my_bilinear_clamp_sampler, SrcCoordinate, 0).r;

    int3 TarCoordinate = (int)(DispatchThreadId.xyz + _TarSDFVolumeBuffer_MinTexelOffset) + _MovementTexelDelta;
    half3 needShift1 = TarCoordinate < 0;
    half3 needShift2 = TarCoordinate >= _SDFVolumeBufferSize;
    TarCoordinate = TarCoordinate + _SDFVolumeBufferSize * needShift - _SDFVolumeBufferSize * needShift2;

    _SDFVolumeBuffer[TarCoordinate] = raw;
}
