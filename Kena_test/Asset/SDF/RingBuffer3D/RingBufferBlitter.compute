// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RingBuffer3DBlitCS

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#define BLIT_UNIT_SIZEX 8

Texture3D<half> _SrcVolumeTex;
#if defined(SHADER_API_GLES) || defined(SHADER_API_GLES30)
RWTexture2DArray<half> _RingBuffer; //TODO
#else
RWTexture3D<half> _RingBuffer;
#endif

SamplerState my_bilinear_clamp_sampler;

float3 _AreaOfIntresetingSize;

float3 _SrcVolumeTex_InvTexelSize;
float3 _SrcVolumeTex_MinTexelOffset;  //pixel offset from AOI(AreaOfIntreseting) Min position to SrcSDFVolume Min position 

float3 _RingBufferSize;
float3 _MovementTexelDelta;
float3 _RingBuffer_MinTexelOffset;

[numthreads(BLIT_UNIT_SIZEX, BLIT_UNIT_SIZEX, BLIT_UNIT_SIZEX)]
void RingBuffer3DBlitCS(
    uint3 GroupId : SV_GroupID,
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID)
{
    if (all(DispatchThreadId < (uint3)_AreaOfIntresetingSize))
    {
        float3 SrcCoordinate = float3(DispatchThreadId.xyz) + _SrcVolumeTex_MinTexelOffset + 0.5;
        SrcCoordinate = SrcCoordinate * _SrcVolumeTex_InvTexelSize;  //to UVW
        float raw = SAMPLE_TEXTURECUBE_LOD(_SrcVolumeTex, my_bilinear_clamp_sampler, SrcCoordinate, 0).r;

        int3 TarCoordinate = DispatchThreadId.xyz + (int3)_RingBuffer_MinTexelOffset + (int3)_MovementTexelDelta;
        uint3 needShift1 = TarCoordinate < 0;
        uint3 needShift2 = TarCoordinate >= (int3)_RingBufferSize;
        TarCoordinate = TarCoordinate + (int3)_RingBufferSize * needShift1 - (int3)_RingBufferSize * needShift2;

        _RingBuffer[TarCoordinate] = raw;
    }
}
