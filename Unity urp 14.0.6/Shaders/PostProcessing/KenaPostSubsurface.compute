// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitValueBufferCS
#pragma kernel BuildIndirectDispatchArgsCS 
#pragma kernel SetupIndirectCS 
#pragma kernel MainIndirectDispatchCS 

#pragma multi_compile _ SUBSURFACE_PASS_ONE 

#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/KenaDefineCommon.hlsl"  

// define structure here 
struct SDiffuseAndSpecular
{
    float3 Diffuse;
    float3 Specular; 
};


// 0, no subsurface
// 1, Separable
// 2, Burley
// 3, Both
groupshared uint SubsurfaceTypeFlag;

uint SubsurfaceUniformParameters_MaxGroupCount;
uint4 Output_ViewportMinMax;    // [0, 0, 1708, 960]
float4 Output_ExtentInverse;    //[pixelSizeX, pixelSizeY, 1/pixelSizeX, 1/pixelSizeY]
float4 Input_ExtentInverse;     //[pixelSizeX, pixelSizeY, 1/pixelSizeX, 1/pixelSizeY] -> half res 
float4 Input_ViewportSize;      //[pixelSizeX, pixelSizeY, 0, 0] -> half res
float4 SubsurfaceParams;        //[0.18515, 1.11089, 0.00, 0.00] -> cb0_v27 

static float4 InvDeviceZToWorldZTransform = float4(0.00, 0.00, 0.10, -1.00000E-08);
static float4 View_BufferSizeAndInvSize = float4(1708.00, 960.00, 0.00059, 0.00104); 
static float4 SubsurfaceInput0_ExtentInverse = float4(0, 0, 0.00059, 0.00104);
static float4 SubsurfaceInput0_UVViewportBilinearMinMax = float4(0.00059, 0.00104, 0.99941, 0.99896);


//SamplerState my_point_clamp_sampler;
SamplerState pointClampSampler;
uniform Texture2D<half4>  _GBuffer0;    //Albedo
uniform Texture2D<half4>  _GBuffer1;    //Comp_M_D_R_F 
uniform Texture2D<float>  _GBuffer4;    //Depth -> pay attention, must be float, not float4 
uniform Texture2D<half4>  _GBuffer5;    //Comp_Custom_F_R_X_I 
uniform Texture2D<float4> _LUT;         //SSSSLUT ->  ActualSSProfilesTexture
uniform Texture2D<half4>  _CameraTexture;    //current render target  -> SubsurfaceInput0_Texture 


RWBuffer<uint> RWSeparableGroupBuffer;
RWBuffer<uint> RWIndirectDispatchArgsBuffer;
Buffer<uint> GroupBuffer;  //could be SeparableGroupBuffer or BurleyGroupBuffer 

bool UseSubsurfaceProfile(int ShadingModel)
{
    return ShadingModel == SHADINGMODELID_SUBSURFACE_PROFILE || ShadingModel == SHADINGMODELID_EYE;
}

// BufferUV
float2 ConvertGridPos2UV(uint2 GridPosition)
{
    float2 GripPositionF = float2(GridPosition);
    return Output_ExtentInverse.zw * (GripPositionF + 0.5f);
}


float ConvertFromDeviceZ(float DeviceZ)
{
    // Supports ortho and perspective, see CreateInvDeviceZToWorldZTransform()
    return DeviceZ * InvDeviceZToWorldZTransform[0] + InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * InvDeviceZToWorldZTransform[2] - InvDeviceZToWorldZTransform[3]);
}

float CalcSceneDepth(float2 ScreenUV)
{
    return ConvertFromDeviceZ(_GBuffer4.SampleLevel(pointClampSampler, ScreenUV, 0).r);
}

float4 GatherSceneDepth(float2 UV, float2 InvBufferSize)
{
    float2 TexelScale = 0.5f * InvBufferSize;
    return float4(
        CalcSceneDepth(UV + (float2(-1, 1) * TexelScale)),
        CalcSceneDepth(UV + (float2(1, 1) * TexelScale)),
        CalcSceneDepth(UV + (float2(1, -1) * TexelScale)),
        CalcSceneDepth(UV + (float2(-1, -1) * TexelScale))
        );
}

// can be moved/shared
half3 LookupSceneColor(float2 SceneUV, half2 PixelOffset)
{
    // faster
    return _CameraTexture.SampleLevel(pointClampSampler, SceneUV, 0, PixelOffset * View_BufferSizeAndInvSize.zw).rgb;
    //return SAMPLE_TEXTURE2D_X(_CameraTexture, sampler_PointClamp, SceneUV + PixelOffset * View_BufferSizeAndInvSize.zw).rgb;
}

bool CheckerFromSceneColorUV(float2 UVSceneColor)
{
    // relative to left top of the rendertarget (not viewport)
    uint2 PixelPos = (uint2)(UVSceneColor.xy * View_BufferSizeAndInvSize.xy).xy;
    uint TemporalAASampleIndex = 3;
    return (PixelPos.x + PixelPos.y + TemporalAASampleIndex) % 2;
}

SDiffuseAndSpecular ReconstructLighting(float2 UVSceneColor)
{
    SDiffuseAndSpecular Ret = (SDiffuseAndSpecular)0;

    bool bChecker = CheckerFromSceneColorUV(UVSceneColor);

    half3 Quant0 = _CameraTexture.SampleLevel(pointClampSampler, UVSceneColor, 0).rgb;
    //half3 Quant0 = SAMPLE_TEXTURE2D_X(_CameraTexture, sampler_PointClamp, UVSceneColor).rgb;

    half3 Quant1 = 0.5f * (
        LookupSceneColor(UVSceneColor, half2(1, 0)) +
        LookupSceneColor(UVSceneColor, half2(-1, 0)));

    Ret.Diffuse = lerp(Quant1, Quant0, bChecker);
    Ret.Specular = lerp(Quant0, Quant1, bChecker);
    return Ret;
}

// @param UVSceneColor for the full res rendertarget (BufferSize) e.g. SceneColor or GBuffers
// @return .RGB Color that should be scattared, .A:1 for subsurface scattering material, 0 for not
float4 SetupSubsurfaceForOnePixel(float2 UVSceneColor)
{
    float4 Ret = 0;

    //sample customdata to get material channel info 
    half packedChannel = _GBuffer1.SampleLevel(pointClampSampler, UVSceneColor, 0).a;
    uint ShadingModelID = ((uint)round(packedChannel * (float)0xFF)) & SHADINGMODELID_MASK;

    [branch]
    if (UseSubsurfaceProfile(ShadingModelID))
    {

        SDiffuseAndSpecular DiffuseAndSpecular = ReconstructLighting(UVSceneColor);

        Ret.rgb = DiffuseAndSpecular.Diffuse;

        // it's a valid sample
        Ret.a = 1;
    }

    return Ret;
}


void AddSeparableGroup(uint2 GroupXY)
{
    //buffer counter is stored in the .Count in the first element.
    uint IndexToStore = 0;

    InterlockedAdd(RWSeparableGroupBuffer[0], 1, IndexToStore);  //RWSeparableGroupBuffer[0]++ 

    if (IndexToStore >= SubsurfaceUniformParameters_MaxGroupCount)
    {
        return; //in case of invalid input params 
    }

    RWSeparableGroupBuffer[2 * (IndexToStore + 1) + 0] = GroupXY.x;  //mark down the group ID which has subsurface 
    RWSeparableGroupBuffer[2 * (IndexToStore + 1) + 1] = GroupXY.y;
}


//GI:GroupIndex, Type:Seperable, GroupXY:GroupID 
void AddSubsurfaceComputeGroup(uint GI, uint Type, uint2 GroupXY) 
{
    InterlockedOr(SubsurfaceTypeFlag, Type);  //atomic OR operation on shared-memory:SubsurfaceTypeFlag 

    GroupMemoryBarrierWithGroupSync(); //block all threads in current group until sync to this line 

    //pass or not pass, One Group as a whole 
    //if any thread in current group has Type==TYPE_SEPARABLE, the first thread of current group will jump into the following branch 
    if (GI == 0 && (SubsurfaceTypeFlag & TYPE_SEPARABLE)) 
    {
        AddSeparableGroup(GroupXY);
    }

    if (GI == 0 && (SubsurfaceTypeFlag & TYPE_BURLEY)) //not support 
    {
        //AddBurleyGroup(GroupXY); //do nothing 
    }
}


[numthreads(1, 1, 1)]
void InitValueBufferCS()  //event name: InitGroupCounter
{
    RWSeparableGroupBuffer[0] = 0;    
}

[numthreads(1, 1, 1)]
void BuildIndirectDispatchArgsCS()  //event name: BuildBurleyIndirectDispatchArgs
{
    uint ValueCount = min(SubsurfaceUniformParameters_MaxGroupCount, GroupBuffer[0]);   
    RWIndirectDispatchArgsBuffer[0] = ValueCount;
    RWIndirectDispatchArgsBuffer[1] = 1;
    RWIndirectDispatchArgsBuffer[2] = 1;
}


RWTexture2D<float4> SetupTexture; // [2D RT 31731] Half Res 

//[numthreads(THREAD_SIZE_X, THREAD_SIZE_Y, 1)]   uint3 DT_ID : SV_DispatchThreadID,
[numthreads(8, 8, 1)]
void SetupIndirectCS(uint3 DT_ID : SV_DispatchThreadID, uint3 G_ID : SV_GroupID, uint3 GT_ID : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    if (GI == 0)  //the very first thread in a perticual group 
    {
        SubsurfaceTypeFlag = 0;  //clean shared flag 
    }
    GroupMemoryBarrier();  //not allow any thread pass through this line until the shared-flag has been reseted 

    uint2 Pos = DT_ID.xy + Output_ViewportMinMax.xy;  
    //uint2 Pos = G_ID.xy * uint2(THREAD_SIZE_X, THREAD_SIZE_Y) + GT_ID.xy + Output_ViewportMinMax.xy;

    bool bHasSubsurface = false;
    float2 BufferUV = ConvertGridPos2UV(Pos);
    uint Type = 0;
    float4 OutColor = 0;

    //SetupTexture[Pos.xy] = float4(0, 0, 0, 0);  //clean up all  

    // --------------SUBSURFACE_HALF_RES START--------------
    // order aligned with Gather() hardware implementation
    // RGB: color*A, A:weight 0 if no subsurface scattering
    float4 A = SetupSubsurfaceForOnePixel(min(BufferUV + float2(-0.5, 0.5f) * SubsurfaceInput0_ExtentInverse.zw, SubsurfaceInput0_UVViewportBilinearMinMax.zw));
    float4 B = SetupSubsurfaceForOnePixel(min(BufferUV + float2(0.5, 0.5f) * SubsurfaceInput0_ExtentInverse.zw, SubsurfaceInput0_UVViewportBilinearMinMax.zw));
    float4 C = SetupSubsurfaceForOnePixel(min(BufferUV + float2(0.5, -0.5f) * SubsurfaceInput0_ExtentInverse.zw, SubsurfaceInput0_UVViewportBilinearMinMax.zw));
    float4 D = SetupSubsurfaceForOnePixel(min(BufferUV + float2(-0.5, -0.5f) * SubsurfaceInput0_ExtentInverse.zw, SubsurfaceInput0_UVViewportBilinearMinMax.zw));

    float4 Sum = (A + B) + (C + D);
    float Div = 1.0f / max(Sum.a, 0.00001f);
    OutColor.rgb = Sum.rgb * Div;

    float4 FourDepth = GatherSceneDepth(BufferUV, SubsurfaceInput0_ExtentInverse.zw);
    // average all valid depth values to a single one
    float SingleDepth = dot(FourDepth, float4(A.a, B.a, C.a, D.a)) * Div;

    OutColor.a = SingleDepth;

    if (OutColor.a > 0)
    {
        bHasSubsurface = true; 
    }
    // --------------SUBSURFACE_HALF_RES END--------------

    
    if (bHasSubsurface)
    {
        Type = TYPE_SEPARABLE; // use separable for half resolution
    }

    if (all(Pos < Output_ViewportMinMax.zw)) 
    {
        SetupTexture[Pos] = OutColor;
    }

    AddSubsurfaceComputeGroup(GI, Type, G_ID.xy);
}


uniform Texture2D<half4> SubsurfaceInput0_Texture;     //passOne -> SetupTexture; passTwo -> SubsurfaceSubpassOneTex 
RWTexture2D<float4> SSSColorUAV;
static const int SUBSURFACE_RADIUS_SCALE = 1024;

float GetMaskFromDepthInAlpha(float Alpha)
{
    return Alpha > 0;
}

float4 GetSceneColor(float2 BufferUV)
{
    BufferUV = clamp(BufferUV, SubsurfaceInput0_UVViewportBilinearMinMax.xy, SubsurfaceInput0_UVViewportBilinearMinMax.zw);
    return SubsurfaceInput0_Texture.SampleLevel(pointClampSampler, BufferUV, 0).rgba;
}

float4 GetSubsurfaceProfileKernel(uint SampleIndex, uint SubsurfaceProfileInt)
{
    const float4 TableMax = float4(1,1,1,SUBSURFACE_KERNEL_SIZE);
    //return _LUT.Load(int3(SampleIndex, SubsurfaceProfileInt, 0)) * TableMax;
    return _LUT.Load(int3(SampleIndex, 64 - SubsurfaceProfileInt, 0)) * TableMax; //reverse y-axis in Unity 
}

uint ExtractSubsurfaceProfileInt(float2 UV)
{
    half packedChannel = _GBuffer1.SampleLevel(pointClampSampler, UV, 0).a;
    uint SelectiveOutputMask = ((uint)round(packedChannel * (float)0xFF)) & ~SHADINGMODELID_MASK;
    half Custom_r = _GBuffer5.SampleLevel(pointClampSampler, UV, 0).r;
    Custom_r = !(SelectiveOutputMask & SKIP_CUSTOMDATA_MASK) ? Custom_r : 0; 
    return uint(Custom_r * 255.0f + 0.5f);
}

uint GetSubsurfaceProfileId(float2 BufferUV)
{
    BufferUV = clamp(BufferUV, SubsurfaceInput0_UVViewportBilinearMinMax.xy, SubsurfaceInput0_UVViewportBilinearMinMax.zw);
    return ExtractSubsurfaceProfileInt(BufferUV);
}

float3 GetSubsurfaceProfileBoundaryColorBleed(uint SubsurfaceProfileInt)
{
    //uint SubsurfaceProfileInt = ExtractSubsurfaceProfileInt(UV);
    return GetSubsurfaceProfileKernel(SSSS_BOUNDARY_COLOR_BLEED_OFFSET, SubsurfaceProfileInt).rgb;
}

float GetSubsurfaceStrength(float2 UV)
{
    //sample MDRI to get material channel info 
    half packedChannel = _GBuffer1.SampleLevel(pointClampSampler, UV, 0).a;
    uint ShadingModelID = ((uint)round(packedChannel * (float)0xFF)) & SHADINGMODELID_MASK;
    float Mask = UseSubsurfaceProfile(ShadingModelID) ? 1.0f : 0.0f;
    //sample Customdata to get ssss raw intensity 
    half Custom_a = _GBuffer5.SampleLevel(pointClampSampler, UV, 0).a;
    return Mask * Custom_a;
}

float4 SSSSBlurPS(float2 BufferUV, float2 dir, bool initStencil)
{
    //Fetch color of current pixel
    float4 colorM = GetSceneColor(BufferUV);

    //store the depth in alpha
    float OutDepth = colorM.a;

    colorM.a = GetMaskFromDepthInAlpha(colorM.a);

    [branch]
    if (!colorM.a) //do not process pixels that are not part of the suvsurface scattering 
    {
        return (float4)0.0f; 
    }
    else
    {
        //0..1
        float SSSStrength = GetSubsurfaceStrength(BufferUV); 

        float SSSScaleX = SubsurfaceParams.x;
        float scale = SSSScaleX / OutDepth;

        //Calculate the final step to fetch the surrounding pixels
        float2 finalStep = scale * dir;

        finalStep *= SSSStrength;  // Modulate it using the opacity (0..1 range)

        // 0..255, which SubSurface profile to pick
        // ideally this comes from a half res buffer as well - there are some minor artifacts
        uint SubsurfaceProfileInt = ExtractSubsurfaceProfileInt(BufferUV);

        // Accumulate the center sample:
        float3 colorAccum = 0;
        // >0 to avoid division by 0, not 100% correct to not visible
        float3 colorInvDiv = 0.00001f;

        //center sample
        colorInvDiv += GetSubsurfaceProfileKernel(SSSS_N_KERNELWEIGHTOFFSET, SubsurfaceProfileInt).rgb;     
        colorAccum = colorM.rgb * GetSubsurfaceProfileKernel(SSSS_N_KERNELWEIGHTOFFSET, SubsurfaceProfileInt).rgb; 

        float3 BoundaryColorBleed = GetSubsurfaceProfileBoundaryColorBleed(SubsurfaceProfileInt); 

        [unroll]
        for (int i = 1; i < SSSS_N_KERNELWEIGHTCOUNT; i++)
        {
            // Kernel.a = 0..SUBSURFACE_KERNEL_SIZE (radius)
            half4 Kernel = GetSubsurfaceProfileKernel(SSSS_N_KERNELWEIGHTOFFSET + i, SubsurfaceProfileInt);

            float4 LocalAccum = 0;

            float2 UVOffset = Kernel.a * finalStep;

            [unroll]
            for (int Side = -1; Side <= 1; Side += 2)   //The kernel is symtrical 
            {
                // Fetch color and depth for current sample:
                float2 LocalUV = BufferUV + UVOffset * Side;
                float4 color = GetSceneColor(LocalUV);
                uint LocalSubsurfaceProfileInt = GetSubsurfaceProfileId(LocalUV);
                float3 ColorTint = LocalSubsurfaceProfileInt == SubsurfaceProfileInt ? 1.0f : BoundaryColorBleed;

                float LocalDepth = color.a;
                color.a = GetMaskFromDepthInAlpha(color.a);

                // If the difference in depth is huge, we weight the sample less or not at all
                float s = saturate(12000.0f / 400000 * SubsurfaceParams.y *
                //float s = saturate(300.0f/400000 * SubsurfaceParams.y *
                    abs(OutDepth - LocalDepth));

                color.a *= 1 - s;

                // approximation, ideally we would reconstruct the mask with GetMaskFromDepthInAlpha() and do manual bilinear filter
                // needed?
                color.rgb *= color.a * ColorTint;

                // Accumulate left and right 
                LocalAccum += color;
            }

            // Accumulate to final value (left and right sample with the same weight)
            colorAccum += Kernel.rgb * LocalAccum.rgb;
            colorInvDiv += Kernel.rgb * LocalAccum.a;
        }

        // normalize (some samples are rejected because of depth or the other material is no SSS, compensate for that)
        // done for each color channel to avoid color shift
        float3 OutColor = colorAccum / colorInvDiv; 

        // alpha stored the SceneDepth (0 if there is no subsurface scattering)
        return float4(OutColor, OutDepth);
    }

    return (float4)0.0f;
}

//#define SUBSURFACE_PASS_ONE

[numthreads(THREAD_SIZE_X * THREAD_SIZE_Y, 1, 1)]
void MainIndirectDispatchCS(uint3 IndirectG_ID : SV_GroupID, uint GI : SV_GroupIndex)
{
    uint2 G_ID = uint2(GroupBuffer[2*(IndirectG_ID.x + 1) + 0], GroupBuffer[2 * (IndirectG_ID.x + 1) + 1]);         //获取目标GroupID 
    uint2 DT_ID = G_ID * float2(THREAD_SIZE_X, THREAD_SIZE_Y) + float2(GI % THREAD_SIZE_X, GI / THREAD_SIZE_X);     //解码获取目标 DispatchThreadID 

    uint2 Pos = DT_ID.xy * SUBSURFACE_GROUP_SIZE / THREAD_SIZE_1D + Output_ViewportMinMax.xy;  //buffer position 
    float2 BufferUV = ConvertGridPos2UV(Pos);

    //float4 Input_ExtentInverse;     //[pixelSizeX, pixelSizeY, 1/pixelSizeX, 1/pixelSizeY] -> half res 
    //float4 Input_ViewportSize;      //[pixelSizeX, pixelSizeY, 0, 0] -> half res 
    #ifdef SUBSURFACE_PASS_ONE
        //horizontal 
        float2 ViewportDirectionUV = float2(1, 0) * SUBSURFACE_RADIUS_SCALE;
    #else
        //vertical 
        float2 ViewportDirectionUV = float2(0, 1) * SUBSURFACE_RADIUS_SCALE * (Input_ExtentInverse.x * Input_ExtentInverse.w);
    #endif

    ViewportDirectionUV *= (Input_ViewportSize.x * Input_ExtentInverse.z); 

    float4 OutColor = SSSSBlurPS(BufferUV, ViewportDirectionUV, false);

    #ifdef SUBSURFACE_PASS_ONE
        //do nothing 
    #else
        // second pass prepares the setup from the recombine pass which doesn't need depth but wants to reconstruct the color
        OutColor.a = GetMaskFromDepthInAlpha(OutColor.a); 
    #endif

    if (all(Pos < Output_ViewportMinMax.zw))
    {
        SSSColorUAV[Pos] = OutColor;
    }

    return;
}
