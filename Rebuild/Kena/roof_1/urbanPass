Forward+ -> TODO -> could replace Deffered pass 
Class based rendering -> Tile based rendering 
TODO -> 看材质名 
以下内容来自：DC=2183   ->  关注输出 Tex 8264 
本DC主要负责 GI 效果 -> 不处理直接光照 
备注1：对于DC=2181   ->  Tex 8269  ->  可能是上一帧的输出 
备注2：SSAO 的DC = 2091 -> 输出到 Tex 8232 上 -> 再通过DC=2903 输出到 单通道的 Tex 6681 上

//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Position              0   xyzw        0      POS   float   xy w
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[10], immediateIndexed
dcl_constantbuffer CB1[201], immediateIndexed
dcl_constantbuffer CB2[1], immediateIndexed
dcl_constantbuffer CB3[4], immediateIndexed
dcl_constantbuffer CB4[1023], dynamicIndexed
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_sampler s2, mode_default
dcl_sampler s3, mode_default
dcl_sampler s4, mode_default
dcl_sampler s5, mode_default
dcl_sampler s6, mode_default
dcl_sampler s7, mode_default
dcl_resource_texturecube (float,float,float,float) t0 			-> 天空 
dcl_resource_texturecube (float,float,float,float) t1 			-> cubemap 几乎全黑 
dcl_resource_texturecubearray (float,float,float,float) t2 	-> 确认是 IBL 探针，有 57 张 
dcl_resource_buffer (uint,uint,uint,uint) t3  					    -> 似乎是一张映射表 
dcl_resource_buffer (uint,uint,uint,uint) t4 
dcl_resource_texture2d (float,float,float,float) t5				-> BRDF LUT 
dcl_resource_texture2d (float,float,float,float) t6 			-> [NormalWS.xyz, DepthWS] 看起来像被模糊过，且分辨率减半 
																	                             -> 后续可能关联计算: Motion Blur;  Depth of Field; ... 
dcl_resource_texture2d (float,float,float,float) t7 			-> Depth01 (R通道) 
dcl_resource_texture2d (float,float,float,float) t8 			-> [NormalWS.xyz, 0.333(?当前pass没有使用)] 
dcl_resource_texture2d (float,float,float,float) t9 			-> [PurpleRGB.y(Rough1), 0.2(Intensity), P.y偏移值(用作Flag), 0.694118(Rough2)] 
																	                             -> Rough2用于采样LUT 
dcl_resource_texture2d (float,float,float,float) t10 			-> [去除强度的BaseColor.rgb, 随机化处理的PurpleRGB.z(AO)] 
dcl_resource_texture2d (float,float,float,float) t11   		-> 似乎区分了角色+衣服+树叶, 其他为黑 -> 动态vs静态? 
																	                             -> [Frsnel_Flag, Rough_3(用于采样LUT), ?, ? ] 
																	                             -> 是否与sss有关? 
																	                             -> X 通道似乎是控制 Fresnel 效果用, Y被当做粗糙度来使用, 
dcl_resource_texture2d (float,float,float,float) t12 			-> 似乎是自发光或高光相关的值 -> 4通道 
dcl_resource_texture2d (float,float,float,float) t13 			-> AO (R通道) -> SSAO Pass 获取 

dcl_input_ps_siv linear noperspective v0.xyw, position 		-> 全屏Blit对应的 VertexInputPS 
dcl_output o0.xyzw 												                -> 输出纹理 T:8264 
dcl_temps 20 


mul r0.xy, v0.xyxx, cb1[131].zwzz  		屏幕像素序号xy * 像素倒数  ->  用于采样贴图的屏幕 UV 

//r1.xy -> 经过如下变换后，r1.xy 介于 ScreenSpace & ClipSpace 之间... 
//注意 v0.w 对应全屏 Blit 使用的三角形面片的视深度 
add r0.zw, v0.xxxy, -cb1[129].xxxy                              -> cb1[129].xy = 0 		-> v0.xy 是屏幕像素索引(+0.5) 
mad r1.xy, r0.zwzz,  [130].zwzz, l(-0.5, -0.5, 0.0, 0.0) 		    -> v0.xy / [height, width] - [0.5, 0.5] -> [-0.5, +0.5]区间UV 
mul r1.xy, r1.xyxx, v0.wwww    	                                -> [-0.5, +0.5] * v0.w 	-> v0.w = Clip.w 
mul r1.xy, r1.xyxx, l(2.000000, -2.000000, 0.000000, 0.000000)  -> [-1.0, +1.0] * v0.w -> 上下翻转 -> 预乘"三角面片深度"的半成品 

sample_l_indexable(texture2d)(float,float,float,float) r2.xyz, r0.xyxx, t8.xyzw, s0, l(0.000000) 	  -> Normal, 0.33 
sample_l_indexable(texture2d)(float,float,float,float) r3.xyzw, r0.xyxx, t9.xywz, s0, l(0.000000) 	-> rough1, 0.2, Flag, 0.69(rough2) 
sample_l_indexable(texture2d)(float,float,float,float) r4.xyzw, r0.xyxx, t10.xyzw, s0, l(0.000000) 	-> BaseColor.rgb, P.z(AO) 
sample_l_indexable(texture2d)(float,float,float,float) r5.xyzw, r0.xyxx, t11.xyzw, s0, l(0.000000)  -> 0,0,0,0 
sample_l_indexable(texture2d)(float,float,float,float) r1.z, r0.xyxx, t7.yzxw, s0, l(0.000000)    	-> 深度 R1.Z 

//Decode Depth 
//原始采样获得的 R1.z 应该是编码后的0-1范围视空间深度，解码后输出R1.Z 推测等于 HClip.w
//HClip.w 在Unity中等于viewSpace中物体z轴取反，在UE4中直接等于视空间z轴值 
//注意: UE4 默认距离单位 = 厘米 ，所以解码后的 R1.Z 基本上取值大于 100, 既大于1米 
mad r1.w, r1.z, cb1[65].x, cb1[65].y   								 -> 0 
mad r1.z, r1.z, cb1[65].z, -cb1[65].w  								 -> 0.1 * depthRaw 
div r1.z, l(1,1,1,1), r1.z 			                       -> 1/(0.1*depthRaw) 
add r1.z, r1.z, r1.w 												           -> 1/(0.1*depthRaw) + (depthRaw*a+b) 

mul r6.xy, r0.xyxx, cb1[131].xyxx 
ftou r6.xy, r6.xyxx 			  -> 当前像素坐标索引 

//Condition: 某种 2x2 块状像素分割逻辑 
ftou r1.w, cb1[151].x 			-> 1 
iadd r2.w, r6.y, r6.x 			-> x + y 
iadd r1.w, r1.w, r2.w 			-> x + y + 1 
and r1.w, r1.w, l(1)        -> 判断奇偶?  ->  某种棋盘状分割逻辑 

//法线 
mad r2.xyz, r2.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), l(-1.000000, -1.000000, -1.000000, 0.000000) 
dp3 r2.w, r2.xyzx, r2.xyzx
rsq r2.w, r2.w
mul r6.xyz, r2.wwww, r2.xyzx   -> R6 

//r3.zy = [Purple.y修改值, T9.y(0.007/0.14/0.2/0.49 ~ 0.607)] 
//利用采样 T9 纹理的 Z 通道，获取当前urbanPass分支逻辑控制符 
//利用采样 T9 纹理的 Y 通道，计算环境光底色 
mul r7.xy, r3.zyzz, l(255.000000, 0.080000, 0, 0)  	-> 255用于将8bit通道转换到整数范围，0.08推测是环境光缩放因子 
round_ne r6.w, r7.x     						                -> 四舍五入到整数float值 ->  颜色[0~255] 
ftou r6.w, r6.w 
and r7.xz, r6.wwww, l(15, 0, 16, 0)   			        -> (Z= r6.w & 10000) -> 筛选出第五bit位=0或1的值； (X= r6.w & 1111) -> 返回:[0~15] 
movc r5.xyzw, r7.zzzz, l(0,0,0,0), r5.xyzw  	      -> 依据倒数第5个bit符号位, 判断是否要启用 T11 纹理的数据 
ieq r8.xyz, r7.xxxx, l(9, 5, 4, 0)    			        -> Condition: r7.x 返回值是否落在给定区间 
movc r6.w, r8.x, l(0), r3.x    					            -> r3.x=rough1 -> factor_RoughOrZero: 若为9号材质则为0, 其余来自纹理T9.x(既rough1) (T9.x: roof和腰带,头发,裤有值) 
mad r9.xyz, -r3.yyyy, l(0.08, 0.08, 0.08, 0), r4.xyzx  		-> BaseCol.rgb - T9.y * 0.08 -> 不妨定义 base_intensity = 0.08 * T9.y
mad r9.xyz, r6.wwww, r9.xyzx, r7.yyyy   		        -> lerp(base_intensity.xxx, BaseColor.xyz, factor_RoughOrZero) 
												                            -> df_inten_base 颜色 似乎是环境光基础强度分布 
                                                    -> 推测T9.x(所代表的粗糙度rough1) -> 用于计算GI_Diffuse部分中的基础辐射强度(待考) 

or r7.y, r8.x, r8.y 							                  -> Condition: 比 r8 单个通道几率更高 -> 是 9号 或 5号 材质渲染方案的话 
lt r7.z, l(0.000000), cb1[155].x 				            -> 0 < cb1[155].x ? 
lt r7.w, l(0.000000), cb1[200].z  			            -> 0 < cb1[200].z ? 
and r7.z, r7.w, r7.z  
ne r7.w, l(0, 0, 0, 0), cb1[155].x  	              -> true 
movc r8.xyw, r7.wwww, l(1,1,0,1), r4.xyxz		        -> r8.xyw = 1 or BaseCol.rgb 

//构建了 R10 颜色/遮罩 -> TODO 
movc r10.xy, r1.wwww, l(1,0,0,0), l(0,1,0,0) 	-> 根据间隔的像素进行选择和分割 -> r10.xy = [1,0] or [0,1] -> 间隔Mask 
mul r11.xyz, r9.xyzx, r10.yyyy 
mul r11.w, r3.y, r10.y 		 					          -> R11 -> [df_inten_base.xyz, T9.y(rifr.y)] * 方块Mask.y 
movc r10.xyz, r7.zzzz, r10.xxxx, r8.xywx 		  -> R10 颜色 -> 要么是 方块Mask.x 既[0 or 1] (√)，要么 BaseCol.rgb 
mov r9.w, r3.y 
movc r11.xyzw, r7.zzzz, r11.xyzw, r9.xyzw 		-> R11 -> [df_inten_base*方块Mask.y] (√) 还是 [df_inten_base.rgb, 0.2] 
mov r10.w, r11.w 								              -> R10 颜色透明通道 = 0.2 * 方块Mask.y -> rgba = [0,0,0,0.2] or [1,1,1,0] 
mov r12.xyz, r4.xyzx 							            -> R12 颜色 = BaseCol.rgb 
mov r12.w, r9.w 								              -> R12 颜色.Alpha = R11.w = r3.y = T9.y ~ 0.2 
movc r10.xyzw, r7.yyyy, r10.xyzw, r12.xyzw 		-> 新 R10 = 概率选 R10 或 R12=[BaseCol.rgb, 0.2] -> 是9号或5号方案就选10 

//重构世界坐标 
//先通过 [-1, +1] * Clip.w * View.z 计算出 Clip Space 下当前点xy，随后结合采样深度z重建世界空间坐标 
//注意1: 矩阵运算的目标向量处在Clip Space中，所以变换矩阵理应是 Inv_VP，且UE4的P矩阵只修改了XY分量(最后一列为[0,0,1,0])，保留Z分量不动 
//注意2: r1.xy 一直保持在 [-1, +1] * Clip.w 状态 
mul r4.xy, r1.zzzz, r1.xyxx 				          -> R4.xy -> ClipSpace.xy -> [-1, +1] * (Clip.w * View.z) 
mul r8.xyw, r4.yyyy, cb1[49].xyxz 			      -> cb1[49] ~ cb1[50] -> Matrix_Inv_VP -> 将物体从裁剪空间转回世界空间的矩阵 
mad r4.xyz, r4.xxxx, cb1[48].xyzx, r8.xywx 
mad r4.xyz, r1.zzzz, cb1[50].xyzx, r4.xyzx 
add r4.xyz, r4.xyzx, cb1[51].xyzx 			      -> 最后一列存有: 'CameraPosWS' 
											                        -> toCameraVector= (inverse(viewMatrix)*vec4(0,0,0,1.0)).xyz-worldPosition.xyz; 

//-ViewDirWS -> R8 -> From Camera To ViewPoint 
add r8.xyw, r4.xyxz, -cb1[67].xyxz    	      -> 摄像机的世界空间坐标[-58890, 27509, -6150] 
dp3 r1.w, r8.xywx, r8.xywx 
rsq r1.w, r1.w 
mul r8.xyw, r1.wwww, r8.xyxw 				          -> 归一化 


//计算不同材质的参数 R7.Z 和 R9.W：基于NdotV，掠视时值小， 俯视时值大 
//参数用于表现GI下物体表面漫反射强度 -> Diffuse部分 -> 一般基于 NdotV 
dp3 r1.w, r6.xyzx, -r8.xywx  					        -> NdotV -> Normal 和 ViewDir 都是单位向量，所有点乘后得到 cosθ 
mov_sat r3.x, r1.w   							            -> saturate(NdotV) = NdotV -> 做sat似乎没必要 
mad r7.z, r3.x, l(0.500000), l(0.500000)    	-> NdotV * 0.5 + 0.5 
mad r7.z, r7.z, r3.x, l(-1.000000) 				    -> (NdotV * 0.5 + 0.5) * NdotV - 1  -> 若(V ⊥ N) 得-1，反之得0 
mad_sat r7.w, -r3.w, l(1.250000), l(1.250000)	-> saturate(1.25 - 1.25*[t9.w=0.69]) -> 不同材质不同缩放比例 
mul r9.w, r7.w, r7.z 							            -> saturate(1.25 - 1.25*[t9.w=0.69]) * ((NdotV*0.5+0.5)*NdotV-1) -> [-1, 0]区间 
mad r7.z, r7.z, r7.w, l(1.000000) 				    -> 定义为 NoV_nearOne -> 类似 NoV -> 转换到 [0, 1] 区间，边缘暗中间亮，整体数值靠近1 

//将 R10 颜色 与 NdotV 以某种形式混淆 
//基于R10颜色生成的 -> R13 属于 [0.15, 1.01]区间; R12 属于 [0, 1.11]区间 
//另外，(col^2 - col)*t + col -> 这种模式的颜色操作等效于对原始颜色进行 "非线性提亮" 
//中间变量 R13 特性: 当垂直看时三通道都为1，掠射时各通道按比例衰减一定幅度 
//输出 R12 颜色 按照视角的大小，表现出由暗到明(原始色)的过渡 
mul r12.xyz, r10.xyzx, l(1.111111, 1.111111, 1.111111, 0.000000)  				-> R12 颜色 = R10 颜色 * 1.11 -> "线性提亮" 
add r7.w, r3.x, l(-1.000000) 													                    -> NdotV - 1 
mul r7.w, r7.w, l(0.850000) 													                    -> 0.85 * (NdotV - 1) -> [-0.85, 0]区间 
mad r13.xyz, r12.xyzx, r12.xyzx, -r12.xyzx 						                    -> (R12)^2 - R12 -> [-0.25, 0.1221]区间 
mad r13.xyz, r13.xyzx, l(-0.780000, -0.780000, -0.780000, 0.000000), r12.xyzx   -> R12-0.78*[(R12)^2 - R12] -> [0, 1.01]区间 
add r13.xyz, -r13.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000) 				-> 1-{R12-0.78*[(R12)^2 - R12]}->[-0.01, 1]区间 
mad r13.xyz, r7.wwww, r13.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000) -> R13=0.85*(NdotV-1)*{1+0.78*[(R12)^2 - R12]-R12} + 1 
mul r12.xyz, r12.xyzx, r13.xyzx 												                  -> R12 颜色 = R12 * R13 

//r5.x 来自 T11，既纹理11 (叶子+人物有颜色，其他为黑的纹理)，似乎用来控制(开关) 菲尼尔效果的Flag 
//如下的 r12.w 构成了 Shilick Fresnel 的核心元素: (1 - cosθ)^5, 而 r7.w 关联 Fresnel_Term (可通过函数曲线验证) 
//r7.z 与 r7.w 相比，随着视角倾斜，数值下降趋势比较缓和 
//对于屋顶和木墙而言，输出颜色 R12 任然只是趋向 R10 
//而树叶之类，其输出颜色 R12 受到Fresnel影响比较大 
add r7.w, -r3.x, l(1.000000)  				  -> 1 - sat(NdotV) -> [0, 1] 
mul r11.w, r7.w, r7.w 						      -> (1 - NdotV)^2 
mul r11.w, r11.w, r11.w 					      -> (1 - NdotV)^4 
mul r12.w, r7.w, r11.w 						      -> R12.w = (1 - NdotV)^5 -> Fresnel_Term
mad r7.w, -r11.w, r7.w, l(1.000000)   
mad r7.w, r7.w, l(0.040000), r12.w  		-> lerp((1 - NdotV)^5, 1, 0.04) 
mad r7.w, r5.x, -r7.w, l(1.000000) 			-> 1 - Fresnel_Term * T11.x(frxx.x) -> 取反色(且屏蔽了除人和草叶以外的物件) 
mul r13.xyz, r7.wwww, r10.xyzx 				  -> R13 = R10颜色 * (1 - Fresnel_Term) -> (R10颜色) * (类似 NoV 效果的乘子) 
mul r12.xyz, r7.zzzz, r12.xyzx 				  -> R12颜色 * NoV_nearOne -> (NoV_nearOne: NoV关联项，但比原始NoV亮)  
mul r7.z, r5.x, r6.w 						        -> r7.z = T11.x * factor_RoughOrZero -> 2个遮罩叠加后 -> 突出了人物 
mad r12.xyz, r12.xyzx, l(0.90, 0.90, 0.90, 0.0), -r13.xyzx  -> R12 = 0.9 * R12颜色 - R13颜色 -> 用减号形成Fresnel现象 
mad r12.xyz, r7.zzzz, r12.xyzx, r13.xyzx 	-> lerp(R13, R12, T11.x*factor_RoughOrZero) -> 人物像素使用R13颜色，其余用R12  

//采样 AO -> R7.z  
sample_l_indexable(texture2d)(float,float,float,float) r7.z, r0.xyxx, t13.yzxw, s7, l(0.000000) 

//求半分辨率下的 UV 
mad r13.xy, -cb1[129].xyxx, cb1[131].zwzz, r0.xyxx 						-> 屏幕UV - 0 * (屏幕长宽的倒数) -> UV 偏移 
min r13.xy, r13.xyxx, cb0[6].xyxx 										        -> 不能超过 0.998 -> 确保在像素中点位置? 
mul r13.zw, cb1[131].xxxy, l(0, 0, 0.500000, 0.500000) 	      -> 求 "半" 屏幕的长宽 
round_ni r13.zw, r13.zzzw  												            -> floor("半"屏幕的长宽) 
div r14.xy, l(1,1,1,1), r13.zwzz 		                          -> "半"屏幕的长宽 の 倒数 
mad r15.xy, r13.xyxx, r13.zwzz, l(-0.5, -0.5, 0, 0) -> 正常屏幕UV * "半"屏幕的长宽 - 0.5 -> '大'像素位置, 注意可能移到左/下邻'大'像素  
round_ni r15.xy, r15.xyxx 												            -> floor("半"屏幕下的像素位置) , 最小为 0 
div r15.xy, r15.xyxx, r13.zwzz 											          -> 新UV, 采样率相对原始UV减半，位置在田字格的左下角(真角落)  
mad r15.xy, r14.xyxx, l(0.500000, 0.500000, 0, 0), r15.xyxx   -> 增加1小像素偏移 -> 让当前降采样UV对准田字格正中心 
add r13.xy, r13.xyxx, -r15.xyxx   				                    -> 正常采样的当前点UV - 半分辨率UV = UV_delta -> 田的中心点到实际当前像素距离 
mul r15.zw, r13.zzzw, r13.xxxy					                      -> 半分辨率下 UV_delta 占用了(0.25或0.75)个大像素点长度 

//采样 T6 (疑似NormalWS纹理, 本身分辨率为原始值的一半) 
//采样了田字四邻域，分布存放在 R16,R17,R18和R14中 
//注意，降分辨率下的一个田字的每个口，都代表正常分辨率下的一个田 -> 采样覆盖正常分辨率下16邻域 
sample_l_indexable(texture2d)(float,float,float,float) r16.xyzw, r15.xyxx, t6.xyzw, s5, l(0.000000) 
mov r14.z, l(0)  						                                  -> r14.xyz = ["半"屏幕的长宽の倒数, 0]; r15.xy = [降采样后当前点UV] 
add r17.xyzw, r14.xzzy, r15.xyxy		                          -> r17.xyzw = [降采样后U + 1, 降采样后V, 降采样后U, 降采样后V + 1] 
sample_l_indexable(texture2d)(float,float,float,float) r18.xyzw, r17.xyxx, t6.xyzw, s5, l(0.000000) 
sample_l_indexable(texture2d)(float,float,float,float) r17.xyzw, r17.zwzz, t6.xyzw, s5, l(0.000000) 
add r14.xy, r14.xyxx, r15.xyxx    		                        -> r14.xy = [UV + 一个像素] 
sample_l_indexable(texture2d)(float,float,float,float) r14.xyzw, r14.xyxx, t6.xyzw, s5, l(0.000000) 

//这里从T6纹理(半分辨率) W 通道获取 Depth_1，拿来和(全分辨率下)深度图的 Depth_2 求差异 
//最后基于当前像素在田字格位置，加权求和 Diff_Depth，存入 R7.w 
// r13 = [UV_delta, "半"屏幕的长宽] 
mad r13.xy, -r13.yxyy, r13.wzww, l(1,1,0,0)	                          -> (1 - 大像素_delta).yx 
mul r19.x, r13.y, r13.x  				                                      
mul r19.yz, r15.zzwz, r13.xxyx 			                                  
mul r19.w, r15.z, r15.w 				                                      -> 从功能上看，r19.xyzw 分别对应田字中左下，右，上和右上4个方位上像素(深度)的衰减值 
mov r13.x, r16.w 						                                          
mov r13.y, r18.w
mov r13.z, r17.w
mov r13.w, r14.w                                                      -> R13 = [左下, 上，右, 右上].(看起来像距离参数，数值普遍大于100，天空在65530附近) 
add r13.xyzw, -r1.zzzz, r13.xyzw 		                                  -> R13 = 田字4个位置的: T6纹理存的Depth - 当前帧深度纹理解码的Depth 
add r13.xyzw, |r13.xyzw|, l(0.000100, 0.000100, 0.000100, 0.000100) 	-> 给 Diff_Depth 加上一个很小的正数，确保都大于0 
div r13.xyzw, l(1.000000, 1.000000, 1.000000, 1.000000), r13.xyzw 		-> Diff_Depth の 倒数 
mul r13.xyzw, r13.xyzw, r19.xyzw 										                  -> 基于当前像素在田字格中位置，修正4个 (1/D_Depth) 
dp4 r7.w, r13.xyzw, l(1.000000, 1.000000, 1.000000, 1.000000) 			  -> 求和田字格区域的这 4个 (1/D_Depth) 
div r7.w, l(1.000000, 1.000000, 1.000000, 1.000000), r7.w 				    -> 相当于求解了4个 Diff_Depth 通道之和的倒数 -> 求平均乘子 -> 定义为 g_depth_factor

mul r15.xyz, r18.xyzx, r13.yyyy 			       	-> 对应田字位置的 (1/D_Depth) * 对应位置的采样结果.xyz 
mad r15.xyz, r13.xxxx, r16.xyzx, r15.xyzx 		-> 4个位置的结果累加起来 -> R13 
mad r13.xyz, r13.zzzz, r17.xyzx, r15.xyzx 
mad r13.xyz, r13.wwww, r14.xyzx, r13.xyzx     -> d_norm -> 田字4方向独自通过(1/D_Depth)累加后 * D_Depth加权平均

add r11.w, -r1.z, cb0[2].w 						        -> 20000 - 当前帧深度纹理解码的Depth 
mul_sat r11.w, r11.w, cb0[3].x 					      -> saturate((20000-Depth)/6000) -> 用于Scale，距离近:1，距离远:0 
mov r14.xyz, -r6.xyzx 							          -> R14 = -Normal 
mad r13.xyz, r13.xyzx, r7.wwww, r14.xyzx 
mad r13.xyz, r11.wwww, r13.xyzx, r6.xyzx 		  -> R13 = lerp(norm, d_norm * g_depth_factor, scale) 


if_nz r7.x  	                                            -> 对于 #1 ~ #15 号渲染通道来说都能进入 

  //GI_Diffuse_Col -> R15 
  mad r15.xyz, -r10.xyzx, r6.wwww, r10.xyzx 				      -> R10颜色 - R10颜色 * factor_RoughOrZero 
  mad r15.xyz, r15.xyzx, cb1[135].wwww, cb1[135].xyzx 
  mad r16.xyz, -r12.xyzx, r6.wwww, r12.xyzx 				      -> R12颜色 - R12颜色 * factor_RoughOrZero 
  movc r15.xyz, r8.zzzz, r16.xyzx, r15.xyzx 				      -> Condition 如果是 4号 材质方案的话，使用R16颜色，不然就用R15 

  dp3 r7.w, r13.xyzx, r13.xyzx 
  sqrt r7.w, r7.w
  max r11.w, r7.w, l(0.000010)
  div r16.xyz, r13.xyzx, r11.wwww                         -> 归一化 d_norm 扰动法线向量 -> R16 -> 定义为 RebuiltedNorm 或 (Rn) 

  //计算 bias_N -> 后续会用到 
  mad r17.xyz, r2.xyzx, r2.wwww, -r16.xyzx  
  mad r17.xyz, r7.wwww, r17.xyzx, r16.xyzx 					-> lerp(RN, norm, RN_Len) -> 平坦表面使用norm，边缘以及陡峭表面使用RN

  //计算标量r11.w -> 无扰动时=1, 强扰动时 = RN_Len 既RN向量的模长 
  dp3 r11.w, r16.xyzx, r6.xyzx 								      -> Dot(扰动法线向量, NormalWS) -> NdotRn 
  add r12.w, -r11.w, l(1.000000) 
  mad r11.w, r7.w, r12.w, r11.w  							      -> lerp(NdotRn, 1, RN_Len)

  //求取 AO_final -> r7.w
  mad r7.w, r7.w, l(10.000000), l(-5.000000)   			-> 扰动向量模长 * 10 - 5 
  mul r7.w, r7.w, -cb0[8].x 								        -> (扰动向量模长 * 10 - 5) * (-0.01) 
  mul r7.w, r7.w, l(1.442695) 								      -> -1.442695 * (10*模长 - 5) / 100 -> Log2E = 1.442695 
  exp r7.w, r7.w 											              -> exp((5 - 10*模长) / 100) 	-> 这里假设 exp 实际上是 exp2 
  add r7.w, r7.w, l(1.000000) 								      -> exp((5 - 10*模长) / 100) + 1 
  div r7.w, l(1,1,1,1), r7.w                        -> 1 / [exp((5 - 10*模长) / 100) + 1] 
  mad_sat r7.w, r7.w, cb0[8].y, cb0[8].z 					  -> saturate(40.0/[exp((5 - 10*模长) / 100) + 1] - 19.5) -> 记为X 
  log r7.w, r7.w 											              -> r7.w = LOG(X) -> 小于0的数 
  mul r7.w, r7.w, cb0[8].w 									        -> LOG(X) * 0.7 
  exp r7.w, r7.w 											              -> exp(LOG(X) * 0.7) -> X^0.7 
  add r12.w, -r7.w, l(1.000000) 
  mad r7.w, cb0[1].w, r12.w, r7.w 							    -> (1 - X^0.7) * 0 + X^0.7 -> lerp 

  eq r12.w, cb0[9].x, l(0.000000) 							    -> 1 != 0 -> r12.w = false 
  min r13.w, r4.w, r7.z 									          -> min(Tex_AO, Computered_AO) -> some AO value any way... 
  min r15.w, r7.w, r13.w 									          -> min(X^0.7, min(AO)) 	->  其中的 X^0.7 推测扮演了AO_noise的角色 
  mul r7.w, r7.w, r13.w 									          -> X^0.7 * min(AO) 
  movc r7.w, r12.w, r15.w, r7.w 							      -> r7.w 是 AO_final -> 通过开关在两种模式间切换: Min(AO1,AO2) 和 Mul(AO1,AO2) 

  ieq r16.xyzw, r7.xxxx, l(6, 2, 3, 7) 						  -> [Purple.y修改值] * 255 的后4个bit <-> [6,2,3,7] 
  if_nz r16.x 	                                    -> #6 号渲染通路对应的分支 
    mov r14.w, l(1.000000)  								        -> 在开始矩阵变换前将w通道设置为1 -> 代表这是对一个点(Point)进行空间变换 
    dp4 r18.x, cb1[181].xyzw, r14.xyzw 						  -> 对 (-Normal) 的顶点进行空间变换 -> R18 
    dp4 r18.y, cb1[182].xyzw, r14.xyzw 
    dp4 r18.z, cb1[183].xyzw, r14.xyzw 

    mul r14.xyzw, r6.yzzx, r6.xyzz        					-> Normal.yzzx * Normal.xyzz -> 产生一个基于Normal的向量(?) 
    dp4 r19.x, cb1[184].xyzw, r14.xyzw 						  -> 对这个基于Normal的向量顶点进行另一种空间变换 -> R19 
    dp4 r19.y, cb1[185].xyzw, r14.xyzw 
    dp4 r19.z, cb1[186].xyzw, r14.xyzw 

    mul r12.w, r6.y, r6.y
    mad r12.w, r6.x, r6.x, -r12.w  							    -> Normal.x^2 - Normal.y^2 
    add r14.xyz, r18.xyzx, r19.xyzx 						    -> R18 + R19 
    mad r14.xyz, cb1[187].xyzx, r12.wwww, r14.xyzx 	-> [-0.016, -0.01, -0.003] * (Normal.x^2 - Normal.y^2) + (R18 + R19) -> R14 
    max r14.xyz, r14.xyzx, l(0,0,0,0)						    -> 推测 R14是一个基于 Normal 的随机向量，且指向正半球空间 
    mul r14.xyz, r14.xyzx, cb1[180].xyzx 	          -> cb1[180]=[4.9, 4.1, 3.1] 是个老朋友,后面会多次出现,推测是'阳光'这类全局控制/缩放因子 
    mul r18.xyz, r5.xyzx, r5.xyzx 							    -> T11.xyz^2 -> 只对人物(还有草叶等)生效的遮罩 
    														                    -> T11纹理的xy通道分别是Flag位和Rough -> 后续作为乘子缩放 R14 
    mul r14.xyz, r7.wwww, r14.xyzx  		            -> 对 R14 使用环境光遮蔽 AO_final -> 合成AO  
    mul r14.xyz, r18.xyzx, r14.xyzx 						    -> 对 R14(合成AO) 应用 来自 T11.xyz^2 遮罩 -> 只对人物(还有草叶等)生效 
  else 
    mov r14.xyz, l(0,0,0,0)  								        -> 不是 6号渲染通道的话，R14 (合成AO) = 0 
  endif 

  or r12.w, r16.z, r16.y 									          -> 2个渲染分支条件满足一个即可，既r12.w用于控制 r16.zy 所对应分支的渲染 
  mul r16.xyz, r5.xyzx, r5.xyzx                     -> T11.xyz^2 
  mad r18.xyz, r5.xyzx, r5.xyzx, r15.xyzx  					-> T11.xyz^2 + r15颜色 
  movc r15.xyz, r12.wwww, r18.xyzx, r15.xyzx 				-> Condition: 选择 (r5^2 + r15颜色) or r15颜色 

  //以下分支计算用于 新的 R15 颜色 
  if_nz r16.w 												              -> r16.w 分支控制 -> 7号材质 
  	//以下片段代码用于求 -ViewDir -> 既视方向的反方向 -> 从摄像机指向视点的归一化向量  
  	//r1.xy 存放了 [-1, +1] * Clip.w -> 没有乘具体Depth -> 全屏Blit使用的三角形片所处的深度切片，xy分量在那个深度上是正确的
    mul r18.xyz, r1.yyyy, cb1[49].xyzx						    -> Matrix_Inv_VP 的前 3X3 区域 
    mad r18.xyz, r1.xxxx, cb1[48].xyzx, r18.xyzx			-> 相当于将视空间坐标的 z 分量设置为1 
    add r18.xyz, r18.xyzx, cb1[50].xyzx    				 	  -> 然后以行向量形式 左乘 逆矩阵中控制旋转和缩放的部分 
    dp3 r1.x, r18.xyzx, r18.xyzx 
    rsq r1.x, r1.x 
    mul r18.xyz, r1.xxxx, r18.xyzx 							      -> 再归一化 -> 得到 -ViewDirWS -> 疑惑:为何不用 CamWS - PosWS 

    //求 ‘视-切向量’ 
    dp3 r1.x, -r18.xyzx, r6.xyzx 							        -> NdotV -> 注意，这是没有saturate的NoV 
    mad r19.xyz, -r6.xyzx, r1.xxxx, -r18.xyzx 				-> NdotV * -Normal + ViewDir -> <视-切向量> -> viewTangentRaw 
    dp3 r1.y, r19.xyzx, r19.xyzx
    rsq r5.z, r1.y
    mul r17.xyz, r5.zzzz, r19.xyzx 							      -> 归一化 <视-切向量> -> viewTangent //此处顺便覆写了 r17.xyz -> bias_N -> 后续会用到 

    //控制粗糙度范围 
    max r5.z, r3.w, l(0.003922) 							        -> max([t9.w=0.69], 0.0039) -> roughness -> 来自rifr纹理的最后一个通道(rough2) 
    min r5.z, r5.z, l(1.000000) 							        -> min(0.69, 1.0) -> 粗糙度控制在[0,1]内 

	  //TdotV -> 视线趋向掠射角和垂直时都得0 
    dp3 r12.w, -r18.xyzx, r17.xyzx 	 

    //TdotN -> 掠射视角时得-1，垂直平面时得0 
    dp3 r13.w, r6.xyzx, r17.xyzx 							 

    //以下代码为: fast_acos(float v) -> 搜索关键数值'-0.156583'可得相关资料 
    //π/2 = 1.570796
    mad r14.w, |r1.x|, l(-0.156583), l(1.570796) 			-> -0.156583 * |NdotV| + 1.570796
    add r15.w, -|r1.x|, l(1.000000) 						      -> 1 - |NdotV|
    sqrt r15.w, r15.w 										            -> sqrt(1 - |NdotV|)
    mul r16.w, r14.w, r15.w 								          -> (-0.156583 * NdotV + 1.570796) * sqrt(1 - |NdotV|) -> 记A角度
    ge r18.x, r1.x, l(0.000000) 							        -> NdotV >= 0 ? true : false 
    mad r14.w, -r14.w, r15.w, l(3.141593) 					  -> π - (-0.156583 * NdotV + 1.570796) * sqrt(1 - |NdotV|)
    movc r14.w, r18.x, r16.w, r14.w 						      -> Condition: r14.w = A角度(true)  or  π-A角度(false) 
    add r14.w, -r14.w, l(1.570796) 							      -> 角度r14.w  -> N与V的夹角 

    //以下代码为: fast_acos(float v) 
    mad r15.w, |r13.w|, l(-0.156583), l(1.570796)
    add r16.w, -|r13.w|, l(1.000000)
    sqrt r18.x, r16.w
    mul r18.y, r15.w, r18.x
    ge r18.z, r13.w, l(0.000000)
    mad r15.w, -r15.w, r18.x, l(3.141593)
    movc r15.w, r18.z, r18.y, r15.w
    add r15.w, -r15.w, l(1.570796) 							      -> 角度r15.w -> N与<视-切向量>的夹角 -> 返回值恒为 π/2 

    //ang_NoV - ang_ToN 
    add r14.w, r14.w, -r15.w 								          -> dif_Angle = N与V的夹角 - N与<视-切向量>的夹角 
    mul r14.w, |r14.w|, l(0.500000)  						      -> 0.5 * |dif_Angle| 
    sincos null, r14.w, r14.w 								        -> cos(0.5 * |ang_NoV - ang_ToN|) 

    //求这些方向与水平方向的夹角余弦值，并在此基础上调整(cosθ)的取值范围 
    mad r18.xyz, -r13.wwww, r6.xyzx, r17.xyzx 				-> Normal * (-ToN) + viewTangent -> 还是 viewTangent -> 记为 dir_A
    dp3 r15.w, r18.xyzx, r19.xyzx 							      -> <viewTangentRaw> dot <dir_A> -> 相当于求viewTangentRaw的模长 
    dp3 r18.x, r18.xyzx, r18.xyzx 							      -> <dir_A> dot <dir_A> 
    mad r1.y, r18.x, r1.y, l(0.000100) 						    -> <dir_A>dot自己 * <viewTangentRaw>dot自己 + 0.0001 
    rsq r1.y, r1.y 											              -> 1 / sqrt(r1.y) 
    mul r1.y, r1.y, r15.w 									          -> <viewTangentRaw> dot <dir_A> / sqrt(r1.y) -> 相当于求 dir_A和viewTangentRaw夹角的余弦值 = 1 -> cos_AtoT 
    mad r18.xy, r1.yyyy, l(0.5, 17.0, 0, 0), l(0.5, -16.780001, 0, 0)	-> cosθ*(0.5,17) + (0.5,-16.78) = (0.5cosθ+0.5, 17cosθ-16.78) -> cos_AtoT_ST
    mov_sat r18.x, r18.x                              -> sat(cos_AtoT_ST.x)
    sqrt r1.y, r18.x 										              -> 这里对其中一个维度进行处理 -> sqrt(cos_AtoT*0.5+0.5) -> 简称为 sqrt_cosAtoTst -> 值恒为1 

    mul r15.w, r5.z, r5.z 									          -> roughness^2 = 0.69^2 = 0.476 
    mad r5.z, r5.z, r5.z, l(0.200000) 						    -> roughness^2 + 0.2 = 0.676 -> rough_factor_1
    mad r15.w, r15.w, l(2.000000), l(0.200000)				-> 2*roughness^2+0.2 = 1.152 -> rough_factor_2

    mad r18.z, -r1.x, r1.x, l(1.000000) 					    -> 1 - NdotV * NdotV = 1 - cosθ^2 = sinθ^2 
    sqrt r18.z, r18.z 										            -> sinθ -> θ:N与V夹角 
    mul r18.xw, r1.yyyx, l(0.997551, 0, 0, -0.069943) -> [0.997551, -0.069943] * (sqrt(cos_AtoT_ST.x), NdotV) 
    mad r18.x, r18.x, r18.z, r18.w 							      -> 0.997 * sqrt(cos_AtoT_ST.x) * sin_NaV - 0.069943*cosNaV -> sin_NaV_ST 

    mul r5.z, r1.y, r5.z 									            -> rough_factor_1 * sqrt(cos_AtoT_ST.x) 
    mul r18.zw, r5.zzzz, l(0, 0, 1.414214, 3.544908)  -> rough_factor_1 * sqrt(cos_AtoT_ST.x) * [1.414214, 3.544908] -> (sqrt(2), 2*sqrt(π))   

    add r1.x, r1.x, r13.w 									          -> NdotV + ToN 
    mad r5.z, -r18.x, l(-0.139886), r1.x 					    -> (NdotV + ToN)-(-0.139886) * sin_NaV_ST 
    mul r5.z, r5.z, r5.z  
    mul r5.z, r5.z, l(-0.500000) 							        -> -0.5 * pow2((NoV + ToN) + 0.139886 * sin_NaV_ST)

    mul r13.w, r18.z, r18.z 								          -> 2 * cosAtoTst * (rough_factor_1)^2 
    div r5.z, r5.z, r13.w 									          -> -0.5 * pow2((NoV + ToN) + 0.139886 * sin_NaV_ST) / (2 * cosAtoTst * (rough_factor_1)^2) 
    mul r5.z, r5.z, l(1.442695) 							        -> 1.442695 * (上式) -> 主要用于将下面的exp2转化为expE 
    exp r5.z, r5.z 											              -> exp( -0.5 * pow2((NoV + ToN) + 0.139886 * sin_NaV_ST) / (2 * cosAtoTst * (rough_factor_1)^2) ) 
    div r5.z, r5.z, r18.w  					                  -> exp( ... ) / (2sqrt(π)*sqrt_cosAtoTst*(rough_factor_1))  
    mul r1.y, r1.y, r5.z 									            -> sqrt_cosAtoTst * exp( ... ) / (2sqrt(π)*sqrt_cosAtoTst*(rough_factor_1))  -> sqrt_cosAtoTst似乎可以约去 

    mad_sat r5.z, r12.w, l(0.500000), l(0.500000) 		-> ToV * 0.5 + 0.5 
    sqrt r5.z, r5.z 										              -> sqrt(ToV * 0.5 + 0.5) 
    add r5.z, -r5.z, l(1.000000) 							        -> 1 - sqrt(ToV*0.5+0.5) 
    mul r13.w, r5.z, r5.z  									          -> [1 - sqrt(ToV*0.5+0.5)]^2 
    mul r13.w, r13.w, r13.w 								          -> [1 - sqrt(ToV*0.5+0.5)]^4 
    mul r5.z, r5.z, r13.w 									          -> [1 - sqrt(ToV*0.5+0.5)]^5 
    mad r5.z, r5.z, l(0.953479), l(0.046521) 				  -> 0.953479 * [1 - sqrt(ToV*0.5+0.5)]^5 + 0.046521 
                                                      -> r5.z 计算过程中的 pow5 会导致返回值非常接近0，如果使用pow2则能保留俯视角度的高亮感 
    mul r1.y, r1.y, r5.z 									            -> 上面的r5.z表达式返回值 * 更上面的r1.y表达式返回值 -> 记为 dark_fresnel_intensity 
    mul r1.y, r10.w, r1.y 									          -> dark_fresnel_intensity * R10.w(gi_intensity_from_tex_rifr_i) -> gi_fresnel_dark_intensity 

    mov_sat r12.w, -r12.w 									          -> saturate(-ToV) 
    add r5.z, -r12.w, l(1.000000) 							      -> 1 - saturate(-ToV) -> factor_ToV

    add r1.x, r1.x, l(-0.140000) 							        -> (NdotV + ToN) - 0.14 
    mul r1.x, r1.x, r1.x 									            -> (NdotV + ToN - 0.14)^2 
    mul r1.xy, r1.xyxx, l(-0.500000, 0.500000, 0, 0) 	-> [-0.5*(NdotV + ToN - 0.14)^2,  0.5*gi_fresnel_dark_intensity] 
    mul r10.w, r15.w, r15.w 								          -> (rough_factor_2)^2 
    div r1.x, r1.x, r10.w 									          -> -0.5*(NdotV + ToN - 0.14)^2 / (rough_factor_2)^2 
    mul r1.x, r1.x, l(1.442695) 
    exp r1.x, r1.x 											              -> exp(-0.5*(NdotV + ToN - 0.14)^2 / (rough_factor_2)^2) 
    mul r10.w, r15.w, l(2.506628) 							      -> (rough_factor_2)*sqrt(2π) 
    div r1.x, r1.x, r10.w 			                      -> exp(-0.5*(NdotV + ToN-0.14)^2/(rough_factor_2)^2) / [(rough_factor_2)*sqrt(2π)] 
                                                      -> 定义为 bright_fresnel_intensity 
    
    mad r10.w, -r14.w, l(0.500000), l(1.000000) 			-> 1 - 0.5 * cos_half_angle_TtoV 
    mul r12.w, r10.w, r10.w 								          -> (1-cos(TaV/2)/2)^2 
    mul r12.w, r12.w, r12.w 								          -> (1-cos(TaV/2)/2)^4
    mul r10.w, r10.w, r12.w 								          -> (1-cos(TaV/2)/2)^5
    mad r10.w, r10.w, l(0.953479), l(0.046521) 				-> 0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521 -> R10W

    add r12.w, -r10.w, l(1.000000) 							      -> 1 - R10W
    mul r12.w, r12.w, r12.w 								          -> (1 - R10W)^2 
    mul r10.w, r10.w, r12.w 								          -> (1 - R10W)^2 * R10W  ->  定义为 lambert_intensity

    //以下操作相当于 pow( R10颜色, (0.8/cos_half_angle_TtoV ) ) 
    div r12.w, l(0.800000), r14.w 							      -> 0.8 / cos_half_angle_TtoV 
    log r18.xzw, r10.xxyz 									          -> ln(R10颜色) 
    mul r18.xzw, r12.wwww, r18.xxzw 						      -> [0.8 / cos_half_angle_TtoV] * ln(R10颜色) 
    exp r18.xzw, r18.xxzw 									          -> exp([0.8 / cos_half_angle_TtoV] * ln(R10颜色)) -> df_chan7 

    mul r12.w, r18.y, l(1.442695) 
    exp r12.w, r12.w 										              -> exp(cos_AtoT_ST.y)  
    mul r1.x, r1.x, r12.w                             -> bright_fresnel_intensity * exp(cos_AtoT_ST.y) 
    mul r1.x, r10.w, r1.x 				                    -> lambert_intensity * bright_fresnel_intensity * exp(cos_AtoT_ST.y) 
    mul r18.xyz, r18.xzwx, r1.xxxx 							      -> df_chan7 * lambert_intensity * bright_fresnel_intensity * exp(cos_AtoT_ST.y) 
    mad r18.xyz, r1.yyyy, r5.zzzz, r18.xyzx  				  -> factor_ToV * 0.5 * gi_fresnel_dark_intensity + 上式  -> 更新 df_chan7 

    dp3 r1.x, r17.xyzx, r17.xyzx 							        -> dot(viewTangent, viewTangent) -> ToT
    add r1.x, r1.x, l(1.000000)								        -> 1 + ToT
    mul r1.x, r1.x, l(0.250000) 							        -> 0.25 * (1 + ToT)
    min r1.x, r1.x, l(1.000000) 							        -> min(0.25 * (1 + ToT), 1) -> 不大于1 
    add r1.y, -r1.x, r16.w 									          -> (1 - |ToN|) - min(0.25*(1+ToT),1) 
    mad r1.x, r1.y, l(0.330000), r1.x 						    -> lerp(min(0.25*(1+ToT),1), (1 - |ToN|), 0.33) 
    mul r1.x, r1.x, r6.w 									            -> factor_RoughOrZero * lerp(...) 
    mul r1.x, r1.x, l(0.318310) 							        -> 0.31831 * factor_RoughOrZero * lerp(...) 
    
    sqrt r10.xyz, r10.xyzx  								          -> sqrt(R10颜色) 
    mad r10.xyz, r10.xyzx, r1.xxxx, r18.xyzx          -> df_chan7 + sqrt(R10颜色) * 0.31831 * factor_RoughOrZero * lerp(...) 
    min r10.xyz, -r10.xyzx, l(0, 0, 0, 0)  					  -> min(-新R10颜色, 0) -> 结合下面乘 -π -> 抹去负数 
    mul r15.xyz, r10.xyzx, l(-3.141593, -3.141593, -3.141593, 0)  -> R15颜色 = π * R10颜色 
                                                      -> 这里的π一般认为是着色点附近半球域光强度积分后的强度值 
  endif 

  ieq r1.x, r7.x, l(8) 							                  -> 是否是 #8 渲染通道  
  mad r10.xyz, r16.xyzx, r5.wwww, r15.xyzx 		        -> T11.w * [T11.xyz^2] + R15颜色 
  movc r10.xyz, r1.xxxx, r10.xyzx, r15.xyzx 	        -> Condition: 如果是8号材质则 选择 {[T11.xyz^2] + R15颜色} 不然就是 R15颜色 

  //以下逻辑与之前处理 #6 渲染通道时雷同 
  mov r17.w, l(1.000000) 						                  -> R17.xyz 是关于法线的一种扰动向量，在某些情况下等于 <视-切向量> nvpv 
  dp4 r15.x, cb1[181].xyzw, r17.xyzw 			            -> 对上述Point执行矩阵变换 -> R15 
  dp4 r15.y, cb1[182].xyzw, r17.xyzw
  dp4 r15.z, cb1[183].xyzw, r17.xyzw

  mul r16.xyzw, r17.yzzx, r17.xyzz 				            -> 基于R17向量进行一个随机化处理 
  dp4 r18.x, cb1[184].xyzw, r16.xyzw 			            -> 对上述Point执行新的矩阵变换 -> R18 
  dp4 r18.y, cb1[185].xyzw, r16.xyzw
  dp4 r18.z, cb1[186].xyzw, r16.xyzw

  mul r1.x, r17.y, r17.y
  mad r1.x, r17.x, r17.x, -r1.x 				              -> x^2 - y^2 
  add r15.xyz, r15.xyzx, r18.xyzx 				            -> R15 + R18 
  mad r15.xyz, cb1[187].xyzx, r1.xxxx, r15.xyzx       -> [-0.016,-0.01,-0.003] * (x^2 - y^2) + (R15 + R18) 
  max r15.xyz, r15.xyzx, l(0,0,0,0)  			            -> 确保都 >= 0 
  mul r15.xyz, r15.xyzx, cb1[180].xyzx 			          -> [4.9, 4.19, 3.1] * 上面结果 -> R15 或 ao_diffuse_common 

  mul r1.x, r11.w, r7.w 						                  -> lerp(NoRn, 1, 扰动向量模长) * AO_final  -> 某种基于Rn的AO(或者光强?) * AO_final 
  add r1.y, -r7.w, l(1.000000) 					              -> 1 - AO_final 
  mul r16.xyz, r1.yyyy, cb0[1].xyzx 			            -> [0.045,0.05,0.029] * (1 - AO_final) 
  mad r15.xyz, r1.xxxx, r15.xyzx, r16.xyzx 		        -> R15 * 基于Rn的AO(或者光强?) * AO_final + [0.045,0.05,0.029] * (1 - AO_final) 
  mad r10.xyz, r15.xyzx, r10.xyzx, r14.xyzx 	        -> R10 = R15 * R10颜色 + R14(如果不是6号材质则全0，如果是，R14是有值的，计算方法与这里类似) 
  mul r10.xyz, r10.xyzx, cb1[134].yyyy 			          -> R10 *= 1 -> 这是个颜色, 推测为 Diffuse 

  eq r1.x, cb1[200].z, l(0.000000) 				            -> 1 == 0 ? false 
  dp3 r1.y, r10.xyzx, l(0.300000, 0.590000, 0.110000, 0)  -> 取 R10 颜色 强度 
  and r1.y, r1.y, r1.x
  and r1.y, r1.y, r7.y 							                  -> r7.y = 是 9号 或 5号 材质渲染方案之一就为true 
  and o0.w, r1.y, r1.x 							                  -> 输出 Alpha, 因为连续使用了 and，且r1.x 肯定为 0， 这里输出应当为 0 
else 
  mov r10.xyz, l(0,0,0,0) 						                -> 这是最外层 if 的 else 分支 
  mov o0.w, l(0) 								                      -> 设置 r10颜色为 全黑(0), a通道=0 
endif 

ine r1.xy, r7.xxxx, l(0, 7, 0, 0)  				            -> [Purple.y修改值] * 255 的后4个bit <-> [0, 7] 
and r1.x, r1.y, r1.x 							                    -> 同时满足 -> 不是0号和7号材质渲染方案 
if_nz r1.x 

  movc r9.xyz, r7.yyyy, r11.xyzx, r9.xyzx 		        -> 依据是否是5或9号材质渲染方案 -> 使用 R11=环境光底色*方块Mask.y 或R9=df_inten_base
  mad r9.xyz, r9.xyzx, cb1[136].wwww, cb1[136].xyzx 	-> R9 * 1 + 0 
  mad r1.x, r5.x, r9.w, l(1.000000)  			            -> 1 + T11.x * R9.w([-1, 0]区间, 与roughness和NoV有关)
  mul r1.y, r1.x, l(0.080000)  					              -> 0.08 * (1 + T11.x * R9.w) -> r1y
  mad r11.xyz, -r1.xxxx, l(0.08, 0.08, 0.08, 0), r12.xyzx	 
  mad r11.xyz, r6.wwww, r11.xyzx, r1.yyyy 		        -> R11 = lerp(r1y, R12, factor_RoughOrZero) 
  movc r9.xyz, r8.zzzz, r11.xyzx, r9.xyzx 		        -> 依据是否是 4号 材质方案设置 R9颜色 (R11 or R9) 

  add r1.x, r1.w, r1.w  						                  -> NdotV + NdotV
  mad r11.yzw, r1.xxxx, r6.xxyz, r8.xxyw		          -> Normal * 2(NdotV) + (-ViewDirWS) -> View_Reflection 或 VR 

  mul r1.x, r3.w, r3.w 							                  -> (rough2)^2 
  mad r1.y, -r3.w, r3.w, l(1.000000) 			            -> 1 - (rough2)^2 
  sqrt r1.w, r1.y 								                    -> sqrt(1 - (rough2)^2)
  mad r1.w, r3.w, r3.w, r1.w 					                -> (rough2)^2 + sqrt(1 - (rough2)^2)
  mul r1.y, r1.w, r1.y 							                  -> (1 - (rough2)^2) * [(rough2)^2 + sqrt(1 - (rough2)^2)] -> 某种 Rate -> 约 0.63 

  mad r2.xyz, -r2.xyzx, r2.wwww, r11.yzwy 		        -> VR - N 
  mad r2.yzw, r1.yyyy, r2.xxyz, r6.xxyz			          -> lerp(norm, VR, rate) -> '上抬视反' (注:没有归一化) 
  												                            -> 当Scale < 1时, 该反射方向(VR)相比镜面反射方向更加靠向法线; 反之则靠向VR 

  //使用屏幕UV采样 T12 -> 这张纹理看起来对水晶,金属扣环等物体做了处理 -> 疑似 spec 纹理 
  //从后续逻辑看(T12.xyz分量)推测是对高光项的线性的附加补充量 
  //T12.w后续会作用到基于环境光贴图的高光重建过程中 -> 推测为高光强度遮罩 
  sample_indexable(texture2d)(float,float,float,float) r6.xyzw, r0.xyxx, t12.xyzw, s6 
  add r0.x, -r6.w, l(1.000000) 							          -> 1 - T12.a 
  mad r12.xyzw, r6.xyzw, l(1, 1, 1, -1), l(0, 0, 0, 1)-> [T12.xyz, 1 - T12.w] 
  add r14.xyzw, -r12.xyzw, l(0, 0, 0, 1)  				    -> [-T12.xyz, T12.w] 
  mad r14.xyzw, r5.xxxx, r14.xyzw, r12.xyzw 			    -> r14 = [-T12.xyz, T12.w] * T11.x(控制阀) + [T12.xyz, 1 - T12.w] 
  movc r12.xyzw, r8.zzzz, r14.xyzw, r12.xyzw 			    -> r12 = 4号材质 ? r14 : [T12.xyz, 1 - T12.w] 
  
  //输出 r1.x -> 被T12.w通道修正过的'AO噪声'高频部分系数 
  mad r0.y, r4.w, r7.z, r3.x 							            -> TexAO(Purple.z) * Computered_AO(SSAO.r) + saturate(NdotV) -> mixed_AO
  log r0.y, r0.y 										                  -> ln(mixed_AO) 
  mul r0.y, r0.y, r1.x 									              -> ln(mixed_AO) * roughness^2 
  exp r0.y, r0.y 										                  -> exp2( ln(mixed_AO) * roughness^2 ) -> pow(mixed_AO, roughness^2)
  mad r0.y, r4.w, r7.z, r0.y 			                    -> TexAO * Computered_AO + exp2(ln(mixed_AO) * roughness^2) -> AOwithRoughNoise 
  add_sat r0.y, r0.y, l(-1.000000) 						        -> saturate(AOwithRoughNoise - 1) -> 只截取超过1的部分，这部分可以看做是AO叠加上Rough后的高频噪声 
  mul r1.x, r0.y, r12.w 								              -> T12纹理(spec贴图)a通道值 * saturate(AOwithRoughNoise - 1) -> 被A通道修正过的 AO噪声 系数 

  ftou r0.zw, r0.zzzw 									              -> 屏幕像素索引(+0.5) to uint 
  mad r1.y, r1.z, cb3[3].x, cb3[3].y  					      -> 当前帧深度纹理解码的Depth * 1 + 1 
  log r1.y, r1.y 										                  -> ln(Depth + 1) 
  mul r1.y, r1.y, cb3[3].z 								            -> ln(Depth + 1) * 1 
  max r1.y, r1.y, l(0.000000) 							          -> max(ln(Depth + 1) * 1, 0) -> 返回值不小于 0 
  ftou r1.y, r1.y 										                -> max(ln(Depth + 1) * 1, 0) to uint 
  iadd r1.z, cb3[1].z, l(-1) 							            -> 1 - 1 = 0 
  umin r1.y, r1.z, r1.y 								              -> min(0, max(ln(Depth + 1) + 1, 0)) -> 似乎只能返回 0? -> 距离对数因子? 
  ushr r0.zw, r0.zzzw, cb3[2].xxxx 						        -> 屏幕像素索引(+1) >> 1 -> 相当于半屏幕分辨率 
  imad r0.w, r1.y, cb3[1].y, r0.w 						        -> 距离对数因子 * 1 + 半屏幕像素索引.v 
  imad r0.z, r0.w, cb3[1].x, r0.z 						        -> 距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u 
  iadd r0.z, r0.z, cb3[0].w 							            -> 距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1 
  ishl r0.w, r0.z, l(1) 								              -> (距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 0 
  
  //访问 T3 表 -> 下标为 r0.w = (深度对数因子 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 0 
  ld_indexable(buffer)(uint,uint,uint,uint) r0.w, r0.wwww, t3.yzwx 		-> 取第一个元素(X) 
  umin r0.w, r0.w, cb3[0].y 											    -> min(r0.w=[0,1,...,4,5,6,7...], 1) -> 不高于1? 
  bfi r0.z, l(31), l(1), r0.z, l(1) 					        -> (深度对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 1 
  ld_indexable(buffer)(uint,uint,uint,uint) r0.z, r0.zzzz, t3.yzxw  	-> 取第一个元素(X)  -> r0.zw 应当在[0,1,2,3,4,5,6,7]这个范围内 

  ieq r1.y, r7.x, l(6) 									              -> [Purple.y修改值] * 255 的后4个bit <-> [6] 
  lt r1.z, l(0.000000), cb0[0].x 						          -> 0 < 1 ? true -> 总是开启如下逻辑 
  if_nz r1.z 											                    -> 这里总是能进入 
  	//R13 = Scale * 从原Norm顶点指向新Norm顶点的向量(正向扰动矢量) + 原Normal向量 -> 由于相对于RN没有归一化，可记为 d_norm 
    dp3 r1.w, r13.xyzx, r13.xyzx 						          -> dot(d_norm, d_norm)
    sqrt r1.w, r1.w 									                -> d_norm 的模长 -> 记为 |d_norm| 或 |Rn| 
    //以下分支用于计算新的 r1.w 值 -> 某种扰动强度 
    //在重新计算过程中使用到了: |Rn|, roughness, asin(dot(Rn,'上抬视反')/|Rn|) -> 推测是经验公式 
    if_nz cb1[189].x 									                -> cb1[189].x 用十六进制解码后的 0x00000001 -> true 
      if_z r1.y 										                  -> 是否当前像素属于 6号材质 
        max r1.y, r3.w, l(0.100000) 					        -> max(roughness, 0.1) 
        mul r4.w, r1.w, cb0[0].y 						          -> |Rn| * 1 
        mul r5.z, r4.w, l(3.141593) 					        -> π * |Rn| 
        dp3 r5.w, r13.xyzx, r2.yzwy 					        -> dot(d_norm, '上抬视反') 
        max r6.w, r1.w, l(0.001000) 					        -> max(|Rn|, 0.001) -> 模长不要小于 0.001 
        
        //构造传入函数asin_fast的入参 a -> (opposite / hypotenuse) 
        div r5.w, r5.w, r6.w 							            -> R5W = dot(d_norm, '上抬视反') / max(|Rn|, 0.001) 

        //asin_fast(a)
        add r6.w, -|r5.w|, l(1.000000) 	 
        sqrt r6.w, r6.w 	 
        mad r7.x, |r5.w|, l(-0.018729), l(0.074261)  
        mad r7.x, r7.x, |r5.w|, l(-0.212114)  
        mad r7.x, r7.x, |r5.w|, l(1.570729)
        mul r7.y, r6.w, r7.x
        mad r7.y, r7.y, l(-2.000000), l(3.141593)
        lt r5.w, r5.w, -r5.w                          -> A < -A -> A < 0
        and r5.w, r5.w, r7.y                          -> 若输入小于0 -> 抹去之前计算的值；反之维持不变 
        mad r5.w, r7.x, r6.w, r5.w                    -> asin(dot(Rn, '上抬视反') / |Rn|) 

        mad r6.w, r1.y, l(3.141593), -r5.z 				    -> 计算:  π * |roughness| - π * |Rn| 
        add r5.w, r5.w, -|r6.w| 						          -> asin - abs(π * |roughness| - π * |Rn|) 

        mad r1.y, r1.y, l(3.141593), r5.z 				    -> π * |roughness| + π * |Rn| 
        add r1.y, -|r6.w|, r1.y 						          -> (π * |roughness| + π * |Rn|) - |π * |roughness| - π * |Rn|| 
        div_sat r1.y, r5.w, r1.y 						          -> asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|) 
        add r1.y, -r1.y, l(1.000000) 					        -> 1 - asin(dot(Rn,'上抬视反')/|Rn|) / (A+B-|A-B|) 
        mad r5.z, r1.y, l(-2.000000), l(3.000000) 		-> -2*[1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)] + 3 
        mul r1.y, r1.y, r1.y 							            -> [ 1 - asin(dot(Rn,'上抬视反')/|Rn|)/(A+B-|A-B|) ]^2 
        mul r1.y, r1.y, r5.z
            -> [ 1 - asin(dot(Rn,'上抬视反')/|Rn|)/(A+B-|A-B|) ]^2 * {-2*[1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)] + 3} 
        mad r4.w, r4.w, l(3.141593), l(-0.100000)		  -> π * |Rn| - 0.1
        mul_sat r4.w, r4.w, l(5.000000) 				      -> saturate((π * |Rn| - 0.1) * 5)
        mul r1.w, r1.y, r4.w
        	  -> saturate((π * |Rn| - 0.1) * 5) * [1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)]^2 * {-2*[1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)] + 3} 
      endif 
    endif 

    add r1.y, -r1.w, l(1.000000) 						          -> 设 r1.w = 与|Rn|和Roughness有关的强度值 
    mad r1.y, cb0[1].w, r1.y, r1.w 						        -> lerp(|Rn|关联值, 1, 0.0%) -> 还是本身 -> norm_shift_intensity
    add r1.w, -r1.y, l(1.000000) 						          -> 1 - |Rn|和Roughness关联 の 强度值 
    mul r7.xyz, r1.wwww, cb0[1].xyzx 					        -> [0.045, 0.051, 0.029] * (1 - |Rn|关联值) -> GI_Spec_Base 
  else 
    mov r7.xyz, l(0,0,0,0) 								            -> 这里总是不进入 
    mov r1.y, l(1.000000)                             -> norm_shift_intensity 
  endif 

  log r1.w, r3.w  										                -> ln(roughness) 
  mad r1.w, -r1.w, l(1.200000), l(1.000000) 			    -> 1 - 1.2 * ln(roughness) 
  add r4.w, cb1[188].z, l(-1.000000) 					        -> 7 - 1 
  add r5.z, -r1.w, r4.w 								              -> 6 - (1 - 1.2 * ln(roughness)) -> 采样IBL贴图使用的 lod lv 
  mov r2.x, l(0) 										
  mov r8.xyw, l(0,0,0,0)
  mov r5.w, r1.x  										                -> r5.w = 高反射率纹理a通道值 * saturate( R0Y - 1 ) -> spec_AOwthRoughNoise 
  mov r6.w, l(0) 										                  -> Loop Index (i) -> 初始为 0 

  //注意, r0.w = 使用'屏幕像素'与'距离对数'组合出索引，再从 T3 buffer 中取得的映射值 -> 取值范围要么 0, 要么 1 -> 重构时默认全为1 
  //挨个判断当前场景'激活'的 IBL 探针，如果当前像素点能被某张IBL影响，则进入内部 if 分支执行逻辑 
  loop 
    uge r7.w, r6.w, r0.w  								            -> i >= r0.w ? 
    breakc_nz r7.w 										                -> 相当于 while( i < r0.w ) 
    lt r7.w, r5.w, l(0.001000)							          -> r5.w < 0.001 ? 
    if_nz r7.w 											                  -> 相当于 if (r5.w < 0.001) then break 
      break 
    endif 
    iadd r7.w, r0.z, r6.w 								            -> r0.z 也是基于'屏幕像素'和'距离对数' 从T3 buffer直接获取 -> 可为[0,1,..7]
    ld_indexable(buffer)(uint,uint,uint,uint) r7.w, r7.wwww, t4.yzwx 	-> 使用 uint4 查看 T4 buffer 数据，这是张映射表 -> 使用ushort4格式采样可以得到返回值"6"  
    add r14.xyz, r4.xyzx, -cb4[r7.w + 0].xyzx 		    -> 当前点世界空间坐标 - cb4[0-49] -> cb4前50组数据记录的是IBL探针的[posWS, 半径R] 
    dp3 r9.w, r14.xyzx, r14.xyzx 
    sqrt r10.w, r9.w 
    lt r12.w, r10.w, cb4[r7.w + 0].w 					        -> 探针距离是否在范围 R 内 
    if_nz r12.w 
      div_sat r10.w, r10.w, cb4[r7.w + 0].w 			    -> saturate(距离 / 影响半径R) 
      dp3 r12.w, r2.yzwy, r14.xyzx  					        -> dot(<上抬视反>, <素-探向量>) 
      mad r9.w, -cb4[r7.w + 0].w, cb4[r7.w + 0].w, r9.w -> (距离^2 - R^2) < 0 
      mad r9.w, r12.w, r12.w, -r9.w 					        -> dot(<上抬视反>, <素-探向量>)^2 - (距离^2 - R^2) 
      ge r13.w, r9.w, l(0.000000) 						        -> dot(<上抬视反>, <素-探向量>)^2 - (距离^2 - R^2) > 0 -> 总是true:正数-(负数) 
      sqrt r9.w, r9.w 									              -> sqrt( dot(<上抬视反>, <素-探向量>)^2 - (距离^2 - R^2) ) 
      add r9.w, -r12.w, r9.w 			                    -> sqrt(dot(<上抬视反>,<素-探向量>)^2-(距离^2-R^2)) - dot(<上抬视反>,<素-探向量>) -> R9W 
      mad r14.xyz, r9.wwww, r2.yzwy, r14.xyzx 			  -> <上抬视反> * R9W + <素-探向量> 
      add r14.yzw, r14.xxyz, -cb4[r7.w + 682].xxyz 		-> <上抬视反> * R9W + <素-探向量> - [200,0,0] 
      
      mad r9.w, r10.w, l(2.500000), l(-1.500000) 		  -> 2.5 * (距离 / 影响半径R) - 1.5 
      max r9.w, r9.w, l(0.000000) 						        -> 如果 (距离 / 影响半径R) < 0.6 -> 上式一律返回 0 
      mul r10.w, r9.w, r9.w 							            -> [2.5 * (距离 / 影响半径R) - 1.5]^2 
      mad r9.w, -r9.w, l(2.000000), l(3.000000) 		  -> 3 - 2 * [2.5 * (距离 / 影响半径R) - 1.5] 
      mad r14.x, -r10.w, r9.w, l(1.000000) 				    -> 1 - {3-2*[2.5*(距离/影响半径R)-1.5]} * [2.5*(距离/影响半径R)-1.5]^2 
      movc r14.xyzw, r13.wwww, r14.xyzw, r2.xyzw 		  -> 总是选择 [r14.x, r14.yzw], 不可能选r2=[0, <上抬视反>] 
      mov r15.xyz, r14.yzwy 							            -> 把向量部分放到 r15.xyz 中 
      mov r15.w, cb4[r7.w + 341].y 						        -> r15.w = 10 

      //采样 IBL Cubemap array, r15.w 是cube的编号索引; r15.xyz 是采样cubemap的方向指针 
      sample_l_indexable(texturecubearray)(float,float,float,float) r15.xyzw, r15.xyzw, t2.xyzw, s3, r5.z  -> 采样 IBL 探针纹理 

      mul r14.yzw, r15.xxyz, cb4[r7.w + 341].xxxx     -> 探针返回颜色 * 1 
      mul r14.yzw, r14.xxxx, r14.yyzw 					      -> 距离缩放因子 * 探针返回颜色 
      mul r14.yzw, r5.wwww, r14.yyzw					        -> [Spec_Intense_1] * {距离缩放因子 * 探针返回颜色} 
      mad r8.xyw, r14.yzyw, r1.yyyy, r8.xyxw 			    -> [spec * IBL_sample_col] * [|Rn|和Roughness关联 の 强度值] + 0 
      mad r7.w, -r15.w, r14.x, l(1.000000) 				    -> 1 - IBL_sample_alpha * 距离缩放因子 
      mul r5.w, r5.w, r7.w  							            -> 更新spec_AOwthRoughNoise -> ~ *= {1 - IBL_sample_alpha * 距离缩放因子} 
    endif 

    iadd r6.w, r6.w, l(1)								              -> LOOP index i++ 
  endloop 

  lt r1.x, l(0.000000), cb2[0].y 						          -> 0 < 0.0992432 ? -> true 

  //以下分支用于采样天空盒颜色，返回值存入 R7.xyz 
  if_nz r1.x 
    add r1.w, -r1.w, cb2[0].x 							          -> 1.8154297 - [1 - 1.2 * ln(roughness)] 
    add r1.w, r1.w, l(-1.000000)						          -> 1.8154297 - [1 - 1.2 * ln(roughness)] - 1 -> 这是计算 LOD 

    //采样 T0 cubemap -> 天空盒; r2=上抬视反 -> 我现在怀疑这货是视方向的反射方向(reflect dir) -> TODO: 修正之前的估计 
    sample_l_indexable(texturecube)(float,float,float,float) r14.xyz, r2.yzwy, t0.xyzw, s1, r1.w 
    mul r14.xyz, r14.xyzx, cb1[180].xyzx				      -> 天空盒采样颜色 * [4.9, 4.19, 3.1]	-> 阳光颜色? 
    lt r2.x, l(0.000000), cb2[0].w 						        -> 0 < -0.00087 -> false 

    if_nz r2.x 											                  -> 这里进不去
      //采样另一个天空盒 
      sample_l_indexable(texturecube)(float,float,float,float) r2.xyz, r2.yzwy, t1.xyzw, s2, r1.w 	-> T1 cubemap 无数据 
      mad r2.xyz, r2.xyzx, cb1[180].xyzx, -r14.xyzx 
      mad r14.xyz, cb2[0].wwww, r2.xyzx, r14.xyzx  		-> 与第一个天空盒颜色进行混淆 
    endif 

    mad r7.xyz, r14.xyzx, r1.yyyy, r7.xyzx 
        -> 天空盒放大后颜色 * norm_shift_intensity + Gi_spec_base -> 更新环境光底色 Gi_spec_base
  endif 

  mul r2.xyz, r5.wwww, r7.xyzx 							          -> 天空盒返回值 * Spec_Intense_1 
  mad r2.xyz, r8.xywx, cb1[156].xyzx, r2.xyzx 			  -> ibl_spec_output * 1 + 天空盒最终值 
  mad r2.xyz, cb1[134].yyyy, r2.xyzx, r12.xyzx 			  -> 1 * (ibl_spec_output * 1 + 天空盒最终值) + T12采样关联值(各颜色spec?) 
  														                        -> 可以认为是各种 IBL 采样返回的大集合 -> prefilter_Specular 

  if_nz r8.z 											                    -> 是否是 4号 材质
    mov r3.y, r3.w 							                      -> 据此知 r3.w=Roughness; r3.x=NdotV -> 这里被当做了出射光方向(毕竟当前pass是用来计算GI的) 
    sample_l_indexable(texture2d)(float,float,float,float) r1.yw, r3.xyxx, t5.zxwy, s4, l(0.000000)  -> 采样 LUT 
    mul_sat r2.w, r9.y, l(50.000000) 					        -> R9色.Y通道 * 50 -> R9颜色似乎是一种环境光基础强度 -> df_inten_base 
    mul r1.w, r1.w, r2.w 								              -> LUT.bias * (50 * R9.y) -> 采样的r1.w = LUT.bias 
    add r2.w, -r5.x, l(1.000000) 						          -> 1 - T11.x -> 控制阀取反 
    mul r1.w, r1.w, r2.w 								              -> [LUT.bias * (50 * R9.y)] * (1 - T11.x) 
    mad r7.xyz, r9.xyzx, r1.yyyy, r1.wwww  				    -> (R9色 * LUT.scale) + [LUT.bias * (50 * R9.y)] * (1 - T11.x) 
    													                        -> R9颜色 -> TODO: 是不是环境光底色? 或者是 F0? 
    mul r7.xyz, r2.xyzx, r7.xyzx  						        -> {(R9色*LUT.scale) + [LUT.bias*(50*R9.y)]*(1-T11.x)} * prefilter_Specular 
    													                        -> 记为 R7颜色(或 gi_spec_1) -> 第一组合成的GI镜面反射 

    mov r3.z, r5.y 										                -> r5.y 来自 T11纹理采样 -> 推测是 Roughness -> 对于茅草和木头来说都是 0 
    													                        -> 而 r3.x = NdotV 
    sample_l_indexable(texture2d)(float,float,float,float) r1.yw, r3.xzxx, t5.zxwy, s4, l(0.000000) 
    mad r1.y, r1.y, l(0.040000), r1.w 					      -> 0.04 * LUT.scale + LUT.bias 
    mul r1.w, r5.x, r1.y 								              -> T11.x * (0.04 * LUT.scale + LUT.bias) -> gi_spec_brdf_2 
    mad r1.y, -r1.y, r5.x, l(1.000000) 					      -> 1 - gi_spec_brdf_2 
    mul r5.xzw, r1.wwww, r6.xxyz 						          -> gi_spec_brdf_2 * T12.xyz 采样结果(spec) 

    mad r5.xzw, r7.xxyz, r1.yyyy, r5.xxzw 	          -> gi_spec_1 *（1 - gi_spec_brdf_2) + T12.xyz * gi_spec_brdf_2  ->  定义为 gi_spec_2 
                                                      -> 推测为对部分存在第二高光波瓣的材质，进行二次环境光高光渲染 (期间需要扣除一次'曝光'过程中的额外部分) 
    mul r0.x, r0.x, r1.w 								              -> (1 - T12.a) * gi_spec_brdf_2
    mul r0.x, r0.y, r0.x 						                  -> AOwthRoughNoise * (1 - T12.a) * gi_spec_brdf_2 -> spec_second_intensity 

    ->下面的分支用于输出属于 #4 号通道专有的 gi_spec_second_base(既第二波瓣颜色) 以及 RN_shift_intensity(基于RN的扰动强度) 
    if_nz r1.z 											                  -> 总是能进入 (通过buffer中的开关控制) 
      dp3 r0.y, r13.xyzx, r13.xyzx						        -> dot(Rn, Rn) 
      sqrt r0.y, r0.y 									              -> |Rn| 模长 

      if_nz cb1[189].x 									              -> 使用 xint4格式查看 -> 1 -> 可以进入 
        max r1.y, r5.y, l(0.100000) 					        -> max(0.1, T11.y) -> 对茅草等来说结果 = 0.1 
        mul r1.z, r0.y, cb0[0].y 						          -> |Rn| * 1 
        mul r1.w, r1.z, l(3.141593) 					        -> π * |Rn| 
        dp3 r2.w, r13.xyzx, r11.yzwy 					        -> dot(Rn, VReflect) 
        max r3.y, r0.y, l(0.001000) 					        -> max(|Rn|, 0.001) 

        div r2.w, r2.w, r3.y 							            -> 准备asin_fast(a)的入参 a = dot(Rn, VReflect) / |Rn| 

        //asin_fast(a)
        add r3.y, -|r2.w|, l(1.000000)
        sqrt r3.y, r3.y
        mad r3.z, |r2.w|, l(-0.018729), l(0.074261)
        mad r3.z, r3.z, |r2.w|, l(-0.212114)
        mad r3.z, r3.z, |r2.w|, l(1.570729)
        mul r6.x, r3.y, r3.z
        mad r6.x, r6.x, l(-2.000000), l(3.141593)
        lt r2.w, r2.w, -r2.w
        and r2.w, r2.w, r6.x
        mad r2.w, r3.z, r3.y, r2.w                    -> asin( dot(Rn, VReflect)/|Rn| )

        mad r3.y, r1.y, l(3.141593), -r1.w 				    -> π * Rough - π * |Rn| 
        add r2.w, r2.w, -|r3.y| 						          -> asin( dot(Rn, VReflect)/|Rn| ) - abs(π*Rough - π*|Rn|)

        mad r1.y, r1.y, l(3.141593), r1.w 				    -> π * Rough + π * |Rn| 
        add r1.y, -|r3.y|, r1.y 						          -> (π*Rough + π*|Rn|) - abs(π*Rough - π*|Rn|) 
        div_sat r1.y, r2.w, r1.y 			                -> sat([ asin( dot(Rn, VReflect)/|Rn| ) - abs(π*Rough - π*|Rn|) ] / [ (π*Rough + π*|Rn|) - abs(π*Rough - π*|Rn|) ])
        add r1.y, -r1.y, l(1.000000)	                -> 1 - R1Y(上式) 
        mad r1.w, r1.y, l(-2.000000), l(3.000000) 		-> 3 - 2 * (1 - R1Y)
        mul r1.y, r1.y, r1.y 							            -> (1 - R1Y)^2 
        mul r1.y, r1.y, r1.w 							            -> (1 - R1Y)^2 * (3 - 2 * (1 - R1Y)) 

        mad r1.z, r1.z, l(3.141593), l(-0.100000) 		-> π * |Rn| - 0.1
        mul_sat r1.z, r1.z, l(5.000000) 				      -> saturate(5 * (π * |Rn| - 0.1)) 
        mul r0.y, r1.y, r1.z 							            -> (1 - R1Y)^2 * (3 - 2 * (1 - R1Y)) * saturate(5 * (π * |Rn| - 0.1)) -> RN_shift_intensity
      endif 

      --add r1.y, -r0.y, l(1.000000) 
      mad r0.y, cb0[1].w, r1.y, r0.y 					        -> lerp(RN_shift_intensity, 1, 0.0%) -> RN_shift_intensity
      add r1.y, -r0.y, l(1.000000) 						        -> 1 - lerp(RN_shift_intensity,1,0)
      mul r1.yzw, r1.yyyy, cb0[1].xxyz 	              -> [0.045, 0.051, 0.029] * [1 - lerp(RN_shift_intensity,1,0)] -> gi_spec_second_base 
    else 
      mov r1.yzw, l(0,0,0,0) 							            -> 总是不进入 
      mov r0.y, l(1.000000)
    endif 

    log r2.w, r5.y 										                -> ln(T11.y) 
    mad r2.w, -r2.w, l(1.200000), l(1.000000) 			  -> 1 - 1.2 * ln(T11.y)
    add r3.y, -r2.w, r4.w 								            -> 6 - ln(T11.y) 
    mov r11.x, l(0) 					
    mov r6.xyz, l(0,0,0,0)                            -> ibl_spec2_output -> 这是待求的量 
    mov r3.z, r0.x  									                -> AOwthRoughNoise * (1 - T12.a) * gi_spec_brdf_2 -> spec_second_intensity 
    													                        -> spec_second_intensity -> 第二高光波瓣的强度 
    mov r4.w, l(0) 										                -> Index i = 0  

    //以下LOOP的起始形式与上面 IBL LOOP 的起始形式雷同 
    loop 
      //注意, r0.w = 使用'屏幕像素'与'距离对数'组合出索引，再从 T3 buffer 中取得的映射值 -> 取值范围要么 0, 要么 1 -> 重构时默认全为1 
      uge r5.y, r4.w, r0.w 								            -> i >= r0.w? 
      breakc_nz r5.y 									                -> while ( i < r0.w ) 
      lt r5.y, r3.z, l(0.001000) 						          -> r3.z < 0.001  
      if_nz r5.y 										                  -> if (spec_second_intensity < 0.001) then break 
        break 
      endif 

      iadd r5.y, r0.z, r4.w  							            -> r0.z 也是基于'屏幕像素'和'距离对数' 从T3 buffer直接获取 -> 可为[0,1,...] 
      ld_indexable(buffer)(uint,uint,uint,uint) r5.y, r5.yyyy, t4.yxzw		-> 推测使用 ushort4 查看 T4 buffer 数据，这是张映射表 
      add r7.xyz, r4.xyzx, -cb4[r5.y + 0].xyzx 			  -> 依然是求取 从探针指向 当前视点的向量 -> <素-探向量> 
      dp3 r6.w, r7.xyzx, r7.xyzx 
      sqrt r7.w, r6.w 									              -> 探针到视点的 Length 
      lt r8.x, r7.w, cb4[r5.y + 0].w 					        -> Length < 探针影响的半径 R 
      if_nz r8.x 										                  -> 当前视点受探针影响的话 
      	//以下逻辑主要用于构造 IBL 采样向量 r8.xyz; 采样后 
        div_sat r7.w, r7.w, cb4[r5.y + 0].w 			    -> saturate(距离 / 影响半径R) 
        dp3 r8.x, r11.yzwy, r7.xyzx 					        -> dot(View_Reflection, <素-探向量>) -> 注:第一次执行IBL_LOOP在这里使用的是 <上抬视反> 
        mad r6.w, -cb4[r5.y + 0].w, cb4[r5.y + 0].w, r6.w 	-> (距离^2 - R^2) < 0 
        mad r6.w, r8.x, r8.x, -r6.w 					        -> dot(VR, <素-探向量>)^2 - (距离^2 - R^2) 
        ge r8.y, r6.w, l(0.000000) 						        -> dot(VR, <素-探向量>)^2 - (距离^2 - R^2) >= 0 -> 总是true 
        sqrt r6.w, r6.w 								              -> sqrt(dot(VR, <素-探向量>)^2 - (距离^2 - R^2)) 
        add r6.w, -r8.x, r6.w 			                  -> sqrt(dot(VR, <素-探向量>)^2 - (距离^2 - R^2)) - dot(VR, <素-探向量>) -> R6W 
        mad r7.xyz, r6.wwww, r11.yzwy, r7.xyzx 			  -> VR * R6W + <素-探向量> 
        add r12.yzw, r7.xxyz, -cb4[r5.y + 682].xxyz 	-> VR * R6W + <素-探向量>  - 0 -> 探针点 指向 VR*R6W 的终点 

        mad r6.w, r7.w, l(2.500000), l(-1.500000) 		-> 2.5 * saturate(距离/R) - 1.5 
        max r6.w, r6.w, l(0.000000) 					        -> max(2.5 * saturate(距离/R) - 1.5, 0) -> [距离/R] < 0.6 则返回 0 
        mul r7.x, r6.w, r6.w 							            -> [2.5 * saturate(距离/R) - 1.5]^2 
        mad r6.w, -r6.w, l(2.000000), l(3.000000) 		-> 3 - 2*[2.5 * saturate(距离/R) - 1.5] 
        mad r12.x, -r7.x, r6.w, l(1.000000) 			    -> 1 - [2.5*saturate(距离/R) - 1.5]^2 * {3-2*[2.5*saturate(距离/R)-1.5]} -> rate_factor(距离缩放因子) 
        movc r7.xyzw, r8.yyyy, r12.xyzw, r11.xyzw 		-> 选[r12.x, r12.yzw] 
        mov r8.xyz, r7.yzwy								            -> 把 向量部分 放到 r8.xyz 中 
        mov r8.w, cb4[r5.y + 341].y  					        -> 10 

        //采样 cubemap array, 获取正确的 IBL 返回值 
        sample_l_indexable(texturecubearray)(float,float,float,float) r8.xyzw, r8.xyzw, t2.xyzw, s3, r3.y 

        mul r7.yzw, r8.xxyz, cb4[r5.y + 341].xxxx    	-> 探针返回颜色 * 1 
        mul r7.yzw, r7.xxxx, r7.yyzw 					        -> 距离缩放因子 * 探针返回颜色 
        mul r7.yzw, r3.zzzz, r7.yyzw 					        -> spec_second_intensity * {距离缩放因子 * 探针返回颜色} 
        												                      -> r3.z = {(1 - T12.a)*[T11.x*(0.04*scale + bias)]} * saturate(R0Y - 1) -> spec_second_intensity 
        mad r6.xyz, r7.yzwy, r0.yyyy, r6.xyzx  			  -> spec * IBL_sample_col * RN_shift_intensity + ibl_spec2_output 
        mad r5.y, -r8.w, r7.x, l(1.000000)  			    -> 1 - IBL_sample_alpha * 距离缩放因子 
        mul r3.z, r3.z, r5.y 							            -> r3.z * {1 - IBL_sample_alpha * 距离缩放因子} -> 对r3.z进行缩放修正(注意Loop条件) 
      endif 
      iadd r4.w, r4.w, l(1) 							            -> i++ 
    endloop 

    //和采样天空盒同一个开关，总是true 
    if_nz r1.x 
      add r0.x, -r2.w, cb2[0].x 						          -> 1.815 - [1 - 1.2 * ln(T11.y)] 
      add r0.x, r0.x, l(-1.000000) 						        -> 1.815 - [1 - 1.2 * ln(T11.y)] - 1 -> 注意,若T11.y=0, ln(0)=-∞ 

      //使用 View_Reflection 采样 天空盒 
      sample_l_indexable(texturecube)(float,float,float,float) r4.xyz, r11.yzwy, t0.xyzw, s1, r0.x 
      mul r4.xyz, r4.xyzx, cb1[180].xyzx 				      -> 天空盒返回值 * [4.9, 4.19, 3.1] 

      lt r0.z, l(0.000000), cb2[0].w 					        -> 0 < -0.00087 -> false 
      if_nz r0.z 
      	//采样另一个天空盒 
        sample_l_indexable(texturecube)(float,float,float,float) r0.xzw, r11.yzwy, t1.xwyz, s2, r0.x 
        mad r0.xzw, r0.xxzw, cb1[180].xxyz, -r4.xxyz 
        mad r4.xyz, cb2[0].wwww, r0.xzwx, r4.xyzx 
      endif 

      mad r1.yzw, r4.xxyz, r0.yyyy, r1.yyzw           -> 天空盒采样值 * V_CB1_180 * RN_shift_intensity + gi_spec_second_base -> 这一步用于更新 gi_spec_second_base 
    endif 

    mul r0.xyz, r1.yzwy, r3.zzzz 						          -> gi_spec_second_base * spec_second_intensity = sunLight_spec_final 
    mad r0.xyz, r6.xyzx, cb1[156].xyzx, r0.xyzx			  -> ibl_spec2_output * 1 + sunLight_spec_final 
    mad r0.xyz, cb1[134].yyyy, r0.xyzx, r5.xzwx			  -> 1 * (ibl_spec2_output + sunLight_spec_final) + 第一个IBL计算后输出的 GI_spec 结果 
    													                        -> 叠加了2次 IBL 采样和计算结果 -> prefilter_Specular_Final 
  else 
  	//不是4号材质的时候进入这个分支 
    sample_l_indexable(texture2d)(float,float,float,float) r1.xy, r3.xwxx, t5.xyzw, s4, l(0.000000)  -> 采样 LUT 
    mul_sat r0.w, r9.y, l(50.000000) 					        -> R9色.Y通道 * 50 -> 待考: R9颜色似乎是一种环境光底色 
    mul r0.w, r1.y, r0.w 								              -> bias * saturate(50 * R9.y) 
    mad r1.xyz, r9.xyzx, r1.xxxx, r0.wwww 				    -> R9色 * scale + bias * saturate(50 * R9.y) 
    mul r0.xyz, r1.xyzx, r2.xyzx 						          -> prefilter_Specular * [R9色 * scale + bias * saturate(50 * R9.y)]
    													                        -> prefilter_Specular_Final  
  endif 

  min r0.xyz, -r0.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)	-> 去除 r0 颜色中小于 0 的部分 
  add o0.xyz, -r0.xyzx, r10.xyzx  									  -> 最终输出颜色由: prefilter_Specular_Final + Diffuse 构成 
  																	                  -> R10颜色 据此推断为 Diffuse 
else 
  mov o0.xyz, r10.xyzx 		                            -> 对于 0号 或 7号 材质渲染方案来说，直接使用 R10.xyz的颜色(Diffuse) 输出值作为 GI 
endif 
ret 
// Approximately 0 instruction slots used
