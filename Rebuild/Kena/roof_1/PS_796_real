//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// TEXCOORD                10   xyzw        0     NONE   float   xyz 
// TEXCOORD                11   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xyzw        2     NONE   float   xy  
// PRIMITIVE_ID             0   x           3     NONE    uint   x   
// SV_Position              0   xyzw        4      POS   float   xyzw
// SV_IsFrontFace           0   x           5    FFACE    uint   x   
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
// SV_Target                1   xyzw        1   TARGET   float   xyzw
// SV_Target                2   xyzw        2   TARGET   float   xyzw
// SV_Target                3   xyzw        3   TARGET   float   xyzw
// SV_Target                4   xyzw        4   TARGET   float   xyzw
// SV_DepthLessEqual        0    N/A oDepthLE  DEPTHLE   float    YES
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[178], immediateIndexed
dcl_constantbuffer CB1[8], immediateIndexed             -> CBV 1465 
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_sampler s2, mode_default
dcl_sampler s3, mode_default

dcl_resource_structured t0, 16                          -> Data Buffer 
dcl_resource_texture2d (float,float,float,float) t1     -> Normal Tex rg
dcl_resource_texture2d (float,float,float,float) t2     -> Grass RGBA 
dcl_resource_texture2d (float,float,float,float) t3     -> Noise RGB
dcl_resource_texture2d (float,float,float,float) t4     -> Common Noise R

dcl_input_ps linear centroid v0.xyz         -> NormalWS
dcl_input_ps linear centroid v1.xyzw        -> TangentWS
dcl_input_ps linear v2.xy                   -> UV
dcl_input_ps constant v3.x                  -> PRIMITIVE_ID

dcl_input_ps_siv linear noperspective centroid v4.xyzw, position      -> PosHCS -> 注:xyzw含义已经变化[pixelIdx.xy, NDC.z, -Clip.w] 
dcl_input_ps_sgv constant v5.x, is_front_face                         -> VFACE 

dcl_output o0.xyzw        未知 -> 类似剪影，基本上只渲染上了天空盒，以及极少数半透明物件(灯笼？)  T:8264 
                          o0 = [混淆后的BaseColor.rgb, 0]
dcl_output o1.xyzw        可能是 normal  A通道在角色上0.66，在某些其他物件上0.33   T:8220
                          o1 = [NormalWS.xyz, t0[PRIMTIVE_ID]]
dcl_output o2.xyzw        未知 -> 偏蓝 且 w分量设置为 0.694118  T:8241  
                          o2 = [NoiseTex.x, CommonNoise.x关联值, NoiseTex.x偏移值, 0.694118]
dcl_output o3.xyzw        可能是 base color -> 存放了 采样base Color 且经过变换后的颜色  T:8222 
                          o3 = [去除强度的BaseColor.rgb, BaseCol与NoiseTex的混淆] 
dcl_output o4.xyzw        未知 -> 似乎区分了角色本体，树叶和建筑 -> 一种 Mask ?    T:8223
                          o4 = [0,0,0,0]   
dcl_output oDepthLE
dcl_temps 7

//获取 BitangentWS -> r0.xyz = Cross(NormalWS，TangentWS) * sign 
mul r0.xyz, v0.yzxy, v1.zxyz
mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx
mul r0.xyz, r0.xyzx, v1.wwww

//准备参数：
//r1.x = VertexInput.z * VertexInput.w  ->  NDC.z * Clip.w = Clip.z 所有r1.x保存了Clip.z的数值 
//r1.y = 1 
//r1.z = VertexInput.w   -> r1.z 保存的是 ViewSpace下该fragment对应几何体微分中心点到摄像机的z轴距离（投影到中轴线上的长度） 
mov r1.x, v4.z
mov r1.y, l(1.000000)
mul r1.xz, r1.xxyx, v4.wwww 

//此处通过采样和解码，似乎是为了获得 Bitangent的朝向w 
imad r2.xy, v3.xxxx, l(35, 35, 0, 0), l(4, 20, 0, 0)
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r0.w, r2.x, l(12), t0.xxxx
mul r0.w, r0.w, cb0[140].w
movc r1.w, v5.x, l(1.000000), l(-1.000000)   根据VFACE判断当前像素所在几何体是正面朝向视点还是背面 
mul r0.w, r0.w, r1.w    这里赋值r0.w 而r0.xyz是Bitangent 


//采样法线纹理，解码位于切线空间的法线原始数，R2 在采样后就不再代表UV了
mul r2.xz, v2.xxyx, cb1[4].xxxx       -> 缩放了UV *= 1，随后拿去采样 Normal 纹理（只有RG通道） -> cb1[4].x = 1 
sample_b_indexable(texture2d)(float,float,float,float) r2.xz, r2.xzxx, t1.xzyw, s0, cb0[142].y
mad r3.xy, r2.xzxx, l(2.000000, 2.000000, 0.000000, 0.000000), l(-1.000000, -1.000000, 0.000000, 0.000000)
dp2 r1.w, r3.xyxx, r3.xyxx
add r1.w, -r1.w, l(1.000000)
max r1.w, r1.w, l(0.000000)
sqrt r3.z, r1.w                                       -> 到这里从RG通道中解出了第三个通道B
mad r2.xzw, r3.xxyz, cb0[137].wwww, cb0[137].xxyz     -> 对切线空间法线进行 Scale 和 Offset 等常规操作 
dp3 r1.w, r2.xzwx, r2.xzwx
rsq r1.w, r1.w
mul r2.xzw, r1.wwww, r2.xxzw                          -> 归一化 切线空间 Normal 

//应用TBN矩阵将贴图法线转换到世界空间下，随后归一化，调整朝向 
//此后 R0.xyz 代表 NormalWS 
mul r0.xyz, r0.xyzx, r2.zzzz
mad r0.xyz, r2.xxxx, v0.xyzx, r0.xyzx
mad r0.xyz, r2.wwww, v1.xyzx, r0.xyzx
dp3 r1.w, r0.xyzx, r0.xyzx
rsq r1.w, r1.w
mul r0.xyz, r0.xyzx, r1.wwww    再次归一化
mul r0.xyz, r0.wwww, r0.xyzx    调整朝向

mul r2.xzw, cb1[1].xxyz, cb1[4].yyyy   -> 清除R2 

//用UV采样 Grass 纹理，获取基础色，返回值存放在了 R3 中 
mul r3.xy, v2.xyxx, cb1[5].xxxx     -> cb1[5].x = 2 -> UV scale by 2 
sample_b_indexable(texture2d)(float,float,float,float) r3.xyz, r3.xyxx, t2.xyzw, s1, cb0[142].y 
mul r3.xyz, r3.xyzx, cb1[5].yyyy    -> cb1[5].y = 1 -> baseCol 缩放 1 倍   -> 任然是 R3 
mul r4.xyz, r3.xyzx, cb1[3].xyzx    -> cb1[3].xyz = [0.28,0.23,0.08] -> 在RGB通道各自缩放一定比例 -> 临时记为 R4 颜色 

//设 k = float3(0.577350, 0.577350, 0.577350)
dp3 r0.w, l(0.577350, 0.577350, 0.577350, 0.000000), r4.xyzx                  -> 则有 r0.w = dot(R4, k)
mul r1.w, r0.w, l(0.577350)                                                   -> r1.w = k * dot(R4, k)
mad r3.xyz, r3.xyzx, cb1[3].xyzx, -r1.wwww  -> 接下来会对临时颜色R4'(存入了r3)进行色调变换，设此处返回值 R4' = R4 - k * dot(R4, k)
mul r4.xyz, r3.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000)                -> mul + mad 组合的标注叉乘形式 
mad r4.xyz, r3.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000), -r4.zxyz      -> cross(R4', k) 
sincos r5.x, r6.x, cb1[4].w                                                   -> cb1[4].w = 0 记为角度A 
mul r4.xyz, r4.xyzx, r5.xxxx                                                  -> cross(R4', k) * sinA 
mad r3.xyz, r3.xyzx, r6.xxxx, r4.xyzx                                         -> R4' * cosA + cross(R4', k) * sinA 
mad r3.xyz, r0.wwww, l(0.577350, 0.577350, 0.577350, 0.000000), r3.xyzx       -> k * dot(R4, k) + R4' * cosA + cross(R4', k) * sinA 
//以上操作含义是：
//获取Grass的基础色，然后依据存储在 cb1[4].w 内的角度，进行色调(Hue)旋转, 最后将返回值保存在 R3.xyz 中  
//采样 GrassTexture + RGB各分量缩放和修正 + 色调偏转后 -> 返回到 R3 中  
//色调(Hue)旋转参考链接：https://forum.unity.com/threads/hue-saturation-brightness-contrast-shader.260649/ 

//已知 outputCol dot (0.3,0.59,0.11) = ColorIntensity 
//以下逻辑用于求取 R3 颜色的 强度 Intensity 或叫做 Cdlum 
dp3 r0.w, r3.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000)

//通过 Lerp 得到最终基础色 R4 
add r4.xyz, -r3.xyzx, r0.wwww                   -> Cdlum - R3
mad_sat r3.xyz, cb1[5].zzzz, r4.xyzx, r3.xyzx   -> cb1[5].z=0 -> R3=saturate((Cdlum - R3) * Rate + R3) -> 从 R3 lerp 到 Cdlum 

//采样 Noise RGB 纹理 -> 存放在 R0.w 中
mul r4.xy, v2.xyxx, cb1[6].yyyy    -> cb1[6].y=17 -> UV scale by 17 
sample_b_indexable(texture2d)(float,float,float,float) r0.w, r4.xyxx, t3.yzwx, s2, cb0[142].y  -> 取NoiseRGB.x 通道值 

//利用 VertexInput.xy 构造顶点噪声      -> 存入 r1.w 
add r4.xy, v4.xyxx, -cb0[129].xyxx    -> cb0[129] = 0,0,0,0
add r4.zw, r4.xxxy, cb0[151].xxxx     -> cb0[151] = 0,0,0,0  对当前fragment在屏幕上的坐标进行两次独立偏移 
ftou r4.zw, r4.zzzw                   -> r4.xy是屏幕坐标原始值，r4.zw是屏幕坐标整数值 -> 这步可以佐证 VertexInput.xy = 屏幕像素坐标 
ishl r1.w, r4.w, l(1)                 -> VertexInput.y << 1 
iadd r1.w, r1.w, r4.z                 -> VertexInput.y * 2 + VertexInput.x 
udiv null, r1.w, r1.w, l(5)           -> (VertexInput.y * 2 + VertexInput.x) mod 5 -> 求余数 -> 存入R1.w(可取值: 0,1,2,3,4) 
utof r1.w, r1.w

//采样 Common Noise，uv来自于屏幕像素坐标的变换 -> 采样返回 R 通道的一个数值 
//随机值 R1.w 基于屏幕像素位置 -> 理论上会随着 视点View 的改变而改变 -> 并不是固定在模型空间上的随机数 
mul r4.xy, r4.xyxx, l(0.015625, 0.015625, 0.000000, 0.000000)    -> 0.015625=1/64 -> Int型posPS.xy/64 -> 一个Tile=64*64么? 
//在64*64见方的像素内，如下采样会得到相同的返回值 
sample_b_indexable(texture2d)(float,float,float,float) r3.w, r4.xyxx, t4.yzwx, s3, cb0[142].y
add r1.w, r1.w, r3.w            -> r1.w           取值 0.0 ~ 4.99 
mul r1.w, r1.w, cb1[6].w        -> cb1[6].w = 30  取值 0.0 ~ 149.99 
mul r1.w, r1.w, l(0.166667)    -> 0.1667 = 1/6    取值 0.0 ~ 24.99 

//目的是为了转换出 R1.y -> 某种基于距离的 Noise -> 推测用于 Dithering(?) 在一定距离内
//R1.y 等效于一种计算出来的 NDC.z 
//若 Clip.w 没有落在 [24~280] 间，则下面的 div_sat 指令会在结果小于24时返回值恒为0，大于280时返回恒为1 
//Clip.w 等效视空间z轴距离 
mad r1.y, r1.y, v4.w, l(-24.000000)   -> r1.y = 1 * Clip.w - 24 -> 视空间z轴距离 - 常量24 
div_sat r1.y, r1.y, cb1[7].x          -> cb1[7].x = 256 -> r1.y = saturate((Clip.w-24)/256) 
mad r1.y, r1.y, r1.w, r1.z            -> r1.y = saturate((Clip.w-24)/256) * rand[0, 24.99] + Clip.w 
div r1.y, r1.x, r1.y                  -> r1.y = Clip.z / (saturate((Clip.w-24)/256) * rand[0, 24.99] + Clip.w) 
min r1.y, r1.y, v4.z                  -> r1.y 不能大于 NDC.z -> 既取到的 R1.y 总是在原始 NDC.z 之前（靠近摄像机) 

add r0.w, r0.w, l(-0.100000)          -> NoiseRGB.x - 0.1
lt r0.w, r0.w, l(0.000000)            -> (NoiseRGB.x - 0.1) < 0 ? true : false 
discard_nz r0.w
mov_sat r0.w, cb1[5].w
mov_sat r1.w, cb1[6].x
mad o2.z, r1.w, cb0[138].y, cb0[138].x
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) o1.w, r2.y, l(4), t0.xxxx
mul r1.w, r0.w, cb0[136].w
mad r4.xyz, r3.xyzx, cb0[135].wwww, cb0[135].xyzx
mad r5.xyz, r1.wwww, l(0.080000, 0.080000, 0.080000, 0.000000), cb0[136].xyzx
ne r1.w, l(0.000000, 0.000000, 0.000000, 0.000000), cb0[177].w
mad r6.xyz, r5.xyzx, l(0.450000, 0.450000, 0.450000, 0.000000), r4.xyzx
movc r4.xyz, r1.wwww, r6.xyzx, r4.xyzx
movc r5.xyz, r1.wwww, l(0,0,0,0), r5.xyzx
dp3 r1.w, r5.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000)
mad r2.y, r1.w, l(2.040400), l(-0.332400)
mad r2.y, r1.w, l(-4.795100), r2.y
mad r1.w, r1.w, l(2.755200), r2.y
add r1.w, r1.w, l(1.332000)
max o3.w, r1.w, l(1.000000)
mad r4.xyz, r5.xyzx, l(0.450000, 0.450000, 0.450000, 0.000000), r4.xyzx
max r2.xyz, r2.xzwx, l(0.000000, 0.000000, 0.000000, 0.000000)
lt r1.w, l(0.000000), cb0[139].x
if_nz r1.w
  mul r5.xyzw, v4.yyyy, cb0[45].xyzw
  mad r5.xyzw, v4.xxxx, cb0[44].xyzw, r5.xyzw
  mad r5.xyzw, v4.zzzz, cb0[46].xyzw, r5.xyzw
  add r5.xyzw, r5.xyzw, cb0[47].xyzw
  div r5.xyz, r5.xyzx, r5.wwww
  add r6.xyz, r5.xyzx, -cb0[70].xyzx
  dp3 r1.w, -r5.xyzx, -r5.xyzx
  rsq r1.w, r1.w
  mul r5.xyz, r1.wwww, -r5.xyzx
  mad r1.x, -r1.y, r1.z, r1.x
  div r1.x, r1.x, r1.y
  mad r1.xzw, r5.xxyz, r1.xxxx, r6.xxyz
  imad r5.xy, v3.xxxx, l(35, 35, 0, 0), l(5, 19, 0, 0)
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r5.xzw, r5.x, l(0), t0.xxyz
  add r5.xzw, r1.xxzw, -r5.xxzw
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r6.xyz, r5.y, l(0), t0.xyzx
  add r6.xyz, r6.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)
  lt r5.xyz, r6.xyzx, |r5.xzwx|
  or r2.w, r5.y, r5.x
  or r2.w, r5.z, r2.w
  dp3 r1.x, r1.xzwx, l(0.577000, 0.577000, 0.577000, 0.000000)
  mul r1.x, r1.x, l(0.002000)
  frc r1.x, r1.x
  lt r1.x, l(0.500000), r1.x
  movc r1.xzw, r1.xxxx, l(0,0,1.000000,1.000000), l(1.000000,0,1.000000,0)
  movc r2.xyz, r2.wwww, r1.xzwx, r2.xyzx
endif 
mad r1.xzw, cb0[144].yyyy, r4.xxyz, r2.xxyz
mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000)
mul o0.xyz, r1.xzwx, cb0[134].yyyy
mov o0.w, l(0)
mov o2.xw, l(0,0,0,0.694118)
mov o2.y, r0.w
mov o3.xyz, r3.xyzx
mov o4.xyzw, l(0,0,0,0)
mov oDepthLE, r1.y
ret 
// Approximately 0 instruction slots used
