mrt_skin_ps

Shader hash 12b9b4c9-f8473fbb-af9f8a14-e11be3bf

ps_5_0
      dcl_globalFlags refactoringAllowed
      dcl_constantbuffer cb0[201], immediateIndexed
      dcl_constantbuffer cb1[21], immediateIndexed
      dcl_constantbuffer cb2[1], immediateIndexed
      dcl_constantbuffer cb3[18], immediateIndexed
      dcl_sampler s0, mode_default
      dcl_sampler s1, mode_default
      dcl_sampler s2, mode_default
      dcl_sampler s3, mode_default
      dcl_sampler s4, mode_default
      dcl_sampler s5, mode_default
      dcl_sampler s6, mode_default
      dcl_sampler s7, mode_default
      dcl_sampler s8, mode_default

      dcl_resource_texture2d (float,float,float,float) t0               -> SSProfileTex
      dcl_resource_texture2d (float,float,float,float) t1               -> kena_cloth_NORMAL_v2
      dcl_resource_texture2d (float,float,float,float) t2               -> skin_n
      dcl_resource_texture2d (float,float,float,float) t3               -> Noise_cloudsmed
      dcl_resource_texture2d (float,float,float,float) t4               -> kena_cloth_EMISSIVE_MASK
      dcl_resource_texture2d (float,float,float,float) t5               -> kena_cloth_BASECOLOR : Albedo
      dcl_resource_texture2d (float,float,float,float) t6               -> Kena_Dirt_MASKS
      dcl_resource_texture2d (float,float,float,float) t7               -> kena_cloth_AO_R_M
      dcl_resource_texture2d (float,float,float,float) t8               -> skin_h : skin noise
      dcl_resource_texture2d (float,float,float,float) t9               -> kena_cloth_SSS_MASK

      dcl_input_ps linear centroid v0.xyz                               -> normal -> tangent
      dcl_input_ps linear centroid v1.xyzw                              -> tangent -> normal + sign  
      dcl_input_ps linear v2.xy                                         -> uv 
      dcl_input_ps_siv linear noperspective v3.xyz, position            -> SV Position 

      dcl_output o0.xyzw                                                -> Emission 
      dcl_output o1.xyzw                                                -> World_Normal 
      dcl_output o2.xyzw                                                -> Comp_M_D_R_F 
      dcl_output o3.xyzw                                                -> Albedo 
      dcl_output o4.xyzw                                                -> Custom 
      dcl_temps 10

//Normal
   0: mul r0.xyz, v0.yzxy, v1.zxyz
   1: mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx                            -> cross(v1, v0) -> tangent X normal 
   2: mul r0.xyz, r0.xyzx, v1.wwww                                      -> bitangent = cross(tangent, normal) * tangent.w 

   3: sample_b(texture2d)(float,float,float,float) r1.xy, v2.xyxx, t1.xyzw, s0, cb0[142].y      -> Sampele kena_cloth_NORMAL_v2
   4: mad r1.xy, r1.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
   5: dp2 r0.w, r1.xyxx, r1.xyxx
   6: add r0.w, -r0.w, l(1.0000)
   7: max r0.w, r0.w, l(0)
   8: sqrt r0.w, r0.w
   9: add r1.z, r0.w, l(1.0000)                 Unpack NormalTS 其中 p_norm.z = z + 1 -> 取值范围 [0, 2]

  10: mul r2.xy, v2.xyxx, cb3[12].xxxx                                  -> uv * cb3[12].x=52.0f 
  11: sample_b(texture2d)(float,float,float,float) r2.zw, r2.xyxx, t2.zwxy, s1, cb0[142].y      -> Sample skin_n
  12: add r3.xy, r2.zwzz, r2.zwzz
  13: mad r2.zw, r2.zzzw, l(0.0000, 0.0000, 2.0000, 2.0000), l(0.0000, 0.0000, -1.0000, -1.0000)
  14: dp2 r0.w, r2.zwzz, r2.zwzz
  15: add r0.w, -r0.w, l(1.0000)
  16: max r0.w, r0.w, l(0)
  17: sqrt r3.z, r0.w
  18: add r3.xyz, r3.xyzx, l(-1.0000, -1.0000, -1.0000, 0.0000)
  19: mad r3.xyz, cb3[12].yyyy, r3.xyzx, l(0, 0, 1.0000, 0)             -> d_norm = cb3[12].y=0.5(DetailAmount) * d_norm + float3(0,0,1)
                                                                        -> DetailAmount = 0.5
  20: mul r3.xyw, r3.xyxz, l(-2.0000, -2.0000, 0.0000, 2.0000)
  21: mad r3.xyz, r3.zzzz, l(0.0000, 0.0000, 4.0000, 0.0000), -r3.xywx
  22: mul r3.xyz, r3.xyzx, l(-1.0000, -1.0000, 1.0000, 0.0000)          -> d_norm *= float3(-1, -1, 1)

  23: dp3 r0.w, r1.xyzx, r3.xyzx                            -> pod = dot(p_norm, d_norm)
  24: mul r3.xyz, r1.zzzz, r3.xyzx                          -> d_norm *= p_norm.z 
  25: mad r1.xyz, r1.xyzx, r0.wwww, -r3.xyzx                -> p_norm = p_norm * pod - d_norm -> MixWithDetailNormal
  26: dp3 r0.w, r1.xyzx, r1.xyzx
  27: sqrt r0.w, r0.w
  28: div r1.xyz, r1.xyzx, r0.wwww                          -> norm = normalize(p_norm)

  29: mad r1.xyz, r1.xyzx, cb0[137].wwww, cb0[137].xyzx     -> norm = norm * 1 + 0 -> scale and offset 
  30: dp3 r0.w, r1.xyzx, r1.xyzx
  31: rsq r0.w, r0.w
  32: mul r1.xyz, r0.wwww, r1.xyzx                          -> nTS = normalize(norm)

  33: mul r0.xyz, r0.xyzx, r1.yyyy
  34: mad r0.xyz, r1.xxxx, v0.xyzx, r0.xyzx
  35: mad r0.xyz, r1.zzzz, v1.xyzx, r0.xyzx
  36: dp3 r0.w, r0.xyzx, r0.xyzx
  37: rsq r0.w, r0.w
  38: mul r0.xyz, r0.wwww, r0.xyzx                          half3 nDirWS = normalize(mul(nTS, tbn));

//Emissive
  39: lt r0.w, l(0.0000), abs(cb3[13].x)                    -> flase : cb3[13].x=0
  40: ge r1.x, cb3[13].x, l(0)                              -> true
  41: and r1.x, r1.x, cb3[13].z                             -> true & 0.02 -> 0.02
  42: and r0.w, r0.w, r1.x                                  -> false & (~) -> 0 -> emitThresould
  43: mul r1.xy, v2.xyxx, cb3[13].wwww                      -> uv * cb3[13].w=1
  44: sample_b(texture2d)(float,float,float,float) r1.x, r1.xyxx, t3.xyzw, s2, cb0[142].y       Sample Noise_cloudsmed
  45: add r1.y, r0.w, -r1.x                                 -> thresould = emitThresould - noise
  46: lt r1.y, l(0.0000), abs(r1.y)                         -> 0 < abs(thresould) ? true : false
  47: ge r0.w, r0.w, r1.x                                   -> enableGlowColor = emitThresould >= noise ? true : false
  48: and r1.xzw, r0.wwww, cb3[2].xxyz                      -> enableGlowColor & GlowColor=[0,0.5,1] -> glowCol
  49: and r1.xyz, r1.xzwx, r1.yyyy                          -> glowCol = thresould & glowCol

  50: mad r0.w, cb3[14].z, cb2[0].y, cb3[14].w        -> emiScale = cb2[0].y=0(GlowAmount) * cb3[14].z=1(scale) + cb3[14].w=0(offset) 
  51: sample_b(texture2d)(float,float,float,float) r3.xyz, v2.xyxx, t4.xyzw, s3, cb0[142].y     Sample kena_cloth_EMISSIVE_MASK
  52: mul r3.xyz, r3.xyzx, cb2[0].yyyy                      -> emissiveMsk *= GlowAmount
  53: mul r3.xyz, r3.xyzx, cb3[15].xxxx                     -> emissiveMsk *= cb3[15].x=1(EmissiveIntensity)
  54: mad r3.xyz, r3.xyzx, cb3[4].xyzx, cb3[5].xyzx         -> emissiveMsk = emissiveMsk * cb3[4].xyz=[0,1,2](EmissiveTint) + [0,0,0]
  55: mul r3.xyz, r0.wwww, r3.xyzx                          -> emissiveMsk *= emiScale
  56: mul r3.xyz, r3.xyzx, cb3[4].xyzx                      -> emiCol = emissiveMsk * EmissiveTint
  57: mad r1.xyz, r1.xyzx, cb3[14].xxxx, r3.xyzx            -> emiCol = glowCol * cb3[14].x=50(DissolveEmissiveAmount) + emiCol
  58: add r3.xyz, -r1.xyzx, cb3[6].xyzx
  59: mad r1.xyz, cb3[15].yyyy, r3.xyzx, r1.xyzx      -> emiCol = lerp(emiCol, cb3[6].xyz=0(EmissiveColor), cb3[15].y=0(EmissiveScale))

//Mix Albedo with Dirt
  60: sample_b(texture2d)(float,float,float,float) r3.xyz, v2.xyxx, t5.xyzw, s4, cb0[142].y     Sample kena_cloth_BASECOLOR
                                                            -> RawAlbedo.xyz
  61: sample_b(texture2d)(float,float,float,float) r4.xyz, v2.xyxx, t6.xyzw, s5, cb0[142].y     Sample Kena_Dirt_MASKS
  62: dp3 r0.w, r4.xyzx, cb3[8].xyzx                        -> DirtChan = dot(Dirt.rgb, cb3[8].xyz=[0,1,0](DirtChannel))
  63: add r4.xyz, r0.wwww, cb3[10].xyzx                     -> DirCol = cb3[10].xyz=[0.100694, 0.061721, 0.038809](DirtColor) + DirtChan
  64: add r4.xyz, r4.xyzx, l(-1, -1, -1, 0)
  65: mad r4.xyz, cb2[0].wwww, r4.xyzx, l(1.0000, 1.0000, 1.0000, 0.0000)     -> DirCol = lerp(1, DirCol, cb2[0].w=0(DirtAmount))
  66: mul r3.xyw, r3.xyxz, r4.xyxz                          -> Albedo = RawAlbedo * DirCol

//Apply direct AO to Albedo
  67: sample_b(texture2d)(float,float,float,float) r2.zw, v2.xyxx, t7.zwxy, s6, cb0[142].y      Sample kena_cloth_AO_R_M -> AO_R
  68: add r0.w, r2.z, cb3[15].z                             -> DirectAO = AO * cb3[15].z=0.4(AO_Ammount)
  69: max r0.w, r0.w, cb3[15].w                             -> DirectAO = max(DirectAO, cb3[15].w=0(AO_Min))
  70: min r0.w, r0.w, l(1.0000)                             -> DirectAO = min(DirectAO, 1)
  71: mul r3.xyw, r0.wwww, r3.xyxw                          -> Albedo *= DirectAO
  72: mul r3.xyw, r3.xyxw, cb3[16].xxxx                     -> Albedo *= cb3[16].x=1.50(BaseColorBrightness)
  73: mul_sat r3.xyw, r3.xyxw, cb3[11].xyxz                 -> Albedo = saturate(Albedo * cb3[11].xyz=[0.99,1.00259,1.1](BaseColortint))

//Spec
  74: add r0.w, -cb3[16].z, cb3[16].y
  75: mad_sat r4.x, r3.z, r0.w, cb3[16].z    -> Specular = saturate(lerp(cb3[16].z=0(SpecularMin), cb3[16].y=2.2(SpecularMax), RawAlbedo.z))

//Roughness
  76: max r0.w, cb2[0].z, l(0)                              -> RoughnessAmount = max(cb2[0].z=0(MinWet), 0)
  77: min r0.w, r0.w, cb3[16].w                             -> RoughnessAmount = min(RoughnessAmount, cb3[16].w]=0.5(MaxWet))
  78: add r0.w, r0.w, l(-1.0000)                            -> RoughnessAmount -= 1
  79: mul r0.w, abs(r0.w), cb3[17].x                        -> RoughnessAmount = abs(RoughnessAmount) * cb3[17].x=1(Roughness)
  80: mul r0.w, r0.w, r2.w                                  -> R = R * RoughnessAmount
  81: sample_b(texture2d)(float,float,float,float) r1.w, r2.xyxx, t8.xyzw, s7, cb0[142].y             Sample skin_h
  82: mad r0.w, r1.w, cb3[12].y, r0.w                       -> R = skin_h * cb3[12].y=0.5(DetailAmount) + R
  83: add_sat r0.w, r0.w, l(-0.1000)                        -> R = saturate(R - 0.1)

//Skin Scatter
  84: sample_b(texture2d)(float,float,float,float) r1.w, v2.xyxx, t9.xzwy, s8, cb0[142].y             Sample kena_cloth_SSS_MASK
  85: add r2.x, -cb3[17].z, cb3[17].y 
  86: mad_sat r2.y, r1.w, r2.x, cb3[17].z       -> Scatter = saturate(lerp(cb3[17].z=0.5(ScatterMin), cb3[17].y=1(ScatterMax), sssMsk))

//AO
  87: mov_sat r2.z, r2.z                                    -> AO = saturate(AO)

//Roughness
  88: mad r4.y, r0.w, cb0[138].y, cb0[138].x                -> R = R * _GlobalRoughnessScaler + _GlobalRoughnessBias

//if Scatter > 0.1
  89: lt r0.w, l(0.1000), r2.y
  90: if_nz r0.w
  91:   mad r0.w, cb3[17].w, l(255.0000), l(0.5000)         -> cb3[17].w=0.0117647(ScatterIntensity) * 255 + 0.5 = 3.4999
  92:   ftou r5.y, r0.w                                     -> 3 -> Row Index for SSProfileTex
  93:   mov r5.xzw, l(5, 0, 0, 0)                           -> r5.xyzw = [5, 3, 0, 0] -> 5 -> Shading mode id
  94:   ld_indexable(texture2d)(float,float,float,float) r0.w, r5.xyzw, t0.xyzw     Load SSProfileTex from [5, 64-3, 0] -> averageR
  95:   add r1.w, r2.y, l(-0.1000) 
  96:   mul_sat r1.w, r1.w, l(10.0000)
  97:   mad r0.w, r0.w, l(2.0000), l(-1.0000)
  98:   mad r0.w, r1.w, r0.w, l(1.0000)
  99:   mul_sat r4.y, r0.w, r4.y                            -> R = saturate((saturate((Scatter - 0.1) * 10) * (averageR * 2 - 1) + 1) * R);
 100:   mov r2.x, cb3[17].w                                 -> CustomData.x = ScatterIntensity
 101:   mov r0.w, l(5)                                      -> Shading mode id = 5
 102: else
 103:   mov r2.xy, l(0, 0, 0, 0)
 104:   mov r0.w, l(1)
 105: endif

//Final AO
 106: mul r1.w, r4.x, l(0.0800)                             -> F0 = DielectricSpecularToF0(Specular)

 107: ftou r5.xy, v3.xyxx
 108: ftou r2.w, cb0[151].x
 109: iadd r3.z, r5.y, r5.x
 110: iadd r2.w, r2.w, r3.z
 111: and r2.w, r2.w, l(1)                                  -> bool bCheck = CheckerFromSceneColorUV(i.vertex.xy);

 112: ieq r3.z, r0.w, l(5)                                  -> bool useSSMode5 = SubsurfaceProfileShadingMode == 5;
 113: lt r5.x, l(0), cb0[155].x                             -> bool value A -> true 
 114: lt r5.y, l(0), cb0[200].z                             -> bool value B -> true
 115: and r5.z, r5.y, r5.x                                  -> bool useSeperate = true

 116: ne r5.w, l(0, 0, 0, 0), cb0[155].x                    -> bool value C -> true
 117: movc r6.xyz, r5.wwww, l(1.0000, 1.0000, 1.0000, 0.0000), r3.xywx
 118: movc r7.xy, r2.wwww, l(1.0000, 0.0000, 0.0000, 0.0000), l(0.0000, 1.0000, 0.0000, 0.0000)
 119: mul r2.w, r1.w, r7.y
 120: movc r6.xyz, r5.zzzz, r7.xxxx, r6.xyzx
 121: movc r2.w, r5.z, r2.w, r1.w
 122: movc r6.xyz, r3.zzzz, r6.xyzx, r3.xywx
 123: movc r1.w, r3.z, r2.w, r1.w
 124: mad r6.xyz, r6.xyzx, cb0[135].wwww, cb0[135].xyzx           -> BaseCol * _GlobalBaseColScaler + _GlobalBaseColBias
 125: mad r7.xzw, r1.wwww, cb0[136].wwww, cb0[136].xxyz           -> SpecCol * _GlobalSpecColScaler + _GlobalSpecColBias

      half2 checkboard = bCheck ? half2(1, 0) : half2(0, 1); 
      half F0 = DielectricSpecularToF0(Specular);
      half encodedEmiSpec = F0 * checkboard.y;
      half3 encodedDiffuse = useSeperate ? checkboard.xxx : dBase;
      encodedEmiSpec = useSeperate ? encodedEmiSpec : F0;
      encodedDiffuse = useSSMode5 ? encodedDiffuse : dBase;
      encodedEmiSpec = useSSMode5 ? encodedEmiSpec : F0;
      half3 BaseCol = encodedDiffuse * _GlobalBaseColorScaler + _GlobalBaseColorBias;
      half3 SpecCol = encodedEmiSpec.xxx * _GlobalSpecularColorScaler + _GlobalSpecularColorBias;

 126: ne r1.w, l(0, 0, 0, 0), cb0[177].w
 127: mad r8.xyz, r7.xzwx, l(0.4500, 0.4500, 0.4500, 0.0000), r6.xyzx
 128: movc r6.xyz, r1.wwww, r8.xyzx, r6.xyzx
 129: movc r7.xzw, r1.wwww, l(0, 0, 0, 0), r7.xxzw
 130: dp3 r1.w, r7.xzwx, l(0.3000, 0.5900, 0.1100, 0.0000)
 131: mad r8.xyz, r1.wwww, l(2.0404, -4.7951, 2.7552, 0.0000), l(-0.3324, 0.6417, 0.6903, 0.0000)
 132: mad r1.w, r2.z, r8.x, r8.y
 133: mad r1.w, r1.w, r2.z, r8.z
 134: mul r1.w, r2.z, r1.w
 135: max o3.w, r1.w, r2.z                -> FinalAO

      bool RenderingReflectionCaptureMask = _RenderingReflectionCaptureMask > 0;
      [branch]
      if (RenderingReflectionCaptureMask)
      {
            EnvBRDFApproxFullyRough(BaseCol, SpecCol);
      }
      half FinalAO = AOMultiBounce(Luminance(SpecCol), AO).r;


 136: mad r6.xyz, r7.xzwx, l(0.4500, 0.4500, 0.4500, 0.0000), r6.xyzx
 137: max r1.xyz, r1.xyzx, l(0, 0, 0, 0)

      EnvBRDFApproxFullyRough(BaseCol, SpecCol);

 138: lt r1.w, l(0), cb0[139].x  
 139: if_nz r1.w
 140:   mul r8.xyzw, v3.yyyy, cb0[45].xyzw
 141:   mad r8.xyzw, v3.xxxx, cb0[44].xyzw, r8.xyzw
 142:   mad r8.xyzw, v3.zzzz, cb0[46].xyzw, r8.xyzw
 143:   add r8.xyzw, r8.xyzw, cb0[47].xyzw
 144:   div r7.xzw, r8.xxyz, r8.wwww
 145:   add r7.xzw, r7.xxzw, -cb0[70].xxyz
 146:   add r8.xyz, r7.xzwx, -cb1[5].xyzx
 147:   add r9.xyz, cb1[19].xyzx, l(1.0000, 1.0000, 1.0000, 0.0000)
 148:   lt r8.xyz, r9.xyzx, abs(r8.xyzx)
 149:   or r1.w, r8.y, r8.x
 150:   or r1.w, r8.z, r1.w
 151:   dp3 r2.z, r7.xzwx, l(0.5770, 0.5770, 0.5770, 0.0000)
 152:   mul r2.z, r2.z, l(0.0020)
 153:   frc r2.z, r2.z
 154:   lt r2.z, l(0.5000), r2.z
 155:   movc r7.xzw, r2.zzzz, l(0.0000, 0.0000, 1.0000, 1.0000), l(1.0000, 0.0000, 1.0000, 0.0000)
 156:   movc r1.xyz, r1.wwww, r7.xzwx, r1.xyzx
 157: endif

      half3 ReflectCol = BaseCol * _GlobalRelectionAmount;
      half3 BaseRTCol = ReflectCol + max(EmitCol.rgb, 0);
 158: mad r1.xyz, cb0[144].yyyy, r6.xyzx, r1.xyzx
 159: and r1.w, r3.z, r5.x
 160: and r1.w, r5.y, r1.w
 161: mul r5.xyz, r7.yyyy, r1.xyzx
 162: movc r1.xyz, r1.wwww, r5.xyzx, r1.xyzx
 163: mad o1.xyz, r0.xyzx, l(0.5000, 0.5000, 0.5000, 0.0000), l(0.5000, 0.5000, 0.5000, 0.0000)
 164: or r0.x, r0.w, l(161)               -> half Flag = (half)(SubsurfaceProfileShadingMode | 161);
 165: utof r0.x, r0.x
 166: mul r4.z, r0.x, l(0.0039)
 167: mul o0.xyz, r1.xyzx, cb0[134].yyyy
 168: mov o0.w, l(0)
 169: mov o1.w, cb1[20].y                 -> cb1[20].y=2/3
 170: mov r4.w, l(0)
 171: mov o2.xyzw, r4.wxyz
 172: mov o3.xyz, r3.xywx
 173: mov o4.xw, r2.xxxy
 174: mov o4.yz, l(0, 0, 0, 0)
 175: ret
