// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	ReflectionEnvironmentComputeShaders - functionality to apply local cubemaps.
=============================================================================*/
  
#include "Common.ush"
#include "DeferredShadingCommon.ush"  
#include "BRDF.ush"
#include "ReflectionEnvironmentShared.ush"
#include "SkyLightingShared.ush"
#include "DistanceFieldAOShared.ush"
#include "ShadingModels.ush"
#include "LightGridCommon.ush"
#include "SceneTextureParameters.ush"

#define REFLECTION_COMPOSITE_USE_BLENDED_REFLECTION_CAPTURES 1
#define REFLECTION_COMPOSITE_SUPPORT_SKYLIGHT_BLEND 1
#include "ReflectionEnvironmentComposite.ush"

float3 GatherRadiance(float CompositeAlpha, float3 WorldPosition, float3 RayDirection, float Roughness, float3 BentNormal, 
	float IndirectIrradiance, uint ShadingModelID, uint NumCulledReflectionCaptures, uint CaptureDataStartIndex)
{
	// Indirect occlusion from DFAO, which should be applied to reflection captures and skylight specular, but not SSR
	float IndirectSpecularOcclusion = 1.0f;
	float3 ExtraIndirectSpecular = 0;

#if SUPPORT_DFAO_INDIRECT_OCCLUSION
	float IndirectDiffuseOcclusion;
	GetDistanceFieldAOSpecularOcclusion(BentNormal, RayDirection, Roughness, ShadingModelID == SHADINGMODELID_TWOSIDED_FOLIAGE, IndirectSpecularOcclusion, IndirectDiffuseOcclusion, ExtraIndirectSpecular);
	// Apply DFAO to IndirectIrradiance before mixing with indirect specular
	IndirectIrradiance *= IndirectDiffuseOcclusion;
#endif

	const bool bCompositeSkylight = true;
	return CompositeReflectionCapturesAndSkylight(
		CompositeAlpha, 
		WorldPosition, 
		RayDirection, 
		Roughness, 
		IndirectIrradiance, 
		IndirectSpecularOcclusion, 
		ExtraIndirectSpecular, 
		NumCulledReflectionCaptures, 
		CaptureDataStartIndex, 
		0,
		bCompositeSkylight);
}


Texture2D ScreenSpaceReflectionsTexture;
SamplerState ScreenSpaceReflectionsSampler;


Texture2D AmbientOcclusionTexture;
SamplerState AmbientOcclusionSampler;


float3 ContrastAndNormalizeMulAdd;
float OcclusionExponent;
float OcclusionCombineMode;

void RemapClearCoatDiffuseAndSpecularColor(FGBufferData GBuffer, float2 ScreenPosition, inout float3 DiffuseColor, inout float3 SpecularColor)
{
	if (GBuffer.ShadingModelID == SHADINGMODELID_CLEAR_COAT)
	{
		// Attenuate base color and recompute diffuse color
		// 注意，传入的ScreenPosition的xy分量在[-SceneW， +SceneW]之间了，此时再乘以Depth会得到Depth^2的效果，这没有意义！
		// 正确应用View.ScreenToWorld的方法是，使用ScreenUV替换下面的ScreenPosition，注意ScreenUV属于[0, 1]区间，这才是屏幕空间（屏幕空间不应该出现负数！）
		float3 WorldPosition = mul(float4(ScreenPosition * GBuffer.Depth, GBuffer.Depth, 1), View.ScreenToWorld).xyz;
		float3 CameraToPixel = normalize(WorldPosition - View.WorldCameraOrigin);
		float3 V = -CameraToPixel;
		float NoV = saturate(dot(GBuffer.WorldNormal, V));
		float RefractionScale = ((NoV * 0.5 + 0.5) * NoV - 1) * saturate(1.25 - 1.25 * GBuffer.Roughness) + 1;

		float MetalSpec = 0.9;
		float3 AbsorptionColor = GBuffer.BaseColor * (1 / MetalSpec);
		float3 Absorption = AbsorptionColor * ((NoV - 1) * 0.85 * (1 - lerp(AbsorptionColor, Square(AbsorptionColor), -0.78)) + 1);

		float F0 = 0.04;
		float Fc = Pow5(1 - NoV);
		float F = Fc + (1 - Fc) * F0;
		float ClearCoat = GBuffer.CustomData.x;
		float LayerAttenuation = lerp(1, (1 - F), ClearCoat);

		float3 BaseColor = lerp(GBuffer.BaseColor * LayerAttenuation, MetalSpec * Absorption * RefractionScale, GBuffer.Metallic * ClearCoat);
		//BaseColor += Dither / 255.f;
		DiffuseColor = BaseColor - BaseColor * GBuffer.Metallic;

		float3 Specular = lerp(1, RefractionScale, ClearCoat);
		SpecularColor = ComputeF0(Specular, BaseColor, GBuffer.Metallic);
	}
}

float3 SkyLightDiffuse(FGBufferData GBuffer, float AmbientOcclusion, float2 BufferUV, float2 ScreenPosition, float3 BentNormal, float3 DiffuseColor)
{
	float2 UV = BufferUV;
	float3 Lighting = 0;

	float SkyVisibility = 1;
	float DotProductFactor = 1;
	float3 SkyLightingNormal = GBuffer.WorldNormal;
	BRANCH if( GBuffer.ShadingModelID == SHADINGMODELID_CLEAR_COAT && CLEAR_COAT_BOTTOM_NORMAL)
	{
		const float2 oct1 = ((float2(GBuffer.CustomData.a, GBuffer.CustomData.z) * 2) - (256.0/255.0)) + UnitVectorToOctahedron(GBuffer.WorldNormal);
		SkyLightingNormal = OctahedronToUnitVector(oct1);
	}
	
	float3 DiffuseIrradiance = 0;

#if APPLY_SKY_SHADOWING  //这条宏定义对应BentNormal
#define USE_DIRECTIONAL_OCCLUSION_ON_SKY_DIFFUSE 1

#if USE_DIRECTIONAL_OCCLUSION_ON_SKY_DIFFUSE
	{
		SkyVisibility = length(BentNormal); //BentNormal遮蔽强度，数值越小遮蔽越强
		float3 NormalizedBentNormal = BentNormal / (max(SkyVisibility, .00001f));		//归一化的BentNormal -> 纯方向

		// Use more bent normal in corners
		float BentNormalWeightFactor = SkyVisibility;

		SkyLightingNormal = lerp(NormalizedBentNormal, GBuffer.WorldNormal, BentNormalWeightFactor); //按遮蔽强弱在BentNormal和WorldNormal之前作平滑
		DotProductFactor = lerp(dot(NormalizedBentNormal, GBuffer.WorldNormal), 1, BentNormalWeightFactor);//这个值反映了BentNormal与WorldNormal之间的差异，遮蔽越强差异越大
	}
#else
	{
		SkyVisibility = length(BentNormal);
	}
#endif

	float ContrastCurve = 1 / (1 + exp(-ContrastAndNormalizeMulAdd.x * (SkyVisibility * 10 - 5)));  //基于天光遮蔽强度的一条曲线
	SkyVisibility = saturate(ContrastCurve * ContrastAndNormalizeMulAdd.y + ContrastAndNormalizeMulAdd.z); //将遮蔽强度remap

#if SUPPORT_IRRADIANCE
	DiffuseIrradiance = Texture2DSampleLevel(IrradianceTexture, IrradianceSampler, UV, 0).xyz;
#endif
#endif

	// Apply DFAO controls
	SkyVisibility = pow(SkyVisibility, OcclusionExponent); //SkyVisibility^(0.7)
	SkyVisibility = lerp(SkyVisibility, 1, OcclusionTintAndMinOcclusion.w); //OcclusionTintAndMinOcclusion.w == 0

	// Combine with other AO sources
	if (OcclusionCombineMode == 0)
	{
		// Combine with min which nicely avoids over-occlusion in cases where strong DFAO is present along with strong SSAO (distant trees)
		SkyVisibility = min(SkyVisibility, min(GBuffer.GBufferAO, AmbientOcclusion));
	}
	else
	{
		// Combine with mul, which continues to add SSAO depth even indoors.  SSAO will need to be tweaked to be less strong.
		SkyVisibility = SkyVisibility * min(GBuffer.GBufferAO, AmbientOcclusion);  //Kena采用相乘的方式与其他AO混合
	}

	float ScalarFactors = SkyVisibility;

	BRANCH
	if (GBuffer.ShadingModelID == SHADINGMODELID_TWOSIDED_FOLIAGE)
	{
		float3 SubsurfaceLookup = GetSkySHDiffuse(-GBuffer.WorldNormal) * View.SkyLightColor.rgb; //采样球谐，并染色（天光颜色），注意使用了物体本身法线采样
		float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer); //美术绘制的次表面色
		Lighting += ScalarFactors * SubsurfaceLookup * SubsurfaceColor; //植被(含SSS效果) = 预烘焙的环境光(SH) * 次表面色(美术) * 混合AO强度(BentNormal & SSAO)
	}

	if (GBuffer.ShadingModelID == SHADINGMODELID_SUBSURFACE || GBuffer.ShadingModelID == SHADINGMODELID_PREINTEGRATED_SKIN)
	{
		float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
		// Add subsurface energy to diffuse
		DiffuseColor += SubsurfaceColor;  //对于预积分次表面材质，这里只是将美术绘制的SSS效果输入到DiffuseColor中，后续集中处理
	}

	BRANCH
	if (GBuffer.ShadingModelID == SHADINGMODELID_HAIR)
	{
		float3 N = GBuffer.WorldNormal;
		float3 V = -normalize(mul(float4(ScreenPosition, 1, 0), View.ScreenToWorld).xyz);
		float3 L = normalize(V - N * dot(V, N));  //发根 -> 发梢的方向 
		SkyLightingNormal = L;
		FHairTransmittanceData TransmittanceData = InitHairTransmittanceData();
		bool bEvalMultiScatter = true;
		//正常计算了一边Marschner，与AmbientCubemapComposite中一致，注意头发的计算结果覆盖了DiffuseColor
		DiffuseColor = PI * HairShading(GBuffer, L, V, N, 1, TransmittanceData, 0, 0.2, uint2(0, 0), bEvalMultiScatter); 
	}

	if (GBuffer.ShadingModelID == SHADINGMODELID_CLOTH)
	{
		float3 ClothFuzz = ExtractSubsurfaceColor(GBuffer);
		DiffuseColor += ClothFuzz * GBuffer.CustomData.a; //布料材质 -> 提取SSS颜色，另：a通道含义待考
	}

	// Compute the preconvolved incoming lighting with the bent normal direction
	float3 DiffuseLookup = GetSkySHDiffuse(SkyLightingNormal) * View.SkyLightColor.rgb; //平行光光源的照射方向用于采样SH，所得强度值 * 天光的颜色 -> 推测此SH只记录了强度变化

	// Apply AO to the sky diffuse and account for darkening due to the geometry term
	// apply the Diffuse color to the lighting (including OcclusionTintAndMinOcclusion as it's considered another light, that fixes SubsurfaceProfile being too dark)
	//（混合AO强度）*（BentNormal与WorldNormal的差异度）*（天光的预烘焙强度）-> 对应天光的直接贡献(会受到AO的影响)
	// (1 - SkyVisibility) 部分是为了能量守恒，后面的OcclusionTint对应AO形成的阴影部分的色调
	// 上面的2个部分(完全来自天光)构成了入射光强，再经过 (~) * DiffuseColor 既，使用了材质自身的DiffuseColor做了染色处理
	// 再次强调一下，这部分光照来自天光 -> 只属于GI的一部分
	Lighting += ((ScalarFactors * DotProductFactor) * DiffuseLookup + (1 - SkyVisibility) * OcclusionTintAndMinOcclusion.xyz) * DiffuseColor;

	//环境光漫反射辐照度，一般也是预烘焙的，kena没有这方面数据，得到的 DiffuseIrradiance == 0
	Lighting += DiffuseIrradiance * GBuffer.DiffuseColor * (GBuffer.GBufferAO * AmbientOcclusion);

#if USE_PREEXPOSURE
	Lighting *= View.PreExposure; //预曝光
#endif
	
	// For debugging
#if SUPPORT_IRRADIANCE
	//Lighting = max(Texture2DSampleLevel(IrradianceTexture, IrradianceSampler, UV, 0).xyz, 0) + .01f * GetSkySHDiffuse(InGBufferData.WorldNormal);
#endif

	//Lighting = (Texture2DSampleLevel(BentNormalAOTexture, BentNormalAOSampler, UV, 0).xyz);

	return Lighting;
}

float3 ReflectionEnvironment(FGBufferData GBuffer, float AmbientOcclusion, float2 BufferUV, float2 ScreenPosition, float4 SvPosition, float3 BentNormal, float3 SpecularColor)
{
#if USE_PREEXPOSURE
	const float PreExposure = View.PreExposure;
#else
	const float PreExposure = 1.f;
#endif
	
	float4 Color = float4(0, 0, 0, 1);

	float3 WorldPosition = mul(float4(ScreenPosition * GBuffer.Depth, GBuffer.Depth, 1), View.ScreenToWorld).xyz; //这里的WorldPosition也是有问题的
	float3 CameraToPixel = normalize(WorldPosition - View.WorldCameraOrigin);
	float3 ReflectionVector = reflect(CameraToPixel, GBuffer.WorldNormal); //视方向的反射方向 
	float IndirectIrradiance = GBuffer.IndirectIrradiance; //间接光(环境光)产生的辐照度（入射光的强度）
	
#if ENABLE_SKY_LIGHT && ALLOW_STATIC_LIGHTING
	BRANCH
	// Add in diffuse contribution from dynamic skylights so reflection captures will have something to mix with
	if (ReflectionStruct.SkyLightParameters.y > 0 && ReflectionStruct.SkyLightParameters.z > 0)
	{
		IndirectIrradiance += GetDynamicSkyIndirectIrradiance(BentNormal, GBuffer.WorldNormal); //这里在IndirectIrradiance中加入了SkyLight的光强
	}
#endif

	float3 N = GBuffer.WorldNormal;
	float3 V = -CameraToPixel;

#if GBUFFER_HAS_TANGENT
	ModifyGGXAnisotropicNormalRoughness(GBuffer.WorldTangent, GBuffer.Anisotropy, GBuffer.Roughness, N, V); //带有Tangent信息 -> 用于根据GGXAnisotropic对法线和粗糙度进行调整
#endif

	float3 R = 2 * dot( V, N ) * N - V;	//V的反射方向
	float NoV = saturate( dot( N, V ) );

	// Point lobe in off-specular peak direction
	R = GetOffSpecularPeakReflectionDir(N, R, GBuffer.Roughness); //依据粗糙度调整反射朝向，粗糙->返回N；光滑->返回R

#if 1
	// Note: this texture may also contain planar reflections
	float4 SSR = Texture2DSample(ScreenSpaceReflectionsTexture, ScreenSpaceReflectionsSampler, BufferUV); //采样获取屏幕空间反射，已经计算好存放在了一张RT中了 -> 怀疑是在AmbientCubemapComposite之后进行的
	Color.rgb = SSR.rgb;
	Color.a = 1 - SSR.a;  //TODO:为啥？ -> Composite Alpha
#endif

#if RAY_TRACED_REFLECTIONS
	float4 SavedColor = Color;	// When a clear coat material is encountered, we save the reflection buffer color for it to not be affected by operations.
#endif
	if(GBuffer.ShadingModelID == SHADINGMODELID_CLEAR_COAT )
	{
#if RAY_TRACED_REFLECTIONS
		Color = float4(0, 0, 0, 1); // Clear coat reflection is expected to be computed on a black background
#endif
		const float ClearCoat = GBuffer.CustomData.x;		//清漆强度
		Color = lerp( Color, float4(0,0,0,1), ClearCoat );	//清漆要在纯黑的底上计算

#if CLEAR_COAT_BOTTOM_NORMAL
		const float2 oct1 = ((float2(GBuffer.CustomData.a, GBuffer.CustomData.z) * 2) - (256.0/255.0)) + 
			UnitVectorToOctahedron(GBuffer.WorldNormal);
		const float3 ClearCoatUnderNormal = OctahedronToUnitVector(oct1);

		const float3 BottomEffectiveNormal = ClearCoatUnderNormal;
		R = 2 * dot( V, ClearCoatUnderNormal ) * ClearCoatUnderNormal - V;
#endif
	}

	float AO = GBuffer.GBufferAO * AmbientOcclusion;
	float RoughnessSq = GBuffer.Roughness * GBuffer.Roughness;
	float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO); //环境光高光强度（带有AO遮蔽）
	Color.a *= SpecularOcclusion;

#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
	float2 LocalPosition = SvPosition.xy - View.ViewRectMin.xy;

	uint GridIndex = ComputeLightGridCellIndex(uint2(LocalPosition.x, LocalPosition.y), GBuffer.Depth);
	uint NumCulledEntryIndex = (ForwardLightData.NumGridCells + GridIndex) * NUM_CULLED_LIGHTS_GRID_STRIDE; 
	// NUM_CULLED_LIGHTS_GRID_STRIDE==2 -> "2" 个一组，分别记录 NumCulledReflectionCaptures 和 DataStartIndex 这一成对的数据 
	// ForwardLightData.NumGridCells==12960 -> 27 * 15 * 32 == 12960 -> 屏幕空间拆解成这么多个cell 
	uint NumCulledReflectionCaptures = min(ForwardLightData.NumCulledLightsGrid[NumCulledEntryIndex + 0], 
		ForwardLightData.NumReflectionCaptures);
	// ForwardLightData.NumReflectionCaptures==44 -> 一共有44张IBL纹理 
	uint DataStartIndex = ForwardLightData.NumCulledLightsGrid[NumCulledEntryIndex + 1];
#else
	uint DataStartIndex = 0;
	uint NumCulledReflectionCaptures = 0;
#endif

	//Top of regular reflection or bottom layer of clear coat.
	Color.rgb += PreExposure * GatherRadiance(Color.a, WorldPosition, R, GBuffer.Roughness, BentNormal, 
		IndirectIrradiance, GBuffer.ShadingModelID, NumCulledReflectionCaptures, DataStartIndex);

	BRANCH
	if( GBuffer.ShadingModelID == SHADINGMODELID_CLEAR_COAT)
	{
		const float ClearCoat			= GBuffer.CustomData.x;
		const float ClearCoatRoughness	= GBuffer.CustomData.y;

		// TODO EnvBRDF should have a mask param
		float2 AB = PreIntegratedGF.SampleLevel( PreIntegratedGFSampler, float2( NoV, GBuffer.Roughness ), 0 ).rg;
		Color.rgb *= SpecularColor * AB.x + AB.y * saturate( 50 * SpecularColor.g ) * (1 - ClearCoat);
		
		// F_Schlick
		float F = EnvBRDF( 0.04, ClearCoatRoughness, NoV ).x;
		
		F *= ClearCoat;
			
		float LayerAttenuation = (1 - F);		
		Color.rgb *= LayerAttenuation;
		Color.a = F;
		
#if !RAY_TRACED_REFLECTIONS	
		Color.rgb += SSR.rgb * F;
		Color.a *= 1 - SSR.a;
#endif
			
		Color.a *= SpecularOcclusion;

		float3 TopLayerR = 2 * dot( V, N ) * N - V;
		Color.rgb += PreExposure * GatherRadiance(Color.a, WorldPosition, TopLayerR, ClearCoatRoughness, BentNormal, 
			IndirectIrradiance, GBuffer.ShadingModelID, NumCulledReflectionCaptures, DataStartIndex);

	#if RAY_TRACED_REFLECTIONS
		Color.rgb = SavedColor.rgb +  Color.rgb * SavedColor.a; // Compose default clear coat reflection over regular refelction (using Premultiplied alpha where SaveColor.a=transmittance)
	#endif
	}
	else
	{
		Color.rgb *= EnvBRDF( SpecularColor, GBuffer.Roughness, NoV );
	}

	// Transform NaNs to black, transform negative colors to black.
	return -min(-Color.rgb, 0.0);
}

void ReflectionEnvironmentSkyLighting(
	in float4 SvPosition : SV_Position,
	out float4 OutColor : SV_Target0)
{
	float2 BufferUV = SvPositionToBufferUV(SvPosition); 	//BufferUV 对应 TargetRT的UV
	float2 ScreenPosition = SvPositionToScreenPosition(SvPosition).xy; //注意，该方法作者的注释：doesn't work for usage with View.ScreenToWorld 

	// Sample scene textures.
	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);

	float3 DiffuseColor = GBuffer.DiffuseColor;
	float3 SpecularColor = GBuffer.SpecularColor;
	RemapClearCoatDiffuseAndSpecularColor(GBuffer, ScreenPosition, DiffuseColor, SpecularColor); //ScreenPosition在这里面乘以了View.ScreenToWorld用于求世界坐标，这是错误的

	// Sample the ambient occlusion that is dynamically generated every frame.
	float AmbientOcclusion = AmbientOcclusionTexture.SampleLevel(AmbientOcclusionSampler, BufferUV, 0).r; //获取AO
	
	uint ShadingModelID = GBuffer.ShadingModelID;
	float3 BentNormal = GBuffer.WorldNormal;
	#if APPLY_SKY_SHADOWING
	{
		BentNormal = UpsampleDFAO(BufferUV, GBuffer.Depth, GBuffer.WorldNormal); //双线性插值上采样 -> 获取BentNormal
	}
	#endif
	
	OutColor = 0.0f;

	#if ENABLE_DYNAMIC_SKY_LIGHT
	BRANCH
	// Only light pixels marked as lit
	if (ShadingModelID != SHADINGMODELID_UNLIT)
	{
		//SkyLighting可以理解为室外环境光
		float3 SkyLighting = SkyLightDiffuse(GBuffer, AmbientOcclusion, BufferUV, ScreenPosition, BentNormal, DiffuseColor);

		// Scene color alpha is used for ScreenSpaceSubsurfaceScattering (if that is not needed it can be disabled with SUBSURFACE_CHANNEL_MODE)
		FLightAccumulator LightAccumulator = (FLightAccumulator)0;

		const bool bNeedsSeparateSubsurfaceLightAccumulation = UseSubsurfaceProfile(ShadingModelID);

		LightAccumulator_Add(LightAccumulator, SkyLighting, SkyLighting, 1.0f, bNeedsSeparateSubsurfaceLightAccumulation);
		OutColor = LightAccumulator_GetResult(LightAccumulator);
	}
	#endif

	BRANCH
	if (ShadingModelID != SHADINGMODELID_UNLIT && ShadingModelID != SHADINGMODELID_HAIR) //不是无光照部分或头发材质，那么都会享受到环境光反射探针的光照输入
	{
		OutColor.xyz += ReflectionEnvironment(GBuffer, AmbientOcclusion, BufferUV, ScreenPosition, SvPosition, BentNormal, SpecularColor);
	}
}

