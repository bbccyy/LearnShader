PS
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// TEXCOORD                10   xyzw        0     NONE   float   xyz 
// TEXCOORD                11   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xyzw        2     NONE   float   xy  
// PRIMITIVE_ID             0   x           3     NONE    uint   x   
// SV_Position              0   xyzw        4      POS   float   xyzw
// SV_IsFrontFace           0   x           5    FFACE    uint   x   
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
// SV_Target                1   xyzw        1   TARGET   float   xyzw
// SV_Target                2   xyzw        2   TARGET   float   xyzw
// SV_Target                3   xyzw        3   TARGET   float   xyzw
// SV_Target                4   xyzw        4   TARGET   float   xyzw
// SV_DepthLessEqual        0    N/A oDepthLE  DEPTHLE   float    YES
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[178], immediateIndexed
dcl_constantbuffer CB1[7], immediateIndexed
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_sampler s2, mode_default
dcl_sampler s3, mode_default

dcl_resource_structured t0, 16                          -> Data Buffer 
dcl_resource_texture2d (float,float,float,float) t1     -> Normal Tex rg
dcl_resource_texture2d (float,float,float,float) t2     -> Grass RGBA 
dcl_resource_texture2d (float,float,float,float) t3     -> Noise RGB
dcl_resource_texture2d (float,float,float,float) t4     -> Common Noise R

dcl_input_ps linear centroid v0.xyz         -> NormalWS
dcl_input_ps linear centroid v1.xyzw        -> TangentWS
dcl_input_ps linear v2.xy                   -> UV
dcl_input_ps constant v3.x                  -> PRIMITIVE_ID

dcl_input_ps_siv linear noperspective centroid v4.xyzw, position      -> PosCS 
dcl_input_ps_sgv constant v5.x, is_front_face                         -> VFACE 


dcl_output o0.xyzw        未知 -> 似乎区分了角色本体，树叶和建筑 -> 一种 Mask ?    T:8241 
dcl_output o1.xyzw        可能是 normal  A通道在角色上0.66，在某些其他物件上0.33   T:8220 
dcl_output o2.xyzw        未知 -> 偏蓝 且 w分量设置为 0.694118  T:8241 
dcl_output o3.xyzw        可能是 base color -> 存放了 采样base Color 且经过变换后的颜色  T:8222 
dcl_output o4.xyzw        未知 -> 类似剪影  T:8263 
dcl_output oDepthLE
dcl_temps 8

//获取 BitangentWS -> r0.xyz = Cross(NormalWS，TangentWS) * sign 
mul r0.xyz, v0.yzxy, v1.zxyz
mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx
mul r0.xyz, r0.xyzx, v1.wwww

//准备参数：
//r1.x = Clip_z * Clip_w
//r1.y = 1 
//r1.z = Clip_w
mov r1.x, v4.z
mov r1.y, l(1.000000)
mul r1.xz, r1.xxyx, v4.wwww

//此处通过采样和解码，似乎是为了获得 Bitangent的朝向w 
imad r2.xy, v3.xxxx, l(35, 35, 0, 0), l(4, 20, 0, 0)
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r0.w, r2.x, l(12), t0.xxxx
mul r0.w, r0.w, cb0[140].w
movc r1.w, v5.x, l(1.000000), l(-1.000000)   根据VFACE判断当前像素所在几何体是正面朝向视点还是背面 
mul r0.w, r0.w, r1.w    这里赋值r0.w 而r0.xyz是Bitangent 

//采样法线纹理，解码位于切线空间的法线原始数据 
mul r2.xz, v2.xxyx, cb1[4].xxxx     缩放了UV，随后拿去采样 Normal 纹理（只有RG通道） -> cb1[4].x = [1]
sample_b_indexable(texture2d)(float,float,float,float) r3.xy, r2.xzxx, t1.xyzw, s0, cb0[142].y
mad r3.xy, r3.xyxx, l(2.000000, 2.000000, 0.000000, 0.000000), l(-1.000000, -1.000000, 0.000000, 0.000000)  从[0,1]转[-1,1]区间 
dp2 r1.w, r3.xyxx, r3.xyxx
add r1.w, -r1.w, l(1.000000)
max r1.w, r1.w, l(0.000000)   -> w在 [0,1] 区间
sqrt r3.z, r1.w               -> 到这里从RG通道中解出了第三个通道B
add r4.xyz, -r3.xyzx, l(0.000000, 0.000000, 1.000000, 0.000000)   r4是法线r3的朝向取反 
mad r3.xyz, cb1[4].yyyy, r4.xyzx, r3.xyzx                         法线扰动？   cb1[4].y = [0]
mad r3.xyz, r3.xyzx, cb0[137].wwww, cb0[137].xyzx                 确认是法线扰动！ 
dp3 r1.w, r3.xyzx, r3.xyzx
rsq r1.w, r1.w
mul r3.xyz, r1.wwww, r3.xyzx    归一化 

//应用TBN矩阵将贴图法线转换到世界空间下，随后归一化，调整朝向 
mul r0.xyz, r0.xyzx, r3.yyyy
mad r0.xyz, r3.xxxx, v0.xyzx, r0.xyzx
mad r0.xyz, r3.zzzz, v1.xyzx, r0.xyzx
dp3 r1.w, r0.xyzx, r0.xyzx
rsq r1.w, r1.w
mul r0.xyz, r0.xyzx, r1.wwww    归一化
mul r0.xyz, r0.wwww, r0.xyzx    调整朝向

mul r3.xyz, cb1[1].xyzx, cb1[4].zzzz    ->  r3.xyz = 0

//采样 Grass 纹理，获取基础色 
sample_b_indexable(texture2d)(float,float,float,float) r4.xyz, r2.xzxx, t2.xyzw, s1, cb0[142].y 
mul r4.xyz, r4.xyzx, cb1[3].xyzx    -> 对原始颜色调整  cb1[3].xyz = [0.28,0.23,0.08]  -> 此后称 R4 颜色 
mul r5.xyz, r4.xyzx, cb1[5].yyyy    -> 对调整后的颜色缩放 cb1[5].y = [1]               -> 此后称 R5 颜色 

//设 k = float3(0.577350, 0.577350, 0.577350)
// r1.w = k * dot(R5, k)
dp3 r0.w, l(0.577350, 0.577350, 0.577350, 0.000000), r5.xyzx   
mul r1.w, r0.w, l(0.577350)  

mad r4.xyz, r4.xyzx, cb1[5].yyyy, -r1.wwww    -> 这才是参与色调变换的新颜色 R4，具体说 R4 = R5 - k * dot(R5, k)

mul r5.xyz, r4.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000)
mad r5.xyz, r4.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000), -r5.zxyz      -> R5 = cross(R4, k) 

sincos r6.x, r7.x, cb1[5].x              -> cb1[5].x = [2] 记为角度A  
mul r5.xyz, r5.xyzx, r6.xxxx 
mad r4.xyz, r4.xyzx, r7.xxxx, r5.xyzx    -> R4 = R4 * cosA + cross(R4, k) * sinA 
mad r4.xyz, r0.wwww, l(0.577350, 0.577350, 0.577350, 0.000000), r4.xyzx  -> k * dot(老R5, k) + R4 * cosA + cross(R4, k) * sinA  
//以上操作是：获取Grass的基础色R4，然后依据存储在cb1[5].x内的角度，进行色调变换，返回颜色存入R4 
//参考链接：https://forum.unity.com/threads/hue-saturation-brightness-contrast-shader.260649/ 

//已知 outputCol dot (0.3,0.59,0.11) = ColorIntensity
//以下在求 R4 颜色的 强度 Intensity
dp3 r0.w, r4.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000) 

//得到最终基础色 R4 
add r5.xyz, -r4.xyzx, r0.wwww   -> 设置R5颜色 = 从R4颜色中去掉强度，变成只有色调和饱和度的部分？ 
mad_sat r4.xyz, cb1[5].zzzz, r5.xyzx, r4.xyzx    -> cb1[5].z = 0 -> R4=saturate(R5 * 0 + R4) -> 恢复自定义强度 

//采样 Noise RGB 纹理 -> r0.w 存放噪声的一个维度 
sample_b_indexable(texture2d)(float,float,float,float) r2.xz, r2.xzxx, t3.yxzw, s2, cb0[142].y 
mul_sat r0.w, r2.x, cb1[6].x          -> cb1[6].x = 1  -> r0 存放NoiseTex.x 

//利用posCS构造顶点噪声 -> 存入 r1.w 
add r5.xy, v4.xyxx, -cb0[129].xyxx    -> cb0[129] = 0,0,0,0
add r5.zw, r5.xxxy, cb0[151].xxxx     -> cb0[151] = 0,0,0,0  可以认为r5.xyzw是v4.xyxy，既posCS.xy
ftou r5.zw, r5.zzzw    -> float to unsigned integer 
ishl r1.w, r5.w, l(1)  -> posCS.y << 1
iadd r1.w, r1.w, r5.z  -> posCS.y * 2 + posCS.x 
udiv null, r1.w, r1.w, l(5)   -> (posCS.y * 2 + posCS.x) mod 5 -> 求余数 -> 记为 R1.w
utof r1.w, r1.w 

//采样 Common Noise，uv来自于posCS的变换 -> 采样返回 R 通道的一个数值 
//随机值 -> R1.w -> 本质是基于 posCS 当前点的一顿混淆和采样操作所得 -> 理论上会随着 view 的改变而改变，并不是固定在模型空间上的随机 
mul r5.xy, r5.xyxx, l(0.015625, 0.015625, 0.000000, 0.000000)    -> 0.015625 = 1/64 -> int型 posCS.xy / 64 
sample_b_indexable(texture2d)(float,float,float,float) r2.w, r5.xyxx, t4.yzwx, s3, cb0[142].y
add r1.w, r1.w, r2.w 
mul r1.w, r1.w, cb1[6].y       -> cb1[6].y = 17 
mul r1.w, r1.w, l(0.166667)    -> 0.1667 = 1/6 

//最终丢弃 R1.w，转化为 R1.y -> 某种 Noise 
mad r1.y, r1.y, v4.w, l(-24.000000)   -> r1.y = 1 * Clip.w - 24 
div_sat r1.y, r1.y, cb1[6].z          -> cb1[6].z = -1.51 -> r1.y=(Clip.w - 24) / -1.51 
mad r1.y, r1.y, r1.w, r1.z            -> (Clip.w - 24) / -1.51 * R1.w + Clip.w 
div r1.y, r1.x, r1.y                  -> r1.y = (Clip_z * Clip_w) / ((Clip.w - 24) / -1.51 * R1.w + Clip.w) 
min r1.y, r1.y, v4.z                  -> r1.y 不能大于 Clip_z 


mov_sat r1.w, cb1[5].w 
mov_sat r2.xz, r2.xxzx
mad o2.z, r0.w, cb0[138].y, cb0[138].x
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) o1.w, r2.y, l(4), t0.xxxx
mul r0.w, r1.w, l(0.080000)
mad r5.xyz, -r1.wwww, l(0.080000, 0.080000, 0.080000, 0.000000), r4.xyzx
mad r5.xyz, r2.xxxx, r5.xyzx, r0.wwww
mad r6.xyz, -r4.xyzx, r2.xxxx, r4.xyzx
mad r6.xyz, r6.xyzx, cb0[135].wwww, cb0[135].xyzx
mad r5.xyz, r5.xyzx, cb0[136].wwww, cb0[136].xyzx
ne r0.w, l(0.000000, 0.000000, 0.000000, 0.000000), cb0[177].w
mad r7.xyz, r5.xyzx, l(0.450000, 0.450000, 0.450000, 0.000000), r6.xyzx
movc r6.xyz, r0.wwww, r7.xyzx, r6.xyzx
movc r5.xyz, r0.wwww, l(0,0,0,0), r5.xyzx
dp3 r0.w, r5.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000)
mad r7.xyz, r0.wwww, l(2.040400, -4.795100, 2.755200, 0.000000), l(-0.332400, 0.641700, 0.690300, 0.000000)
mad r0.w, r2.z, r7.x, r7.y
mad r0.w, r0.w, r2.z, r7.z
mul r0.w, r2.z, r0.w
max o3.w, r0.w, r2.z
mad r2.yzw, r5.xxyz, l(0.000000, 0.450000, 0.450000, 0.450000), r6.xxyz
max r3.xyz, r3.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)
lt r0.w, l(0.000000), cb0[139].x
if_nz r0.w
  mul r5.xyzw, v4.yyyy, cb0[45].xyzw    从这里判断，cb0 应该以float4格式打开 
  mad r5.xyzw, v4.xxxx, cb0[44].xyzw, r5.xyzw
  mad r5.xyzw, v4.zzzz, cb0[46].xyzw, r5.xyzw
  add r5.xyzw, r5.xyzw, cb0[47].xyzw
  div r5.xyz, r5.xyzx, r5.wwww
  add r6.xyz, r5.xyzx, -cb0[70].xyzx
  dp3 r0.w, -r5.xyzx, -r5.xyzx
  rsq r0.w, r0.w
  mul r5.xyz, r0.wwww, -r5.xyzx
  mad r0.w, -r1.y, r1.z, r1.x
  div r0.w, r0.w, r1.y
  mad r5.xyz, r5.xyzx, r0.wwww, r6.xyzx
  imad r1.xz, v3.xxxx, l(35, 0, 35, 0), l(5, 0, 19, 0)
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r6.xyz, r1.x, l(0), t0.xyzx
  add r6.xyz, r5.xyzx, -r6.xyzx
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r7.xyz, r1.z, l(0), t0.xyzx
  add r7.xyz, r7.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)
  lt r6.xyz, r7.xyzx, |r6.xyzx|
  or r0.w, r6.y, r6.x
  or r0.w, r6.z, r0.w
  dp3 r1.x, r5.xyzx, l(0.577000, 0.577000, 0.577000, 0.000000)
  mul r1.x, r1.x, l(0.002000)
  frc r1.x, r1.x
  lt r1.x, l(0.500000), r1.x
  movc r5.xyz, r1.xxxx, l(0,1.000000,1.000000,0), l(1.000000,1.000000,0,0)
  movc r3.xyz, r0.wwww, r5.xyzx, r3.xyzx
endif 
mad r2.yzw, cb0[144].yyyy, r2.yyzw, r3.xxyz
mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000)
mul o0.xyz, r2.yzwy, cb0[134].yyyy
mov o0.w, l(0)
mov o2.x, r2.x
mov o2.w, l(0.694118)
mov o2.y, r1.w
mov o3.xyz, r4.xyzx         -> 存放经过Hue shift，并重新调整了Intensity的 BaseColor 
mov o4.xyzw, l(0,0,0,0)
mov oDepthLE, r1.y
ret 
// Approximately 0 instruction slots used
