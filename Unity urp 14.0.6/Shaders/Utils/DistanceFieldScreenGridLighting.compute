// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ConeTraceGlobalOcclusionCS
#pragma kernel DebugCS
#pragma kernel CombineConeVisibilityCS

#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/DistanceFieldAOShared.hlsl"

#ifndef CONE_TRACE_GLOBAL_DISPATCH_SIZEX
#define CONE_TRACE_GLOBAL_DISPATCH_SIZEX 8  //TODO defined in C# 
#endif


//RWTexture2D<float4> _DebugTexture;
RWTexture2D<float4> _DebugTexture3X3;

void ResetBufferData(uint ConeTraceGridIndex)
{
    [unroll]
    for (uint ConeIndex = 0; ConeIndex < NUM_CONE_DIRECTIONS; ConeIndex++)
    {
        RWScreenGridConeVisibility[
            ConeIndex * ScreenGridConeVisibilitySize.x * ScreenGridConeVisibilitySize.y + ConeTraceGridIndex
        ] = 0xFFFFFFFF; 
    }
}

void HemisphereConeTraceGlobalDistanceFieldClipmap(
    uint ClipmapIndex,
    uint ConeTraceGridIndex,
    float3 WorldShadingPosition,
    float SceneDepth,
    float3 WorldNormal,
    float3 Tangent,
    float3 Bitangent)
{
    float MinStepSize = GlobalVolumeCenterAndExtent[ClipmapIndex].w * 2 / 300.0f; 
    float InitialOffset = GetStepOffset(NUM_CONE_STEPS); //0.758 m

    float ConeTraceLeakFill = 1.0f;
#define CONE_TRACE_OBJECTS         //TODO: undefine it 
#ifndef CONE_TRACE_OBJECTS
    InitialOffset = GlobalVolumeCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize * 2.0f;
    {
        float3 WorldSamplePosition = WorldShadingPosition + WorldNormal * InitialOffset;
        float3 StepVolumeUV = ComputeGlobalUV(WorldSamplePosition, ClipmapIndex);
        float DistanceToOccluder = SampleGlobalDistanceField(ClipmapIndex, StepVolumeUV).x;
        ConeTraceLeakFill = saturate(Pow2(DistanceToOccluder / InitialOffset)) * 0.4f + 0.6f;
    }
#endif

    [unroll]
    for (uint ConeIndex = 0; ConeIndex < NUM_CONE_DIRECTIONS; ConeIndex++)
    {
        float3 ConeDirection = AOSamples2_SampleDirections[ConeIndex].xyz;
        float3 ConeDirectionWS = ConeDirection.x * Tangent + ConeDirection.y * Bitangent + ConeDirection.z * WorldNormal; 
        //ConeDirectionWS = WorldNormal; //debug 

        float MinVisibility = 1.0f;
        float WorldStepOffset = InitialOffset;
        
        [loop]
        for (uint StepIndex = 0; StepIndex < NUM_CONE_STEPS && WorldStepOffset < AOGlobalMaxOcclusionDistanceAndInv[0]; StepIndex++)
        {
            //Ray-marching
            float3 WorldSamplePosition = WorldShadingPosition + ConeDirectionWS * WorldStepOffset;
            float3 StepVolumeUV = ComputeGlobalUV(WorldSamplePosition, ClipmapIndex);
            float DistanceToOccluder = SampleGlobalDistanceField(ClipmapIndex, StepVolumeUV).x; 
            float SphereRadius = WorldStepOffset * TanConeHalfAngle;  
            float InvSphereRadius = rcpFast(SphereRadius);  // 1 / SphereRadius

            float Visibility = saturate(DistanceToOccluder * InvSphereRadius);

            float OccluderDistanceFraction = (WorldStepOffset + DistanceToOccluder) * AOGlobalMaxOcclusionDistanceAndInv[1];

            Visibility = max(Visibility, saturate(OccluderDistanceFraction * OccluderDistanceFraction * 0.6f));

            MinVisibility = min(MinVisibility, Visibility);

            WorldStepOffset += max(DistanceToOccluder, MinStepSize); //accelerate computation of simple case by applying DistanceToOccluder here 
        }

        MinVisibility *= ConeTraceLeakFill;

        InterlockedMin(
            RWScreenGridConeVisibility[
                ConeIndex * ScreenGridConeVisibilitySize.x * ScreenGridConeVisibilitySize.y + ConeTraceGridIndex
            ], 
            asuint(MinVisibility) 
                    );

        //if (ConeIndex == 0)
        //{
        //    uint2 coord = GridIndexToCoordination(ConeTraceGridIndex);
        //    _DebugTexture[coord] = float4(MinVisibility.xxxx);   //TODO: remove
        //}
    }
}


void HemisphereConeTraceGlobalDistanceField(
    uint GridIndex, float3 WorldShadingPosition, float SceneDepth,
    float3 WorldNormal, float3 Tangent, float3 Bitangent)
{
    float DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeCenterAndExtent[0].xyz, GlobalVolumeCenterAndExtent[0].www, WorldShadingPosition);

    //2 LOD vs UE's 4 LOD 
    [branch]
    if (DistanceFromClipmap > AOGlobalMaxOcclusionDistanceAndInv[0])
    {
        HemisphereConeTraceGlobalDistanceFieldClipmap((uint)0, GridIndex, WorldShadingPosition, SceneDepth, WorldNormal, Tangent, Bitangent);
    }
    else
    {
        HemisphereConeTraceGlobalDistanceFieldClipmap((uint)1, GridIndex, WorldShadingPosition, SceneDepth, WorldNormal, Tangent, Bitangent);
    }
}


[numthreads(CONE_TRACE_GLOBAL_DISPATCH_SIZEX, CONE_TRACE_GLOBAL_DISPATCH_SIZEX, 1)] 
void ConeTraceGlobalOcclusionCS(
    uint3 GroupId : SV_GroupID,
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID)
{
    uint2 DstCoordinate = DispatchThreadId.xy;  //refs to dest RT's tex coordinate 

    if (all(DstCoordinate < ScreenGridConeVisibilitySize))
    {
        float2 BaseLevelScreenUV = GetBaseLevelScreenUVFromScreenGrid(DstCoordinate); //get uv based on half res=[854,480] and Jitterring 

        float3 NormalWS;
        float DeviceZDepth;
        GetNormalDepthGBuffer(BaseLevelScreenUV, NormalWS, DeviceZDepth);

        uint ConeTracingGridIndex = DstCoordinate.y * ScreenGridConeVisibilitySize.x + DstCoordinate.x;

        ResetBufferData(ConeTracingGridIndex);

        if (DeviceZDepth > 0)  //TODO: use clip?
        {
            float3 TangentX;
            float3 TangentY;
            FindTangentXY(NormalWS, TangentX, TangentY);

            float2 ScreenUV = GetFullResUVFromBufferGrid(DstCoordinate);

            float3 WorldShadingPosition = ComputeWorldSpacePosition(ScreenUV, DeviceZDepth, UNITY_MATRIX_I_VP);
            float SceneDepth = LinearEyeDepth(DeviceZDepth, _ZBufferParams); //ViewSpace.Z 

            HemisphereConeTraceGlobalDistanceField(
                ConeTracingGridIndex, WorldShadingPosition, SceneDepth,
                NormalWS, TangentX, TangentY);
        }
    }
}


[numthreads(CONE_TRACE_GLOBAL_DISPATCH_SIZEX, CONE_TRACE_GLOBAL_DISPATCH_SIZEX, 1)]
void DebugCS(
    uint3 GroupId : SV_GroupID,
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID)
{
    uint2 DstCoordinate = DispatchThreadId.xy;  //refs to dest RT's tex coordinate 

    if (all(DstCoordinate < ScreenGridConeVisibilitySize))
    {
        uint ConeTracingGridIndex = DstCoordinate.y * ScreenGridConeVisibilitySize.x + DstCoordinate.x;

        [unroll]
        for (uint ConeIndex = 0; ConeIndex < NUM_CONE_DIRECTIONS; ConeIndex++)
        {
            uint raw = RWScreenGridConeVisibility[
                ConeIndex * ScreenGridConeVisibilitySize.x * ScreenGridConeVisibilitySize.y + ConeTracingGridIndex];
            float visibility = asfloat(raw);
            uint row = ConeIndex % 3;
            uint col = ConeIndex / 3;
            uint2 coord = uint2(row, col) * ScreenGridConeVisibilitySize.xy + DstCoordinate;
            _DebugTexture3X3[coord] = visibility.xxxx;
        }
    }
}


[numthreads(CONE_TRACE_GLOBAL_DISPATCH_SIZEX, CONE_TRACE_GLOBAL_DISPATCH_SIZEX, 1)]
void CombineConeVisibilityCS(
    uint3 GroupId : SV_GroupID,
    uint3 DispatchThreadId : SV_DispatchThreadID,
    uint3 GroupThreadId : SV_GroupThreadID)
{
    uint2 SrcCoordinate = min(DispatchThreadId.xy, ScreenGridConeVisibilitySize);
    uint2 DstCoordinate = DispatchThreadId.xy;

    if (all(DstCoordinate < ScreenGridConeVisibilitySize))
    {
        float2 BaseLevelScreenUV = GetBaseLevelScreenUVFromScreenGrid(SrcCoordinate);

        float3 WorldNormal;
        float DeviceZ;
        GetNormalDepthGBuffer(BaseLevelScreenUV, WorldNormal, DeviceZ);

        if (DeviceZ > 0)
        {
            float3 Tangent;
            float3 Bitangent;
            FindTangentXY(WorldNormal, Tangent, Bitangent);

            uint SrcBaseIndex = SrcCoordinate.y * ScreenGridConeVisibilitySize.x + SrcCoordinate.x;

            float3 UnoccludedDirection = 0;

            [unroll]
            for (uint ConeIndex = 0; ConeIndex < NUM_CONE_DIRECTIONS; ConeIndex++)
            {
                float ConeVisibility = asfloat(RWScreenGridConeVisibility[
                    ConeIndex * ScreenGridConeVisibilitySize.x * ScreenGridConeVisibilitySize.y + SrcBaseIndex]);

                float3 ConeDirection = AOSamples2_SampleDirections[ConeIndex].xyz;
                float3 ConeDirectionWS = ConeDirection.x * Tangent + ConeDirection.y * Bitangent + ConeDirection.z * WorldNormal;

                UnoccludedDirection += ConeVisibility * ConeDirectionWS;
            }

            float InvNumSamples = 1.0f / (float)NUM_CONE_DIRECTIONS;
            float3 BentNormal = UnoccludedDirection * BentNormalNormalizeFactor * InvNumSamples;

            RWCombinedDFBentNormal[DstCoordinate] = float4(BentNormal, DeviceZ);
        }
        else
        {
            RWCombinedDFBentNormal[DstCoordinate] = float4(0,0,0,0);
        }
    }
}





// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
