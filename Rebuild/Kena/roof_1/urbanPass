Forward+ -> TODO -> could replace Deffered pass 
Class based rendering -> Tile based rendering 
TODO -> 看材质名 
以下内容来自：DC=2183   ->  关注输出 Tex 8264 
本DC主要负责 GI 效果 -> 不处理直接光照 
备注1：对于DC=2181   ->  Tex 8269  ->  可能是上一帧的输出 
备注2：SSAO 的DC = 2091 -> 输出到 Tex 8232 上 -> 再通过DC=2903 输出到 单通道的 Tex 6681 上

//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Position              0   xyzw        0      POS   float   xy w
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[10], immediateIndexed
dcl_constantbuffer CB1[201], immediateIndexed
dcl_constantbuffer CB2[1], immediateIndexed
dcl_constantbuffer CB3[4], immediateIndexed
dcl_constantbuffer CB4[1023], dynamicIndexed
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_sampler s2, mode_default
dcl_sampler s3, mode_default
dcl_sampler s4, mode_default
dcl_sampler s5, mode_default
dcl_sampler s6, mode_default
dcl_sampler s7, mode_default
dcl_resource_texturecube (float,float,float,float) t0 			-> 天空 
dcl_resource_texturecube (float,float,float,float) t1 			-> cubemap 几乎全黑 
dcl_resource_texturecubearray (float,float,float,float) t2 	-> 确认是 IBL 探针，有 57 张 
dcl_resource_buffer (uint,uint,uint,uint) t3  					    -> 似乎是一张映射表 
dcl_resource_buffer (uint,uint,uint,uint) t4 
dcl_resource_texture2d (float,float,float,float) t5				-> BRDF LUT 
dcl_resource_texture2d (float,float,float,float) t6 			-> [NormalWS.xyz, DepthWS] 看起来像被模糊过，且分辨率减半 
																	                             -> 后续可能关联计算: Motion Blur;  Depth of Field; ... 
dcl_resource_texture2d (float,float,float,float) t7 			-> Depth01 (R通道) 
dcl_resource_texture2d (float,float,float,float) t8 			-> [NormalWS.xyz, 0.333(?当前pass没有使用)] 
dcl_resource_texture2d (float,float,float,float) t9 			-> [PurpleRGB.y(Rough1), 0.2(Intensity), P.y偏移值(用作Flag), 0.694118(Rough2)] 
																	                             -> Rough2用于采样LUT 
dcl_resource_texture2d (float,float,float,float) t10 			-> [去除强度的BaseColor.rgb, 随机化处理的PurpleRGB.z(AO)] 
dcl_resource_texture2d (float,float,float,float) t11   		-> 似乎区分了角色+衣服+树叶, 其他为黑 -> 动态vs静态? 
																	                             -> [Frsnel_Flag, Rough_3(用于采样LUT), ?, ? ] 
																	                             -> 是否与sss有关? 
																	                             -> X 通道似乎是控制 Fresnel 效果用, Y被当做粗糙度来使用, 
dcl_resource_texture2d (float,float,float,float) t12 			-> 似乎是自发光或高光相关的值 -> 4通道 
dcl_resource_texture2d (float,float,float,float) t13 			-> AO (R通道) -> SSAO Pass 获取 

dcl_input_ps_siv linear noperspective v0.xyw, position 		-> 全屏Blit对应的 VertexInputPS 
dcl_output o0.xyzw 												                -> 输出纹理 T:8264 
dcl_temps 20 


mul r0.xy, v0.xyxx, cb1[131].zwzz  		屏幕像素序号xy * 像素倒数  ->  用于采样贴图的屏幕 UV 

//r1.xy -> 经过如下变换后，r1.xy 介于 ScreenSpace & ClipSpace 之间... 
//注意 v0.w 对应全屏 Blit 使用的三角形面片的视深度 
add r0.zw, v0.xxxy, -cb1[129].xxxy                              -> cb1[129].xy = 0 		-> v0.xy 是屏幕像素索引(+0.5) 
mad r1.xy, r0.zwzz,  [130].zwzz, l(-0.5, -0.5, 0.0, 0.0) 		    -> v0.xy / [height, width] - [0.5, 0.5] -> [-0.5, +0.5]区间UV 
mul r1.xy, r1.xyxx, v0.wwww    	                                -> [-0.5, +0.5] * v0.w 	-> v0.w = Clip.w 
mul r1.xy, r1.xyxx, l(2.000000, -2.000000, 0.000000, 0.000000)  -> [-1.0, +1.0] * v0.w -> 上下翻转 -> 预乘"三角面片深度"的半成品 

sample_l_indexable(texture2d)(float,float,float,float) r2.xyz, r0.xyxx, t8.xyzw, s0, l(0.000000) 	  -> Normal, 0.33 
sample_l_indexable(texture2d)(float,float,float,float) r3.xyzw, r0.xyxx, t9.xywz, s0, l(0.000000) 	-> rough1, 0.2, Flag, 0.69(rough2) 
sample_l_indexable(texture2d)(float,float,float,float) r4.xyzw, r0.xyxx, t10.xyzw, s0, l(0.000000) 	-> BaseColor.rgb, P.z(AO) 
sample_l_indexable(texture2d)(float,float,float,float) r5.xyzw, r0.xyxx, t11.xyzw, s0, l(0.000000)  -> 0,0,0,0 
sample_l_indexable(texture2d)(float,float,float,float) r1.z, r0.xyxx, t7.yzxw, s0, l(0.000000)    	-> 深度 R1.Z 

//Decode Depth 
//R1.z 应该是趋向 Clip.w' 的数值，基本上取值大于 100, 既大于1米 
//注意: UE4 默认距离单位 = 厘米 
mad r1.w, r1.z, cb1[65].x, cb1[65].y   								 -> 0 
mad r1.z, r1.z, cb1[65].z, -cb1[65].w  								 -> 0.1 * depthRaw 
div r1.z, l(1,1,1,1), r1.z 			                       -> 1/(0.1*depthRaw) 
add r1.z, r1.z, r1.w 												           -> 1/(0.1*depthRaw) + (depthRaw*a+b) 

mul r6.xy, r0.xyxx, cb1[131].xyxx 
ftou r6.xy, r6.xyxx 			  -> 当前像素坐标索引 

//Condition: 某种 2x2 块状像素分割逻辑 
ftou r1.w, cb1[151].x 			-> 1 
iadd r2.w, r6.y, r6.x 			-> x + y 
iadd r1.w, r1.w, r2.w 			-> x + y + 1 
and r1.w, r1.w, l(1)        -> 判断奇偶?  ->  某种棋盘状分割逻辑 

//法线 
mad r2.xyz, r2.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), l(-1.000000, -1.000000, -1.000000, 0.000000) 
dp3 r2.w, r2.xyzx, r2.xyzx
rsq r2.w, r2.w
mul r6.xyz, r2.wwww, r2.xyzx   -> R6 

//r3.zy = [Purple.y修改值, T9.y(0.007/0.14/0.2/0.49 ~ 0.607)] 
//利用采样 T9 纹理的 Z 通道，获取当前urbanPass分支逻辑控制符 
//利用采样 T9 纹理的 Y 通道，计算环境光底色 
mul r7.xy, r3.zyzz, l(255.000000, 0.080000, 0, 0)  	-> 255用于将8bit通道转换到整数范围，0.08推测是环境光缩放因子 
round_ne r6.w, r7.x     						                -> 四舍五入到整数float值 ->  颜色[0~255] 
ftou r6.w, r6.w 
and r7.xz, r6.wwww, l(15, 0, 16, 0)   			        -> (Z= r6.w & 10000) -> 筛选出第五bit位=0或1的值； (X= r6.w & 1111) -> 返回:[0~15] 
movc r5.xyzw, r7.zzzz, l(0,0,0,0), r5.xyzw  	      -> 依据倒数第5个bit符号位, 判断是否要启用 T11 纹理的数据 
ieq r8.xyz, r7.xxxx, l(9, 5, 4, 0)    			        -> Condition: r7.x 返回值是否落在给定区间 
movc r6.w, r8.x, l(0), r3.x    					            -> r3.x=rough1 -> 若为9号材质则为0, 除此之外是材质自有 rough1 (roof和腰带,头发,裤有值) 
mad r9.xyz, -r3.yyyy, l(0.08, 0.08, 0.08, 0), r4.xyzx  		-> BaseCol.rgb - T9.y * 0.08 
mad r9.xyz, r6.wwww, r9.xyzx, r7.yyyy   		        -> (BaseCol.rgb - T9.y * 0.08) * [0 or rough1] + T9.y * 0.08 
												                            -> R9 颜色似乎是环境光底色 

or r7.y, r8.x, r8.y 							      -> Condition: 比 r8 单个通道几率更高 -> 是 9号 或 5号 材质渲染方案的话 
lt r7.z, l(0.000000), cb1[155].x 				-> 0 < 1 ? true 
lt r7.w, l(0.000000), cb1[200].z  			-> 0 < 1 ? true  -> 这2个开关负责什么? TODO 
and r7.z, r7.w, r7.z 							      -> 同时满足上面2个开关 -> 才OK 
ne r7.w, l(0, 0, 0, 0), cb1[155].x  	  -> true  
movc r8.xyw, r7.wwww, l(1,1,0,1), r4.xyxz		-> r8.xyw = BaseCol.rgb 

//构建了 R10 颜色/遮罩 -> TODO 
movc r10.xy, r1.wwww, l(1,0,0,0), l(0,1,0,0) 	-> 根据间隔的像素进行选择和分割 -> r10.xy = [1,0] or [0,1] -> 间隔Mask 
mul r11.xyz, r9.xyzx, r10.yyyy 					      -> R11 颜色 -> R9 颜色 * 间隔的Mask.y  -> 可颜色 可0 
mul r11.w, r3.y, r10.y 		 					          -> T9.y * [1 or 0] -> T9.y * 方块Mask.y 
movc r10.xyz, r7.zzzz, r10.xxxx, r8.xywx 		  -> R10 颜色 -> 要么是 方块Mask.x 既[0 or 1] (√)，要么 BaseCol.rgb 
mov r9.w, r3.y 
movc r11.xyzw, r7.zzzz, r11.xyzw, r9.xyzw 		-> R11 颜色 <- [R9颜色*方块Mask.y] (√) 还是 [R9颜色.rgb, 0.2] 
mov r10.w, r11.w 								              -> R10 颜色透明通道 = 0.2 * 方块Mask.y -> rgba = [0,0,0,0.2] or [1,1,1,0] 
mov r12.xyz, r4.xyzx 							            -> R12 颜色 = BaseCol.rgb 
mov r12.w, r9.w 								              -> R12 颜色.Alpha = R11.w = r3.y = T9.y ~ 0.2 
movc r10.xyzw, r7.yyyy, r10.xyzw, r12.xyzw 		-> 新 R10 = 概率选 R10 或 R12=[BaseCol.rgb, 0.2] -> 是9号或5号方案就选10 

//重构世界坐标 
//先通过 [-1, +1] * Clip.w * View.z 计算出 Clip Space 下当前点xy，随后结合采样深度z重建世界空间坐标 
//注意1: 矩阵运算的目标向量处在Clip Space中，所以变换矩阵理应是 Inv_VP，且UE4的P矩阵只修改了XY分量(最后一列为[0,0,1,0])，保留Z分量不动 
//注意2: r1.xy 一直保持在 [-1, +1] * Clip.w 状态 
mul r4.xy, r1.zzzz, r1.xyxx 				    -> R4.xy -> ClipSpace.xy -> [-1, +1] * (Clip.w * View.z) 
mul r8.xyw, r4.yyyy, cb1[49].xyxz 			-> cb1[49] ~ cb1[50] -> Matrix_Inv_VP -> 将物体从裁剪空间转回世界空间的矩阵 
mad r4.xyz, r4.xxxx, cb1[48].xyzx, r8.xywx 
mad r4.xyz, r1.zzzz, cb1[50].xyzx, r4.xyzx 
add r4.xyz, r4.xyzx, cb1[51].xyzx 			-> 最后一列存有: 'CameraPosWS' 
											                  -> toCameraVector= (inverse(viewMatrix)*vec4(0,0,0,1.0)).xyz-worldPosition.xyz; 

//-ViewDirWS -> R8 -> From Camera To ViewPoint 
add r8.xyw, r4.xyxz, -cb1[67].xyxz    	-> 摄像机的世界空间坐标[-58890, 27509, -6150] 
dp3 r1.w, r8.xywx, r8.xywx 
rsq r1.w, r1.w 
mul r8.xyw, r1.wwww, r8.xyxw 				    -> 归一化 


//计算不同材质的参数 R7.Z 和 R9.W：基于NdotV，掠视时值小， 俯视时值大 
//参数用于表现GI下物体表面漫反射强度 -> Diffuse部分 -> 一般基于 NdotV 
dp3 r1.w, r6.xyzx, -r8.xywx  					        -> NdotV -> Normal 和 ViewDir 都是单位向量，所有点乘后得到 cosθ 
mov_sat r3.x, r1.w   							            -> saturate(NdotV) = NdotV -> 做sat似乎没必要 
mad r7.z, r3.x, l(0.500000), l(0.500000)    	-> NdotV * 0.5 + 0.5 
mad r7.z, r7.z, r3.x, l(-1.000000) 				    -> (NdotV * 0.5 + 0.5) * NdotV - 1  -> 若(V ⊥ N) 得-1，反之得0 
mad_sat r7.w, -r3.w, l(1.250000), l(1.250000)	-> saturate(1.25 - 1.25*[t9.w=0.69]) -> 不同材质不同缩放比例 
mul r9.w, r7.w, r7.z 							            -> saturate(1.25 - 1.25*[t9.w=0.69]) * ((NdotV*0.5+0.5)*NdotV-1) -> [-1, 0]区间 ；
mad r7.z, r7.z, r7.w, l(1.000000) 				    -> 类似 R9.w -> 转换到 [0, 1] 区间，垂直得0，同向得1 

//将 R10 颜色 与 NdotV 以某种形式混淆 
//基于R10颜色生成的 -> R13 属于 [0.15, 1.01]区间; R12 属于 [0, 1.11]区间 
//另外，(col^2 - col)*t + col -> 这种模式的颜色操作等效于对原始颜色进行 "非线性提亮" 
//中间变量 R13 特性: 当垂直看时三通道都为1，掠射时各通道按比例衰减一定幅度 
//输出 R12 颜色 按照视角的大小，表现出由暗到明(原始色)的过渡 
mul r12.xyz, r10.xyzx, l(1.111111, 1.111111, 1.111111, 0.000000)  				-> R12 颜色 = R10 颜色 * 1.11 -> "线性提亮" 
add r7.w, r3.x, l(-1.000000) 													                    -> NdotV - 1 
mul r7.w, r7.w, l(0.850000) 													                    -> 0.85 * (NdotV - 1) -> [-0.85, 0]区间 
mad r13.xyz, r12.xyzx, r12.xyzx, -r12.xyzx 						                    -> (R12)^2 - R12 -> [-0.25, 0.1221]区间 
mad r13.xyz, r13.xyzx, l(-0.780000, -0.780000, -0.780000, 0.000000), r12.xyzx   -> R12-0.78*[(R12)^2 - R12] -> [0, 1.01]区间 
add r13.xyz, -r13.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000) 				-> 1-{R12-0.78*[(R12)^2 - R12]}->[-0.01, 1]区间 
mad r13.xyz, r7.wwww, r13.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000) -> R13=0.85*(NdotV-1)*{1+0.78*[(R12)^2 - R12]-R12} + 1 
mul r12.xyz, r12.xyzx, r13.xyzx 												                  -> R12 颜色 = R12 * R13 

//r5.x 来自 T11，既纹理11 (叶子+人物有颜色，其他为黑的纹理)，似乎用来控制(开关) 菲尼尔效果的Flag 
//如下的 r12.w 构成了 Shilick Fresnel 的核心元素: (1 - cosθ)^5, 而 r7.w 关联 Fresnel_Term (可通过函数曲线验证) 
//r7.z 与 r7.w 相比，随着视角倾斜，数值下降趋势比较缓和 
//对于屋顶和木墙而言，输出颜色 R12 任然只是趋向 R10 
//而树叶之类，其输出颜色 R12 受到Fresnel影响比较大 
add r7.w, -r3.x, l(1.000000)  				  -> 1 - NdotV -> [0, 1] 
mul r11.w, r7.w, r7.w 						      -> (1 - NdotV)^2 
mul r11.w, r11.w, r11.w 					      -> (1 - NdotV)^4 
mul r12.w, r7.w, r11.w 						      -> R12.w = (1 - NdotV)^5 
mad r7.w, -r11.w, r7.w, l(1.000000)  		-> 1 - (1 - NdotV)^5 
mad r7.w, r7.w, l(0.040000), r12.w  		-> 0.04 * [1 - (1 - NdotV)^5] + (1 - NdotV)^5 -> Fresnel_Term 
mad r7.w, r5.x, -r7.w, l(1.000000) 			-> 1 - Fresnel_Term * r5.x -> 如果r5.x为控制开启阀门，整体返回值是与1的互补数 
mul r13.xyz, r7.wwww, r10.xyzx 				  -> R13 = R10颜色 * (1 - Fresnel_Term) -> 如果开启，掠视时R10会被压制 
mul r12.xyz, r7.zzzz, r12.xyzx 				  -> R12颜色 * [NoV关联项，比原始NoV亮]  
mul r7.z, r5.x, r6.w 						        -> r7.z = T11.x(非0既1的Fresnel关联项) * [0 or Purple.y(rough1)]  -> 开启条件:开启了F项，同时不是类型9的材质 
mad r12.xyz, r12.xyzx, l(0.90, 0.90, 0.90, 0.0), -r13.xyzx  -> R12 = 0.9 * R12颜色 - R13颜色 -> 用减号形成Fresnel现象 
mad r12.xyz, r7.zzzz, r12.xyzx, r13.xyzx 	-> R12 = r7.z * R12 + R13 -> 屋顶材质应当使用的是 R13颜色  -> lerp

//采样 AO -> R7.z  
sample_l_indexable(texture2d)(float,float,float,float) r7.z, r0.xyxx, t13.yzxw, s7, l(0.000000) 

//求半分辨率下的 UV 
mad r13.xy, -cb1[129].xyxx, cb1[131].zwzz, r0.xyxx 						-> 屏幕UV - 0 * (屏幕长宽的倒数) -> UV 偏移 
min r13.xy, r13.xyxx, cb0[6].xyxx 										        -> 不能超过 0.998 -> 确保在像素中点位置? 
mul r13.zw, cb1[131].xxxy, l(0, 0, 0.500000, 0.500000) 	      -> 求 "半" 屏幕的长宽 
round_ni r13.zw, r13.zzzw  												            -> floor("半"屏幕的长宽) 
div r14.xy, l(1,1,1,1), r13.zwzz 		                          -> "半"屏幕的长宽 の 倒数 
mad r15.xy, r13.xyxx, r13.zwzz, l(-0.5, -0.5, 0, 0) -> 正常屏幕UV * "半"屏幕的长宽 - 0.5 -> '大'像素位置, 注意可能移到左/下邻'大'像素  
round_ni r15.xy, r15.xyxx 												            -> floor("半"屏幕下的像素位置) , 最小为 0 
div r15.xy, r15.xyxx, r13.zwzz 											          -> 新UV, 采样率相对原始UV减半，位置在田字格的左下角(真角落)  
mad r15.xy, r14.xyxx, l(0.500000, 0.500000, 0, 0), r15.xyxx   -> 增加1小像素偏移 -> 让当前降采样UV对准田字格正中心 
add r13.xy, r13.xyxx, -r15.xyxx   				                    -> 正常采样的当前点UV - 半分辨率UV = UV_delta -> 田的中心点到实际当前像素距离 
mul r15.zw, r13.zzzw, r13.xxxy					                      -> 半分辨率下 UV_delta 占用了(0.25或0.75)个大像素点长度 

//采样 T6 (疑似NormalWS纹理, 本身分辨率为原始值的一半) 
//采样了田字四邻域，分布存放在 R16,R17,R18和R14中 
//注意，降分辨率下的一个田字的每个口，都代表正常分辨率下的一个田 -> 采样覆盖正常分辨率下16邻域 
sample_l_indexable(texture2d)(float,float,float,float) r16.xyzw, r15.xyxx, t6.xyzw, s5, l(0.000000) 
mov r14.z, l(0)  						                               -> r14.xyz = ["半"屏幕的长宽の倒数, 0]; r15.xy = [降采样后当前点UV] 
add r17.xyzw, r14.xzzy, r15.xyxy		                       -> r17.xyzw = [降采样后U + 1, 降采样后V, 降采样后U, 降采样后V + 1] 
sample_l_indexable(texture2d)(float,float,float,float) r18.xyzw, r17.xyxx, t6.xyzw, s5, l(0.000000) 
sample_l_indexable(texture2d)(float,float,float,float) r17.xyzw, r17.zwzz, t6.xyzw, s5, l(0.000000) 
add r14.xy, r14.xyxx, r15.xyxx    		                     -> r14.xy = [UV + 一个像素] 
sample_l_indexable(texture2d)(float,float,float,float) r14.xyzw, r14.xyxx, t6.xyzw, s5, l(0.000000) 

//这里从T6纹理(半分辨率) W 通道获取 Depth_1，拿来和(全分辨率下)深度图的 Depth_2 求差异 
//最后基于当前像素在田字格位置，加权求和 Diff_Depth，存入 R7.w 
// r13 = [UV_delta, "半"屏幕的长宽] 
mad r13.xy, -r13.yxyy, r13.wzww, l(1,1,0,0)	  -> (1 - 大像素_delta).yx 
mul r19.x, r13.y, r13.x  				              -> r19.x = [当前点在田字左下格时: 1], [右上: 0.25], [其他: 0.5]  ? 
mul r19.yz, r15.zzwz, r13.xxyx 			          -> 大像素_delta.xy * (1 - 大像素_delta).yx  -> 可以区分 ↑，→，↗和本身共4中情况 ? 
mul r19.w, r15.z, r15.w 				              -> 区分是否是 右上 格子 -> [右上: 0.25], [其他: 0] ? 
mov r13.x, r16.w 						                  -> R13 = [左下, 上，右, 右上].(看起来像距离参数，数值普遍大于100，天空在65530附近) 
mov r13.y, r18.w
mov r13.z, r17.w
mov r13.w, r14.w
add r13.xyzw, -r1.zzzz, r13.xyzw 		-> R13 = 田字4个位置的: T6纹理存的Depth - 当前帧深度纹理解码的Depth 
add r13.xyzw, |r13.xyzw|, l(0.000100, 0.000100, 0.000100, 0.000100) 	-> 给 Diff_Depth 加上一个很小的正数，确保都大于0 
div r13.xyzw, l(1.000000, 1.000000, 1.000000, 1.000000), r13.xyzw 		-> Diff_Depth の 倒数 
mul r13.xyzw, r13.xyzw, r19.xyzw 										                  -> 基于当前像素在田字格中位置，修正4个 (1/D_Depth) 
dp4 r7.w, r13.xyzw, l(1.000000, 1.000000, 1.000000, 1.000000) 			  -> 求和田字格区域的这 4个 (1/D_Depth) 
div r7.w, l(1.000000, 1.000000, 1.000000, 1.000000), r7.w 				    -> 相当于求解了4个 Diff_Depth 的加权平均 -> 与深度值相关 

mul r15.xyz, r18.xyzx, r13.yyyy 			       	-> 对应田字位置的 (1/D_Depth) * 对应位置的采样结果.xyz 
mad r15.xyz, r13.xxxx, r16.xyzx, r15.xyzx 		-> 4个位置的结果累加起来 -> R13 
mad r13.xyz, r13.zzzz, r17.xyzx, r15.xyzx 
mad r13.xyz, r13.wwww, r14.xyzx, r13.xyzx 

add r11.w, -r1.z, cb0[2].w 						        -> 20000 - 当前帧深度纹理解码的Depth 
mul_sat r11.w, r11.w, cb0[3].x 					      -> saturate((20000-Depth)/6000) -> 用于Scale，距离近:1，距离远:0 
mov r14.xyz, -r6.xyzx 							          -> R14 = -Normal 
mad r13.xyz, r13.xyzx, r7.wwww, r14.xyzx 		  -> (田字4方向独自通过(1/D_Depth)累加后 * D_Depth加权平均).xyz + (-Normal) 
mad r13.xyz, r11.wwww, r13.xyzx, r6.xyzx 		  -> R13 = Scale * 从原Norm顶点指向新Norm顶点的向量(正向扰动矢量) + 原Normal向量 


if_nz r7.x  	-> 大概率能进，除非 [Purple.y修改值] * 255 的后4个bit位全是 0 
  mad r15.xyz, -r10.xyzx, r6.wwww, r10.xyzx 				      -> R10颜色 - R10颜色 * Purple.y 
  mad r15.xyz, r15.xyzx, cb1[135].wwww, cb1[135].xyzx  		-> 上面的颜色 * 1 + 0 
  mad r16.xyz, -r12.xyzx, r6.wwww, r12.xyzx 				      -> R12颜色 - R12颜色 * Purple.y 
  movc r15.xyz, r8.zzzz, r16.xyzx, r15.xyzx 				      -> Condition 如果是 4号 材质方案的话，使用R16颜色，不然就用R15 

  dp3 r7.w, r13.xyzx, r13.xyzx  							            -> 归一化 R13 扰动法线向量 -> R16 -> 定义为RandomNorm 或 (Rn) 
  sqrt r7.w, r7.w
  max r11.w, r7.w, l(0.000010)
  div r16.xyz, r13.xyzx, r11.wwww

  //计算标量r11.w -> 无扰动时=1, 强扰动时=扰动向量模长 
  mad r17.xyz, r2.xyzx, r2.wwww, -r16.xyzx  				-> 法向量 - 扰动法线向量 = 反向扰动矢量 
  mad r17.xyz, r7.wwww, r17.xyzx, r16.xyzx 					-> 按Rn的模长放大 '反向扰动矢量' 
  dp3 r11.w, r16.xyzx, r6.xyzx 								      -> Dot(扰动法线向量, NormalWS) -> NdotRn 
  add r12.w, -r11.w, l(1.000000) 
  mad r11.w, r7.w, r12.w, r11.w  							      -> lerp(NdotRn, 1, 扰动向量模长)

  //求取 AO_final -> r7.w
  mad r7.w, r7.w, l(10.000000), l(-5.000000)   			-> 扰动向量模长 * 10 - 5 
  mul r7.w, r7.w, -cb0[8].x 								        -> (扰动向量模长 * 10 - 5) * (-0.01) 
  mul r7.w, r7.w, l(1.442695) 								      -> -1.442695 * (10*模长 - 5) / 100 -> Log2E = 1.442695 
  exp r7.w, r7.w 											              -> exp((5 - 10*模长) / 100) 	-> 这里假设 exp 实际上是 exp2 
  add r7.w, r7.w, l(1.000000) 								      -> exp((5 - 10*模长) / 100) + 1 
  div r7.w, l(1,1,1,1), r7.w                        -> 1 / [exp((5 - 10*模长) / 100) + 1] 
  mad_sat r7.w, r7.w, cb0[8].y, cb0[8].z 					  -> saturate(40.0/[exp((5 - 10*模长) / 100) + 1] - 19.5) -> 记为X 
  log r7.w, r7.w 											              -> r7.w = LOG(X) -> 小于0的数 
  mul r7.w, r7.w, cb0[8].w 									        -> LOG(X) * 0.7 
  exp r7.w, r7.w 											              -> exp(LOG(X) * 0.7) -> X^0.7 
  add r12.w, -r7.w, l(1.000000) 
  mad r7.w, cb0[1].w, r12.w, r7.w 							    -> (1 - X^0.7) * 0 + X^0.7 -> lerp 

  eq r12.w, cb0[9].x, l(0.000000) 							    -> 1 != 0 -> r12.w = false 
  min r13.w, r4.w, r7.z 									          -> min(Tex_AO, Computered_AO) -> some AO value any way... 
  min r15.w, r7.w, r13.w 									          -> min(X^0.7, min(AO)) 	->  其中的 X^0.7 推测扮演了AO_noise的角色 
  mul r7.w, r7.w, r13.w 									          -> X^0.7 * min(AO) 
  movc r7.w, r12.w, r15.w, r7.w 							      -> r7.w 是 AO_final -> 通过开关在两种模式间切换: Min(AO1,AO2) 和 Mul(AO1,AO2) 

  ieq r16.xyzw, r7.xxxx, l(6, 2, 3, 7) 						  -> [Purple.y修改值] * 255 的后4个bit <-> [6,2,3,7] 
  if_nz r16.x 	-> 后4-bit == 6的情况 
  	//利用法线的扰动 + AO相关参数 -> 求取该材质独有的 GI_Diffuse 
    mov r14.w, l(1.000000)  								        -> 在开始矩阵变换前将w通道设置为1 -> 代表这是对一个点(Point)进行空间变换 
    dp4 r18.x, cb1[181].xyzw, r14.xyzw 						  -> 对 (-Normal) 的顶点进行空间变换 -> R18 
    dp4 r18.y, cb1[182].xyzw, r14.xyzw 
    dp4 r18.z, cb1[183].xyzw, r14.xyzw

    mul r14.xyzw, r6.yzzx, r6.xyzz        					-> Normal.yzzx * Normal.xyzz -> 产生一个基于Normal的向量(?) 
    dp4 r19.x, cb1[184].xyzw, r14.xyzw 						  -> 对这个基于Normal的向量顶点进行另一种空间变换 -> R19 
    dp4 r19.y, cb1[185].xyzw, r14.xyzw
    dp4 r19.z, cb1[186].xyzw, r14.xyzw 

    mul r12.w, r6.y, r6.y
    mad r12.w, r6.x, r6.x, -r12.w  							    -> Normal.x^2 - Normal.y^2 
    add r14.xyz, r18.xyzx, r19.xyzx 						    -> R18 + R19 
    mad r14.xyz, cb1[187].xyzx, r12.wwww, r14.xyzx 	-> [-0.016, -0.01, -0.003] * (Normal.x^2 - Normal.y^2) + (R18 + R19) -> R14 
    max r14.xyz, r14.xyzx, l(0,0,0,0)						    -> 推测 R14是一个基于 Normal 的随机向量，且指向正半球空间 
    mul r14.xyz, r14.xyzx, cb1[180].xyzx 	    -> cb1[180]=[4.9, 4.1, 3.1] 是个老朋友,后面会多次出现,推测是'阳光'这类全局控制/缩放因子 
    mul r18.xyz, r5.xyzx, r5.xyzx 							    -> T11.xyz * T11.xyz 
    														                    -> T11纹理的xy通道分别是Flag位和Rough -> 后续作为乘子缩放 R14 
    mul r14.xyz, r7.wwww, r14.xyzx  		            -> 对 R14 使用环境光遮蔽 AO_final -> 由此推测 R14 是环境光入射光强度(也可以理解为反向AO) 
    mul r14.xyz, r18.xyzx, r14.xyzx 						    -> 对 R14 应用 来自 T11.xyz^2 的乘子(主要三个通道都 >= 0) 
  else 
    mov r14.xyz, l(0,0,0,0)  								        -> 不是 6号材质的话，R14 (环境光入射光强) = 0 
  endif 

  or r12.w, r16.z, r16.y 									          -> 2个渲染分支条件满足一个即可，既r12.w用于控制 r16.zy 所对应分支的渲染 
  mul r16.xyz, r5.xyzx, r5.xyzx 							      -> r5^2: r5 来自 T11 纹理，对除了人物和叶子外的区域，大多是[0,0,0,0] 
  mad r18.xyz, r5.xyzx, r5.xyzx, r15.xyzx  					-> r5^2 + r15颜色 
  movc r15.xyz, r12.wwww, r18.xyzx, r15.xyzx 				-> Condition: 选择 (r5^2 + r15颜色) or r15颜色 

  //以下分支计算用于 新的 R15 颜色 
  if_nz r16.w 												-> r16.w 分支控制 -> 7号材质 
  	//求 -ViewDirWS? 
  	//r1.xy 存放了 [-1, +1] * Clip.w -> 没有乘具体Depth -> 全屏Blit使用的三角形片所处的深度切片，xy分量在那个深度上是正确的 
    mul r18.xyz, r1.yyyy, cb1[49].xyzx						    -> Matrix_Inv_VP 的前 3X3 区域 
    mad r18.xyz, r1.xxxx, cb1[48].xyzx, r18.xyzx			-> 相当于将视空间坐标的 z 分量设置为1 
    add r18.xyz, r18.xyzx, cb1[50].xyzx    				 	  -> 然后以行向量形式 左乘 逆矩阵中控制旋转和缩放的部分 
    dp3 r1.x, r18.xyzx, r18.xyzx 
    rsq r1.x, r1.x 
    mul r18.xyz, r1.xxxx, r18.xyzx 							      -> 再归一化 -> 得到 -ViewDirWS -> 疑惑:为何不用 CamWS - PosWS 

    //求 ‘类折射向量’ 
    dp3 r1.x, -r18.xyzx, r6.xyzx 							        -> NdotV 
    mad r19.xyz, -r6.xyzx, r1.xxxx, -r18.xyzx 				-> NdotV * -Normal + ViewDir -> <类折射向量> 
    dp3 r1.y, r19.xyzx, r19.xyzx
    rsq r5.z, r1.y
    mul r17.xyz, r5.zzzz, r19.xyzx 							      -> 归一化 <类折射向量> 

    //控制粗糙度范围 
    max r5.z, r3.w, l(0.003922) 							        -> max([t9.w=0.69], 0.0039) -> roughness -> 来自rifr纹理的最后一个通道(rough2) 
    min r5.z, r5.z, l(1.000000) 							        -> min(0.69, 1.0) -> 粗糙度控制在[0,1]内 

	  //RdotV -> 视线趋向掠射角和垂直时都得0 
    dp3 r12.w, -r18.xyzx, r17.xyzx 	 

    //RdotN -> 掠射视角时得-1，垂直平面时得0 
    dp3 r13.w, r6.xyzx, r17.xyzx 							 

    //以下代码为: fast_acos(float v) -> 搜索关键数值'-0.156583'可得相关资料 
    //π/2 = 1.570796
    mad r14.w, |r1.x|, l(-0.156583), l(1.570796) 			-> -0.156583 * |NdotV| + 1.570796
    add r15.w, -|r1.x|, l(1.000000) 						      -> 1 - |NdotV|
    sqrt r15.w, r15.w 										            -> sqrt(1 - |NdotV|)
    mul r16.w, r14.w, r15.w 								          -> (-0.156583 * NdotV + 1.570796) * sqrt(1 - |NdotV|) -> 记A角度
    ge r18.x, r1.x, l(0.000000) 							        -> NdotV >= 0 ? true : false 
    mad r14.w, -r14.w, r15.w, l(3.141593) 					  -> π - (-0.156583 * NdotV + 1.570796) * sqrt(1 - |NdotV|)
    movc r14.w, r18.x, r16.w, r14.w 						      -> Condition: r14.w = A角度(true)  or  π-A角度(false) 
    add r14.w, -r14.w, l(1.570796) 							      -> 角度r14.w  -> N与V的夹角 

    //以下代码为: fast_acos(float v) 
    mad r15.w, |r13.w|, l(-0.156583), l(1.570796)
    add r16.w, -|r13.w|, l(1.000000)
    sqrt r18.x, r16.w
    mul r18.y, r15.w, r18.x
    ge r18.z, r13.w, l(0.000000)
    mad r15.w, -r15.w, r18.x, l(3.141593)
    movc r15.w, r18.z, r18.y, r15.w
    add r15.w, -r15.w, l(1.570796) 							      -> 角度r15.w -> N与<类折射向量>的夹角 -> 固定 90° 

    //ang_NoV - ang_RoN 
    add r14.w, r14.w, -r15.w 								          -> dif_Angle = N与V的夹角 - N与<-类折射向量>的夹角 
    mul r14.w, |r14.w|, l(0.500000)  						      -> 0.5 * |dif_Angle| 
    sincos null, r14.w, r14.w 								        -> cos(0.5 * |dif_Angle|) 

    //求这些方向与水平方向的夹角余弦值，并在此基础上调整(cosθ)的取值范围 
    mad r18.xyz, -r13.wwww, r6.xyzx, r17.xyzx 				-> Normal * (-RoN) + RefracDir -> 获得朝向折射方向的 "水平向量" 
    dp3 r15.w, r18.xyzx, r19.xyzx 							      -> <水平向量> dot <类折射向量> 
    dp3 r18.x, r18.xyzx, r18.xyzx 							      -> <水平向量> dot 自己 
    mad r1.y, r18.x, r1.y, l(0.000100) 						    -> <类折射向量>dot自己 * <水平向量>dot自己 + 0.0001 
    rsq r1.y, r1.y 											              -> 1 / sqrt(r1.y) -> 相当于求 |V_hori| * |RefracRaw|的倒数 
    mul r1.y, r1.y, r15.w 									          -> cos(V_hori和Refract的夹角) 
    mad r18.xy, r1.yyyy, l(0.5, 17.0, 0, 0), l(0.5, -16.780001, 0, 0)	-> cosθ*(0.5,17) + (0.5,-16.78) = (0.5cosθ+0.5, 17cosθ-16.78) 
    mov_sat r18.x, r18.x                              -> 如上操作可以看做是对cosθ的两种不同range调整 
    sqrt r1.y, r18.x 										              -> 这里对其中一个维度进行处理 -> sqrt(cos_VhroiToRefract*0.5+0.5) -> 简称为 sqrt(cos_VhoR) 

    mul r15.w, r5.z, r5.z 									          -> roughness^2 = 0.69^2 = 0.476 
    mad r5.z, r5.z, r5.z, l(0.200000) 						    -> roughness^2 + 0.2 = 0.676 
    mad r15.w, r15.w, l(2.000000), l(0.200000)				-> 2*roughness^2+0.2 = 1.152 

    mad r18.z, -r1.x, r1.x, l(1.000000) 					    -> 1 - NdotV * NdotV = 1 - cosθ^2 = sinθ^2 
    sqrt r18.z, r18.z 										            -> sinθ -> θ:N与V夹角 
    mul r18.xw, r1.yyyx, l(0.997551, 0, 0, -0.069943) -> [0.997551, -0.069943] * (sqrt(cos_VhroiToRefract), NdotV) 
    mad r18.x, r18.x, r18.z, r18.w 							      -> r18.x = 0.997*sqrt(cos_VhroiToRefract)*sinθ - 0.069943*cosθ -> twist 
                                                      -> twist是数值cos_VhoR基于θ对偏移后的结果 
    mul r5.z, r1.y, r5.z 									            -> (roughness^2 + 0.2) * sqrt(cos_VhroiToRefract) 
    mul r18.zw, r5.zzzz, l(0, 0, 1.414214, 3.544908)  -> r18.zw = sqrt(cos_VhoR)*(roughness^2 + 0.2) * [1.414214, 3.544908] 

    add r1.x, r1.x, r13.w 									          -> NdotV + RoN 
    mad r5.z, -r18.x, l(-0.139886), r1.x 					    -> (NdotV + RoN)-(-0.139886)*twist -> 记为 R5Z , 其中θ为N和V夹角 
    mul r5.z, r5.z, r5.z 									            -> R5Z^2 
    mul r5.z, r5.z, l(-0.500000) 							        -> -R5Z^2 / 2 

    mul r13.w, r18.z, r18.z 								          -> 2*cos_VhoR*(roughness^2+0.2)^2 
    div r5.z, r5.z, r13.w 									          -> -0.5*R5Z^2 / (2*cos_VhoR*(roughness^2+0.2)^2) 
    mul r5.z, r5.z, l(1.442695) 							        -> 1.442695 * (上式) -> 主要用于将下面的exp2转化为expE 
    exp r5.z, r5.z 											              -> exp(-0.5*R5Z^2 / (2*cos_VhoR*(roughness^2+0.2)^2))
    div r5.z, r5.z, r18.w  					-> exp(-0.5*R5Z^2 / (2*cos_VhoR*(roughness^2+0.2)^2)) / (2sqrt(π)*sqrt(cos_VhoR)*(roughness^2 + 0.2)) 
    mul r1.y, r1.y, r5.z 									            -> r1.y = sqrt(cos_VhroiToRefract_adjust2.x) * (上式) -> 记为 R5Z' 

    mad_sat r5.z, r12.w, l(0.500000), l(0.500000) 		-> (ViewDir dot <类折射向量>) * 0.5 + 0.5 
    sqrt r5.z, r5.z 										              -> sqrt(RoV * 0.5 + 0.5) 
    add r5.z, -r5.z, l(1.000000) 							        -> 1 - sqrt(RoV*0.5+0.5) 
    mul r13.w, r5.z, r5.z  									          -> [1 - sqrt(RoV*0.5+0.5)]^2 
    mul r13.w, r13.w, r13.w 								          -> [1 - sqrt(RoV*0.5+0.5)]^4 
    mul r5.z, r5.z, r13.w 									          -> [1 - sqrt(RoV*0.5+0.5)]^5 
    mad r5.z, r5.z, l(0.953479), l(0.046521) 				  -> 0.953479 * [1 - sqrt(RoV*0.5+0.5)]^5 + 0.046521 
    mul r1.y, r1.y, r5.z 									            -> R5Z'/3.544908*1*(roughness^2+0.2) * [a*(1-sqrt(.))^5+b] 
    mul r1.y, r10.w, r1.y 									          -> [0.2 or 0] * 上面r1.y -> R1Y 

    mov_sat r12.w, -r12.w 									          -> saturate(-RoV) 
    add r5.z, -r12.w, l(1.000000) 							      -> 1 - saturate(-RoV) 

    add r1.x, r1.x, l(-0.140000) 							        -> NdotV - 0.14 
    mul r1.x, r1.x, r1.x 									            -> (NdotV - 0.14)^2 
    mul r1.xy, r1.xyxx, l(-0.500000, 0.500000, 0, 0) 	-> [-0.5*(NdotV - 0.14)^2,  0.5*R1Y] 
    mul r10.w, r15.w, r15.w 								          -> (2*roughness^2+0.2)^2 
    div r1.x, r1.x, r10.w 									          -> -0.5*(NdotV - 0.14)^2 / (2*roughness^2+0.2)^2 
    mul r1.x, r1.x, l(1.442695) 
    exp r1.x, r1.x 											              -> exp(-0.5*(NdotV - 0.14)^2 / (2*roughness^2+0.2)^2) 
    mul r10.w, r15.w, l(2.506628) 							      -> (2*roughness^2+0.2)*sqrt(2π) 
    div r1.x, r1.x, r10.w 			                      -> exp(-0.5*(NdotV-0.14)^2/(2*roughness^2+0.2)^2) / (2*roughness^2+0.2)*sqrt(2π) 
    
    mad r10.w, -r14.w, l(0.500000), l(1.000000) 			-> 1 - 0.5 * cos(0.5 * |dif_Angle|) 
    mul r12.w, r10.w, r10.w 								          -> (1-cos(|dif_Angle|/2)/2)^2 
    mul r12.w, r12.w, r12.w 								          -> (1-cos(|dif_Angle|/2)/2)^4
    mul r10.w, r10.w, r12.w 								          -> (1-cos(|dif_Angle|/2)/2)^5
    mad r10.w, r10.w, l(0.953479), l(0.046521) 				-> 0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521 	-> 	R10W
    add r12.w, -r10.w, l(1.000000) 							      -> 1 - [0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]
    mul r12.w, r12.w, r12.w 								          -> {1-[0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]}^2 
    mul r10.w, r10.w, r12.w 								          -> {1-[0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]}^2 * R10W 

    div r12.w, l(0.800000), r14.w 							      -> 0.8 / cos(0.5 * |dif_Angle|) 
    log r18.xzw, r10.xxyz 									          -> ln(R10颜色) 
    mul r18.xzw, r12.wwww, r18.xxzw 						      -> [0.8 / cos(|dif_Angle|/2)] * ln(R10颜色) 
    exp r18.xzw, r18.xxzw 									          -> exp2([0.8 / cos(|dif_Angle|/2)] * ln(R10颜色)) 

    mul r12.w, r18.y, l(1.442695) 
    exp r12.w, r12.w 										              -> exp(17*cosθ - 16.78) -> 其他θ为 Vhroi_To_Refract
    mul r1.x, r1.x, r12.w         -> exp(0.219) * exp(-0.5*(NdotV-0.14)^2/(2*roughness^2+0.2)^2) / (2*roughness^2+0.2)*2*sqrt(π) -> R1X
    mul r1.x, r10.w, r1.x 				                    -> R1X * {1-[0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]}^2 * R10W -> R1X'
    mul r18.xyz, r18.xzwx, r1.xxxx 							      -> exp2([0.8 / cos(|dif_Angle|/2)] * ln(R10颜色)) * R1X' 
    mad r18.xyz, r1.yyyy, r5.zzzz, r18.xyzx  				  -> 0.5*R1Y * [1-saturate(-RoV)] + 上面r18.xyz  -> R18 

    dp3 r1.x, r17.xyzx, r17.xyzx 							        -> dot(RefracDir, RefracDir)
    add r1.x, r1.x, l(1.000000)								        -> 1 + dot(RefracDir, RefracDir)
    mul r1.x, r1.x, l(0.250000) 							        -> 0.25 * [1 + dot(RefracDir, RefracDir)]
    min r1.x, r1.x, l(1.000000) 							        -> min(0.25 * [1 + dot(RefracDir, RefracDir)], 1) -> 不大于1 -> _R1X 
    add r1.y, -r1.x, r16.w 									          -> (1 - |RoN|) - _R1X 
    mad r1.x, r1.y, l(0.330000), r1.x 						    -> lerp(_R1X, 1-|RoN|, 0.33) 
    mul r1.x, r1.x, r6.w 									            -> [0 or Purple.y] * lerp( _R1X, (1 - |RoN|), 0.33 ) 
    mul r1.x, r1.x, l(0.318310) 							        -> 0.31831 * [0 or Purple.y] * lerp( _R1X, (1 - |RoN|), 0.33 ) 
    
    sqrt r10.xyz, r10.xyzx  								          -> sqrt(R10颜色) 
    mad r10.xyz, r10.xyzx, r1.xxxx, r18.xyzx          -> R18颜色 + sqrt(R10颜色) * {0.31831*[0 or Purple.y]*lerp(_R1X,1-|dot(n,nvpv)|,0.33)} 
    min r10.xyz, -r10.xyzx, l(0, 0, 0, 0)  					  -> min(-新R10颜色, 0) -> 结合下面乘 -π -> 抹去负数 
    mul r15.xyz, r10.xyzx, l(-3.141593, -3.141593, -3.141593, 0)  -> R15颜色 = π * R10颜色 
  endif 

  //以下似乎用于计算 输出颜色的 Alpha 通道 
  ieq r1.x, r7.x, l(8) 							                  -> [Purple.y修改值] * 255 的后4个bit <-> [8] -> 是否是 8 号材质 
  mad r10.xyz, r16.xyzx, r5.wwww, r15.xyzx 		        -> T11.w * [r5^2] + R15颜色 
  movc r10.xyz, r1.xxxx, r10.xyzx, r15.xyzx 	        -> Condition: 如果是8号材质则 选择 {[r5^2] + R15颜色} 不然就是 R15颜色 

  //以下逻辑与之前处理 6号 材质时雷同 
  mov r17.w, l(1.000000) 						                  -> R17.xyz 是关于法线的一种扰动向量，在某些情况下等于 <类折射向量> nvpv 
  dp4 r15.x, cb1[181].xyzw, r17.xyzw 			            -> 对上述Point执行矩阵变换 -> R15 
  dp4 r15.y, cb1[182].xyzw, r17.xyzw
  dp4 r15.z, cb1[183].xyzw, r17.xyzw

  mul r16.xyzw, r17.yzzx, r17.xyzz 				            -> 基于R17向量进行一个随机化处理 
  dp4 r18.x, cb1[184].xyzw, r16.xyzw 			            -> 对上述Point执行新的矩阵变换 -> R18 
  dp4 r18.y, cb1[185].xyzw, r16.xyzw
  dp4 r18.z, cb1[186].xyzw, r16.xyzw

  mul r1.x, r17.y, r17.y
  mad r1.x, r17.x, r17.x, -r1.x 				              -> x^2 - y^2 
  add r15.xyz, r15.xyzx, r18.xyzx 				            -> R15 + R18 
  mad r15.xyz, cb1[187].xyzx, r1.xxxx, r15.xyzx       -> [-0.016,-0.01,-0.003] * (x^2 - y^2) + (R15 + R18) 
  max r15.xyz, r15.xyzx, l(0,0,0,0)  			            -> 确保都 >= 0 
  mul r15.xyz, r15.xyzx, cb1[180].xyzx 			          -> [4.9, 4.19, 3.1] * 上面结果 -> R15 或 ao_diffuse_common 

  mul r1.x, r11.w, r7.w 						                  -> lerp(NoRn, 1, 扰动向量模长) * AO_final  -> 某种基于Rn的AO(或者光强?) * AO_final 
  add r1.y, -r7.w, l(1.000000) 					              -> 1 - AO_final 
  mul r16.xyz, r1.yyyy, cb0[1].xyzx 			            -> [0.045,0.05,0.029] * (1 - AO_final) 
  mad r15.xyz, r1.xxxx, r15.xyzx, r16.xyzx 		        -> R15 * 基于Rn的AO(或者光强?) * AO_final + [0.045,0.05,0.029] * (1 - AO_final) 
  mad r10.xyz, r15.xyzx, r10.xyzx, r14.xyzx 	        -> R10 = R15 * R10颜色 + R14(如果不是6号材质则全0，如果是，R14是有值的，计算方法与这里类似) 
  mul r10.xyz, r10.xyzx, cb1[134].yyyy 			          -> R10 *= 1 -> 这是个颜色, 推测为 Diffuse 

  eq r1.x, cb1[200].z, l(0.000000) 				            -> 1 == 0 ? false 
  dp3 r1.y, r10.xyzx, l(0.300000, 0.590000, 0.110000, 0)  -> 取 R10 颜色 强度 
  and r1.y, r1.y, r1.x
  and r1.y, r1.y, r7.y 							                  -> r7.y = 是 9号 或 5号 材质渲染方案之一就为true 
  and o0.w, r1.y, r1.x 							                  -> 输出 Alpha, 因为连续使用了 and，且r1.x 肯定为 0， 这里输出应当为 0 
else 
  mov r10.xyz, l(0,0,0,0) 						                -> 这是最外层 if 的 else 分支 
  mov o0.w, l(0) 								                      -> 设置 r10颜色为 全黑(0), a通道=0 
endif 

ine r1.xy, r7.xxxx, l(0, 7, 0, 0)  				            -> [Purple.y修改值] * 255 的后4个bit <-> [0, 7] 
and r1.x, r1.y, r1.x 							                    -> 同时满足 -> 不是0号和7号材质渲染方案  
if_nz r1.x 
  movc r9.xyz, r7.yyyy, r11.xyzx, r9.xyzx 		        -> 是5或9号材质渲染方案 -> 则使用 R11(环境光底色*方块Mask.y) -> 不然就用R9(环境光底色) 
  mad r9.xyz, r9.xyzx, cb1[136].wwww, cb1[136].xyzx 	-> R9 * 1 + 0 
  mad r1.x, r5.x, r9.w, l(1.000000)  			            -> 1 + T11.x(菲涅尔等光照效果的开关?) * {[-1, 0]区间,与roughness和NoV有关}
  mul r1.y, r1.x, l(0.080000)  					              -> 0.08 * (1 + T11.x * {[-1, 0]区间,与roughness和NoV有关}) 
  mad r11.xyz, -r1.xxxx, l(0.08, 0.08, 0.08, 0), r12.xyzx	      ->R11 = R12颜色 - 0.08*(1 + T11.x*{[-1, 0]区间,与roughness和NoV有关}) 
  mad r11.xyz, r6.wwww, r11.xyzx, r1.yyyy 		        -> R11=[0 or Purple.y] * 上面的颜色 + 0.08*(1+T11.x*{[-1, 0]区间,与roughness和NoV有关}) 
  movc r9.xyz, r8.zzzz, r11.xyzx, r9.xyzx 		        -> 依据是否是 4号 材质方案设置 R9颜色 (R11 or R9) 
  add r1.x, r1.w, r1.w  						                  -> NdotV + NdotV
  mad r11.yzw, r1.xxxx, r6.xxyz, r8.xxyw		          -> Normal * 2(NdotV) + (-ViewDirWS) -> View_Reflection 或 VR 
  mul r1.x, r3.w, r3.w 							                  -> (rough2)^2 
  mad r1.y, -r3.w, r3.w, l(1.000000) 			            -> 1 - (rough2)^2 
  sqrt r1.w, r1.y 								                    -> sqrt(1 - (rough2)^2)
  mad r1.w, r3.w, r3.w, r1.w 					                -> (rough2)^2 + sqrt(1 - (rough2)^2)
  mul r1.y, r1.w, r1.y 							                  -> (1 - (rough2)^2) * [(rough2)^2 + sqrt(1 - (rough2)^2)] -> 某种 Rate -> 约 0.63 
  mad r2.xyz, -r2.xyzx, r2.wwww, r11.yzwy 		        -> VR - N 
  mad r2.yzw, r1.yyyy, r2.xxyz, r6.xxyz			          -> lerp(norm, VR, rate) -> '上抬视反' (注:没有归一化) 
  												                            -> 当Scale < 1时, 该反射方向(VR)相比镜面反射方向更加靠向法线; 反之则靠向VR 

  //使用屏幕UV采样 T12 -> 这张纹理看起来对水晶,金属扣环等物体做了处理 -> 疑似 spec 纹理 
  //从后续逻辑看(T12.xyz分量)推测是对高光项的线性的附加补充量 
  //T12.w后续会作用到基于环境光贴图的高光重建过程中 -> 推测为高光强度遮罩 
  sample_indexable(texture2d)(float,float,float,float) r6.xyzw, r0.xyxx, t12.xyzw, s6 
  add r0.x, -r6.w, l(1.000000) 							          -> 1 - T12.a 
  mad r12.xyzw, r6.xyzw, l(1, 1, 1, -1), l(0, 0, 0, 1)-> [T12.xyz, 1 - T12.w] 
  add r14.xyzw, -r12.xyzw, l(0, 0, 0, 1)  				    -> [-T12.xyz, T12.w] 
  mad r14.xyzw, r5.xxxx, r14.xyzw, r12.xyzw 			    -> r14 = [-T12.xyz, T12.w] * T11.x(控制阀) + [T12.xyz, 1 - T12.w] 
  movc r12.xyzw, r8.zzzz, r14.xyzw, r12.xyzw 			    -> r12 = 4号材质 ? r14 : [T12.xyz, 1 - T12.w] 
  
  //输出 r1.x -> 被T12.w通道修正过的'AO噪声'高频部分系数 
  mad r0.y, r4.w, r7.z, r3.x 							            -> TexAO(Purple.z) * Computered_AO(SSAO.r) + saturate(NdotV) -> mixed_AO
  log r0.y, r0.y 										                  -> ln(mixed_AO) 
  mul r0.y, r0.y, r1.x 									              -> ln(mixed_AO) * roughness^2 
  exp r0.y, r0.y 										                  -> exp2( ln(mixed_AO) * roughness^2 ) 
  mad r0.y, r4.w, r7.z, r0.y 			                    -> TexAO * Computered_AO + exp2(ln(mixed_AO) * roughness^2) -> AOwithRoughNoise 
  add_sat r0.y, r0.y, l(-1.000000) 						        -> saturate(AOwithRoughNoise - 1) -> 只截取超过1的部分，这部分可以看做是AO叠加上Rough后的高频噪声 
  mul r1.x, r0.y, r12.w 								              -> T12纹理(spec贴图)a通道值 * saturate(AOwithRoughNoise - 1) -> 被A通道修正过的 AO噪声 系数 

  ftou r0.zw, r0.zzzw 									              -> 屏幕像素索引(+0.5) to uint 
  mad r1.y, r1.z, cb3[3].x, cb3[3].y  					      -> 当前帧深度纹理解码的Depth * 1 + 1 
  log r1.y, r1.y 										                  -> ln(Depth + 1) 
  mul r1.y, r1.y, cb3[3].z 								            -> ln(Depth + 1) + 1 
  max r1.y, r1.y, l(0.000000) 							          -> max(ln(Depth + 1) + 1, 0) -> 返回值不小于 0 
  ftou r1.y, r1.y 										                -> max(ln(Depth + 1) + 1, 0) to uint 
  iadd r1.z, cb3[1].z, l(-1) 							            -> 1 - 1 = 0 
  umin r1.y, r1.z, r1.y 								              -> min(0, max(ln(Depth + 1) + 1, 0)) -> 似乎只能返回 0? -> 距离对数因子? 
  ushr r0.zw, r0.zzzw, cb3[2].xxxx 						        -> 屏幕像素索引(+1) >> 1 -> 相当于半屏幕分辨率 
  imad r0.w, r1.y, cb3[1].y, r0.w 						        -> 距离对数因子 * 1 + 半屏幕像素索引.v 
  imad r0.z, r0.w, cb3[1].x, r0.z 						        -> 距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u 
  iadd r0.z, r0.z, cb3[0].w 							            -> 距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1 
  ishl r0.w, r0.z, l(1) 								              -> (距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 0 
  
  //访问 T3 表 -> 下标为 r0.w = (深度对数因子 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 0 
  ld_indexable(buffer)(uint,uint,uint,uint) r0.w, r0.wwww, t3.yzwx 		-> 取第一个元素(X) 
  umin r0.w, r0.w, cb3[0].y 											    -> min(r0.w=[0,1,...,4,5,6,7...], 1) -> 不高于1? 
  bfi r0.z, l(31), l(1), r0.z, l(1) 					        -> (深度对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 1 
  ld_indexable(buffer)(uint,uint,uint,uint) r0.z, r0.zzzz, t3.yzxw  	-> 取第一个元素(X) 

  ieq r1.y, r7.x, l(6) 									              -> [Purple.y修改值] * 255 的后4个bit <-> [6] 
  lt r1.z, l(0.000000), cb0[0].x 						          -> 0 < 1 ? true -> 总是开启如下逻辑 
  if_nz r1.z 											                    -> 这里总是能进入 

  	//R13 = Scale * 从原Norm顶点指向新Norm顶点的向量(正向扰动矢量) + 原Normal向量 -> 由于相对于RN没有归一化，可记为 Rn_raw  
    dp3 r1.w, r13.xyzx, r13.xyzx 						          -> dot(Rn_raw, Rn_raw)
    sqrt r1.w, r1.w 									                -> Rn_raw 的模长 -> 记为 |Rn_raw| 或 |Rn| 
    //以下分支用于计算新的 r1.w 值 -> 某种扰动强度 
    //在重新计算过程中使用到了: |Rn|, roughness, asin(dot(Rn,'上抬视反')/|Rn|) -> 推测是经验公式 
    if_nz cb1[189].x 									                -> cb1[189].x 用十六进制解码后的 0x00000001 -> true 
      if_z r1.y 										                  -> 是否当前像素属于 6号材质 
        max r1.y, r3.w, l(0.100000) 					        -> max(roughness, 0.1) 
        mul r4.w, r1.w, cb0[0].y 						          -> |Rn| * 1 
        mul r5.z, r4.w, l(3.141593) 					        -> π * |Rn| 
        dp3 r5.w, r13.xyzx, r2.yzwy 					        -> dot(Rn, '上抬视反') 
        max r6.w, r1.w, l(0.001000) 					        -> max(|Rn|, 0.001) -> 模长不要小于 0.001 
        
        //构造传入函数asin_fast的入参 a -> (opposite / hypotenuse) 
        --div r5.w, r5.w, r6.w 							-> R5W = dot(Rn, '上抬视反') / max(|Rn|, 0.001) 

        //asin_fast(a)
        add r6.w, -|r5.w|, l(1.000000) 	 
        sqrt r6.w, r6.w 	 
        mad r7.x, |r5.w|, l(-0.018729), l(0.074261)  
        mad r7.x, r7.x, |r5.w|, l(-0.212114)  
        mad r7.x, r7.x, |r5.w|, l(1.570729)
        mul r7.y, r6.w, r7.x
        mad r7.y, r7.y, l(-2.000000), l(3.141593)
        lt r5.w, r5.w, -r5.w
        and r5.w, r5.w, r7.y
        mad r5.w, r7.x, r6.w, r5.w 
        mad r6.w, r1.y, l(3.141593), -r5.z 				-> 这一行于asin无关，用于计算:  π * |roughness| - π * |Rn|
        add r5.w, r5.w, -|r6.w| 						-> asin(dot(Rn, '上抬视反') / |Rn|)  

        mad r1.y, r1.y, l(3.141593), r5.z 				-> π * |roughness| + π * |Rn| 
        add r1.y, -|r6.w|, r1.y 						-> (π * |roughness| + π * |Rn|) - |π * |roughness| - π * |Rn|| 
        div_sat r1.y, r5.w, r1.y 						-> asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|) 
        add r1.y, -r1.y, l(1.000000) 					-> 1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)
        mad r5.z, r1.y, l(-2.000000), l(3.000000) 		-> -2*[1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)] + 3
        mul r1.y, r1.y, r1.y 							-> [1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)]^2
        mul r1.y, r1.y, r5.z
        	-> [1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)]^2 * {-2*[1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)] + 3}
        mad r4.w, r4.w, l(3.141593), l(-0.100000)		-> π * |Rn| - 0.1
        mul_sat r4.w, r4.w, l(5.000000) 				-> saturate((π * |Rn| - 0.1) * 5)
        mul r1.w, r1.y, r4.w
        	-> saturate((π * |Rn| - 0.1) * 5) * [1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)]^2 * {-2*[1 - asin(dot(Rn,'上抬视反')/|Rn|)  / (A+B-|A-B|)] + 3} 
      endif 
    endif 

    add r1.y, -r1.w, l(1.000000) 						-> 设 r1.w = 与|Rn|和Roughness有关的强度值 
    mad r1.y, cb0[1].w, r1.y, r1.w 						-> lerp(|Rn|关联值, 1, 0.0%) -> 还是本身 
    add r1.w, -r1.y, l(1.000000) 						-> 1 - |Rn|和Roughness关联 の 强度值 
    mul r7.xyz, r1.wwww, cb0[1].xyzx 					-> [0.045, 0.051, 0.029] * (1 - |Rn|关联值) -> GI_Spec_Base 
  else 
    mov r7.xyz, l(0,0,0,0) 								-> 这里总是不进入 
    mov r1.y, l(1.000000)
  endif 

  log r1.w, r3.w  										-> ln(roughness) 
  mad r1.w, -r1.w, l(1.200000), l(1.000000) 			-> 1 - 1.2 * ln(roughness) 
  add r4.w, cb1[188].z, l(-1.000000) 					-> 7 - 1 
  add r5.z, -r1.w, r4.w 								-> 6 - (1 - 1.2 * ln(roughness))
  mov r2.x, l(0) 										
  mov r8.xyw, l(0,0,0,0)
  mov r5.w, r1.x  										-> r5.w = 高反射率纹理a通道值 * saturate( R0Y - 1 ) -> Spec_Intense_1 
  mov r6.w, l(0) 										-> Loop Index (i) -> 初始为 0 

  //注意, r0.w = 使用'屏幕像素'与'距离对数'组合出索引，再从 T3 buffer 中取得的映射值 -> 取值范围要么 0, 要么 1 
  //挨个判断当前场景'激活'的 IBL 探针，如果当前像素点能被某张IBL影响，则进入内部 if 分支执行逻辑 
  loop 
    uge r7.w, r6.w, r0.w  								-> i >= r0.w ? 
    breakc_nz r7.w 										-> 相当于 while( i < r0.w ) 
    lt r7.w, r5.w, l(0.001000)							-> r5.w < 0.001 ? 
    if_nz r7.w 											-> 相当于 if (r5.w < 0.001) then break 
      break 
    endif 
    iadd r7.w, r0.z, r6.w 								-> r0.z 也是基于'屏幕像素'和'距离对数' 从T3 buffer直接获取 -> 可为[0,1,...] 
    ld_indexable(buffer)(uint,uint,uint,uint) r7.w, r7.wwww, t4.yzwx 	-> 使用 uint4 查看 T4 buffer 数据，这是张映射表 
    add r14.xyz, r4.xyzx, -cb4[r7.w + 0].xyzx 		-> 当前点世界空间坐标 - cb4[0-49] -> cb4前50组数据记录的是IBL探针的[posWS, 半径R] 
    dp3 r9.w, r14.xyzx, r14.xyzx 
    sqrt r10.w, r9.w 
    lt r12.w, r10.w, cb4[r7.w + 0].w 					-> 探针距离是否在范围 R 内 
    if_nz r12.w 
      div_sat r10.w, r10.w, cb4[r7.w + 0].w 			-> saturate(距离 / 影响半径R) 
      dp3 r12.w, r2.yzwy, r14.xyzx  					-> dot(<上抬视反>, <探素向量>) 
      mad r9.w, -cb4[r7.w + 0].w, cb4[r7.w + 0].w, r9.w -> (距离^2 - R^2) < 0 
      mad r9.w, r12.w, r12.w, -r9.w 					-> dot(<上抬视反>, <探素向量>)^2 - (距离^2 - R^2) 
      ge r13.w, r9.w, l(0.000000) 						-> dot(<上抬视反>, <探素向量>)^2 - (距离^2 - R^2) > 0 -> 总是true:正数-(负数) 
      sqrt r9.w, r9.w 									-> sqrt( dot(<上抬视反>, <探素向量>)^2 - (距离^2 - R^2) ) 
      add r9.w, -r12.w, r9.w 			-> sqrt(dot(<上抬视反>,<探素向量>)^2-(距离^2-R^2)) - dot(<上抬视反>,<探素向量>) -> R9W 
      mad r14.xyz, r9.wwww, r2.yzwy, r14.xyzx 			-> <上抬视反> * R9W + <探素向量> 
      add r14.yzw, r14.xxyz, -cb4[r7.w + 682].xxyz 		-> <上抬视反> * R9W + <探素向量> - 0 
      mad r9.w, r10.w, l(2.500000), l(-1.500000) 		-> 2.5 * (距离 / 影响半径R) - 1.5 
      max r9.w, r9.w, l(0.000000) 						-> 如果 (距离 / 影响半径R) < 0.6 -> 上式一律返回 0 
      mul r10.w, r9.w, r9.w 							-> [2.5 * (距离 / 影响半径R) - 1.5]^2 
      mad r9.w, -r9.w, l(2.000000), l(3.000000) 		-> 3 - 2 * [2.5 * (距离 / 影响半径R) - 1.5] 
      mad r14.x, -r10.w, r9.w, l(1.000000) 				-> 1 - {3-2*[2.5*(距离/影响半径R)-1.5]} * [2.5*(距离/影响半径R)-1.5]^2 
      movc r14.xyzw, r13.wwww, r14.xyzw, r2.xyzw 		-> 总是选择 [r14.x, r14.yzw], 不可能选r2=[0, <上抬视反>] 
      mov r15.xyz, r14.yzwy 							-> 把向量部分放到 r15.xyz 中 
      mov r15.w, cb4[r7.w + 341].y 						-> r15.w = 10 

      //采样 IBL Cubemap array, r15.w 是cube的编号索引; r15.xyz 是采样cubemap的方向指针 
      sample_l_indexable(texturecubearray)(float,float,float,float) r15.xyzw, r15.xyzw, t2.xyzw, s3, r5.z  -> 采样 IBL 探针纹理 

      mul r14.yzw, r15.xxyz, cb4[r7.w + 341].xxxx 		-> 探针返回颜色 * 1 
      mul r14.yzw, r14.xxxx, r14.yyzw 					-> 距离缩放因子 * 探针返回颜色 
      mul r14.yzw, r5.wwww, r14.yyzw					-> [Spec_Intense_1] * {距离缩放因子 * 探针返回颜色} 
      mad r8.xyw, r14.yzyw, r1.yyyy, r8.xyxw 			-> [spec * IBL_base_col] * [|Rn|和Roughness关联 の 强度值] + 0 
      mad r7.w, -r15.w, r14.x, l(1.000000) 				-> 1 - IBL_base_alpha * 距离缩放因子
      mul r5.w, r5.w, r7.w  							-> [Spec_Intense_1] * {1 - IBL_base_alpha * 距离缩放因子} 
    endif 

    iadd r6.w, r6.w, l(1)								-> LOOP index i++ 
  endloop 

  lt r1.x, l(0.000000), cb2[0].y 						-> 0 < 0.0992432 ? -> true 

  //以下分支用于采样天空盒颜色，返回值存入 R7.xyz 
  if_nz r1.x 
    add r1.w, -r1.w, cb2[0].x 							-> 1.8154297 - [1 - 1.2 * ln(roughness)]
    add r1.w, r1.w, l(-1.000000)						-> 1.8154297 - [1 - 1.2 * ln(roughness)] - 1 -> 这是计算 LOD 

    //采样 T0 cubemap -> 天空盒; r2=上抬视反 -> 我现在怀疑这货是视方向的反射方向(reflect dir) -> TODO: 修正之前的估计 
    sample_l_indexable(texturecube)(float,float,float,float) r14.xyz, r2.yzwy, t0.xyzw, s1, r1.w 
    mul r14.xyz, r14.xyzx, cb1[180].xyzx				-> 天空盒采样颜色 * [4.9, 4.19, 3.1]	-> 对3个通道缩放 -> why? 
    lt r2.x, l(0.000000), cb2[0].w 						-> 0 < -0.00087 -> false 

    if_nz r2.x 											-> 这里进不去
      //采样另一个天空盒 
      sample_l_indexable(texturecube)(float,float,float,float) r2.xyz, r2.yzwy, t1.xyzw, s2, r1.w 	-> T1 cubemap 无数据 
      mad r2.xyz, r2.xyzx, cb1[180].xyzx, -r14.xyzx 
      mad r14.xyz, cb2[0].wwww, r2.xyzx, r14.xyzx  		-> 与第一个天空盒颜色进行混淆 
    endif 

    mad r7.xyz, r14.xyzx, r1.yyyy, r7.xyzx 
    	-> 天空盒放大后颜色 * [|Rn|和Roughness关联 の 强度值] + {[0.045, 0.051, 0.029] * (1 - |Rn|关联值)} -> 后面{}里的是 R7颜色 -> 环境光底色? 
  endif 

  mul r2.xyz, r5.wwww, r7.xyzx 							-> 天空盒返回值 * Spec_Intense_1 
  mad r2.xyz, r8.xywx, cb1[156].xyzx, r2.xyzx 			-> IBL_spec1&rough1_col * 1 + 天空盒最终值 
  mad r2.xyz, cb1[134].yyyy, r2.xyzx, r12.xyzx 			-> 1 * (IBL_spec1&rough1_col * 1 + 天空盒最终值) + T12采样关联值(各颜色spec?) 
  														-> 可以认为是各种 IBL 采样返回的大集合 -> prefilter_Specular 

  if_nz r8.z 											-> 是否是 4号 材质
    mov r3.y, r3.w 							-> 据此知 r3.w=Roughness; r3.x=NdotV -> 这里被当做了出射光方向(毕竟当前pass是用来计算GI的) 
    sample_l_indexable(texture2d)(float,float,float,float) r1.yw, r3.xyxx, t5.zxwy, s4, l(0.000000)  -> 采样 LUT 
    mul_sat r2.w, r9.y, l(50.000000) 					-> R9色.Y通道 * 50 -> 待考: R9颜色似乎是一种环境光底色 
    mul r1.w, r1.w, r2.w 								-> LUT.bias * (50 * R9.y) -> 采样的r1.w = LUT.bias 
    add r2.w, -r5.x, l(1.000000) 						-> 1 - T11.x -> 控制阀取反 
    mul r1.w, r1.w, r2.w 								-> [LUT.bias * (50 * R9.y)] * (1 - T11.x) 
    mad r7.xyz, r9.xyzx, r1.yyyy, r1.wwww  				-> (R9色 * LUT.scale) + [LUT.bias * (50 * R9.y)] * (1 - T11.x) 
    													-> R9颜色 -> TODO: 是不是环境光底色? 或者是 F0? 
    mul r7.xyz, r2.xyzx, r7.xyzx  						-> {(R9色*LUT.scale) + [LUT.bias*(50*R9.y)]*(1-T11.x)} * prefilter_Specular 
    													-> 记为 R7颜色 -> 第一组合成的GI镜面反射

    mov r3.z, r5.y 										-> r5.y 来自 T11纹理采样 -> 推测是 Roughness -> 对于茅草和木头来说都是 0 
    													-> 而 r3.x = NdotV 
    sample_l_indexable(texture2d)(float,float,float,float) r1.yw, r3.xzxx, t5.zxwy, s4, l(0.000000) 
    mad r1.y, r1.y, l(0.040000), r1.w 					-> 0.04 * LUT.scale + LUT.bias 
    mul r1.w, r5.x, r1.y 								-> T11.x * (0.04 * LUT.scale + LUT.bias) 
    mad r1.y, -r1.y, r5.x, l(1.000000) 					-> 1 - T11.x * (0.04 * LUT.scale + LUT.bias) 
    mul r5.xzw, r1.wwww, r6.xxyz 						-> T11.x * (0.04 * LUT.scale + LUT.bias) * T12.xyz采样结果(spec) 

    mad r5.xzw, r7.xxyz, r1.yyyy, r5.xxzw 	-> R7颜色 - R7颜色 * [T11.x*(0.04*scale + bias)] + T12.xyz * [T11.x*(0.04*scale + bias)]
    						-> IBL采样生成的 GI_spec_A - 基于新LUT采样但使用IBL采样色的 GI_spec_A' + 基于新LUT采样和新Spec色的 GI_spec_B
    						-> 既在 GI_spec_A 基础上进行微调，引入新的环境GI_spec，同时去除重复量以免过曝 
    mul r0.x, r0.x, r1.w 								-> (1 - T12.a) * [T11.x*(0.04*scale + bias)]
    mul r0.x, r0.y, r0.x 						-> saturate(R0Y - 1) * (1 - T12.a) * [T11.x*(0.04*scale + bias)] -> Spec_Intense_2 

    if_nz r1.z 											-> 总是能进入 (通过buffer中的开关控制) 
      dp3 r0.y, r13.xyzx, r13.xyzx						-> dot(Rn, Rn) 
      sqrt r0.y, r0.y 									-> |Rn| 模长 

      if_nz cb1[189].x 									-> 使用 xint4格式查看 -> 1 -> 可以进入 
        max r1.y, r5.y, l(0.100000) 					-> max(0.1, T11.y) -> 对茅草等来说结果 = 0.1 
        mul r1.z, r0.y, cb0[0].y 						-> |Rn| * 1 
        mul r1.w, r1.z, l(3.141593) 					-> π * |Rn| 
        dp3 r2.w, r13.xyzx, r11.yzwy 					-> dot(Rn, VReflect) 
        max r3.y, r0.y, l(0.001000) 					-> max(|Rn|, 0.001) 

        div r2.w, r2.w, r3.y 							-> 准备asin_fast(a)的入参 a = dot(Rn, VReflect) / |Rn| 

        //asin_fast(a)
        add r3.y, -|r2.w|, l(1.000000)
        sqrt r3.y, r3.y
        mad r3.z, |r2.w|, l(-0.018729), l(0.074261)
        mad r3.z, r3.z, |r2.w|, l(-0.212114)
        mad r3.z, r3.z, |r2.w|, l(1.570729)
        mul r6.x, r3.y, r3.z
        mad r6.x, r6.x, l(-2.000000), l(3.141593)
        lt r2.w, r2.w, -r2.w
        and r2.w, r2.w, r6.x
        mad r2.w, r3.z, r3.y, r2.w
        mad r3.y, r1.y, l(3.141593), -r1.w 				-> π * max(0.1, T11.y) - π * |Rn| 
        add r2.w, r2.w, -|r3.y| 						-> 输出值 r2.w = asin( dot(Rn, VReflect) / |Rn| ) 

        mad r1.y, r1.y, l(3.141593), r1.w 				-> π * max(0.1, T11.y) + π * |Rn| 
        add r1.y, -|r3.y|, r1.y 						-> [π * max(0.1, T11.y) + π * |Rn|] - |π * max(0.1, T11.y) - π * |Rn|| 
        div_sat r1.y, r2.w, r1.y 			-> asin(a) / {[π * max(0.1, T11.y) + π * |Rn|] - |π * max(0.1, T11.y) - π * |Rn||} 
        add r1.y, -r1.y, l(1.000000)	-> R1Y' = 1 - asin(a) / {[π * max(0.1, T11.y) + π * |Rn|] - |π * max(0.1, T11.y) - π * |Rn||} 
        mad r1.w, r1.y, l(-2.000000), l(3.000000) 		-> 3 - 2 * R1Y' 
        mul r1.y, r1.y, r1.y 							-> (R1Y')^2 
        mul r1.y, r1.y, r1.w 							-> (R1Y')^2 * (3 - 2 * R1Y') 
        mad r1.z, r1.z, l(3.141593), l(-0.100000) 		-> π * |Rn| - 0.1
        mul_sat r1.z, r1.z, l(5.000000) 				-> saturate(5 * (π * |Rn| - 0.1)) 
        mul r0.y, r1.y, r1.z 							-> (R1Y')^2 * (3 - 2 * R1Y') * saturate(5 * (π * |Rn| - 0.1)) <= 1
      endif 

      add r1.y, -r0.y, l(1.000000) 
      mad r0.y, cb0[1].w, r1.y, r0.y 					-> lerp((R1Y')^2 * (3 - 2 * R1Y') * saturate(5 * (π * |Rn| - 0.1)), 1, 0.0%) 
      add r1.y, -r0.y, l(1.000000) 						-> 1 - (R1Y')^2 * (3 - 2 * R1Y') * saturate(5 * (π * |Rn| - 0.1))
      mul r1.yzw, r1.yyyy, cb0[1].xxyz 	-> [0.045, 0.051, 0.029] * [1 - (R1Y')^2 * (3 - 2 * R1Y') * saturate(5 * (π * |Rn| - 0.1))] 
    else 
      mov r1.yzw, l(0,0,0,0) 							-> 总是不进入 
      mov r0.y, l(1.000000)
    endif 

    log r2.w, r5.y 										-> ln(T11.y) 
    mad r2.w, -r2.w, l(1.200000), l(1.000000) 			-> 1 - 1.2 * ln(T11.y)
    add r3.y, -r2.w, r4.w 								-> 6 - ln(T11.y) 
    mov r11.x, l(0) 					
    mov r6.xyz, l(0,0,0,0) 
    mov r3.z, r0.x  									-> {(1 - T12.a)*[T11.x*(0.04*scale + bias)]} * saturate(R0Y - 1) 
    													-> Spec_Intense_2 -> 新计算出来的高光强度 
    mov r4.w, l(0) 										-> Index i = 0  

    //以下LOOP的起始形式与上面 IBL LOOP 的起始形式雷同 
    loop 
      //注意, r0.w = 使用'屏幕像素'与'距离对数'组合出索引，再从 T3 buffer 中取得的映射值 -> 取值范围要么 0, 要么 1 
      uge r5.y, r4.w, r0.w 								-> i >= r0.w? 
      breakc_nz r5.y 									-> while ( i < r0.w ) 
      lt r5.y, r3.z, l(0.001000) 						-> r3.z < 0.001 -> 推测 r3.z(或r0.x) 是某种待调整强度 
      if_nz r5.y 										-> if (r3.z < 0.001) then break 
        break 
      endif 

      iadd r5.y, r0.z, r4.w  							-> r0.z 也是基于'屏幕像素'和'距离对数' 从T3 buffer直接获取 -> 可为[0,1,...] 
      ld_indexable(buffer)(uint,uint,uint,uint) r5.y, r5.yyyy, t4.yxzw		-> 推测使用 ushort4 查看 T4 buffer 数据，这是张映射表 
      add r7.xyz, r4.xyzx, -cb4[r5.y + 0].xyzx 			-> 依然是求取 从探针指向 当前视点的向量 -> <探素向量> 
      dp3 r6.w, r7.xyzx, r7.xyzx 
      sqrt r7.w, r6.w 									-> 探针到视点的 Length 
      lt r8.x, r7.w, cb4[r5.y + 0].w 					-> Length < 探针影响的半径 R 
      if_nz r8.x 										-> 当前视点受探针影响的话 
      	//以下逻辑主要用于构造 IBL 采样向量 r8.xyz; 采样后
        div_sat r7.w, r7.w, cb4[r5.y + 0].w 			-> saturate(距离 / 影响半径R) 
        dp3 r8.x, r11.yzwy, r7.xyzx 					-> dot(View_Reflection, <探素向量>) -> 注:IBL_LOOP在这里使用的是 <上抬视反> 
        mad r6.w, -cb4[r5.y + 0].w, cb4[r5.y + 0].w, r6.w 	-> (距离^2 - R^2) < 0 
        mad r6.w, r8.x, r8.x, -r6.w 					-> dot(VR, <探素向量>)^2 - (距离^2 - R^2) 
        ge r8.y, r6.w, l(0.000000) 						-> dot(VR, <探素向量>)^2 - (距离^2 - R^2) >= 0 -> 总是true 
        sqrt r6.w, r6.w 								-> sqrt(dot(VR, <探素向量>)^2 - (距离^2 - R^2)) 
        add r6.w, -r8.x, r6.w 			-> sqrt(dot(VR, <探素向量>)^2 - (距离^2 - R^2)) - dot(VR, <探素向量>) -> R6W 
        mad r7.xyz, r6.wwww, r11.yzwy, r7.xyzx 			-> VR * R6W + <探素向量> 
        add r12.yzw, r7.xxyz, -cb4[r5.y + 682].xxyz 	-> VR * R6W + <探素向量>  - 0 -> 探针点 指向 VR*R6W 的终点 
        mad r6.w, r7.w, l(2.500000), l(-1.500000) 		-> 2.5 * saturate(距离/R) - 1.5 
        max r6.w, r6.w, l(0.000000) 					-> max(2.5 * saturate(距离/R) - 1.5, 0) -> [距离/R] < 0.6 则返回 0 
        mul r7.x, r6.w, r6.w 							-> [2.5 * saturate(距离/R) - 1.5]^2 
        mad r6.w, -r6.w, l(2.000000), l(3.000000) 		-> 3 - 2*[2.5 * saturate(距离/R) - 1.5] 
        mad r12.x, -r7.x, r6.w, l(1.000000) 			-> 1 - [2.5*saturate(距离/R) - 1.5]^2 * {3-2*[2.5*saturate(距离/R)-1.5]} 
        movc r7.xyzw, r8.yyyy, r12.xyzw, r11.xyzw 		-> 选[r12.x, r12.yzw] 
        mov r8.xyz, r7.yzwy								-> 把 向量部分 放到 r8.xyz 中 
        mov r8.w, cb4[r5.y + 341].y  					-> 10 

        //采样 cubemap array, 获取正确的 IBL 返回值 
        sample_l_indexable(texturecubearray)(float,float,float,float) r8.xyzw, r8.xyzw, t2.xyzw, s3, r3.y 

        mul r7.yzw, r8.xxyz, cb4[r5.y + 341].xxxx    	-> 探针返回颜色 * 1 
        mul r7.yzw, r7.xxxx, r7.yyzw 					-> 距离缩放因子 * 探针返回颜色 
        mul r7.yzw, r3.zzzz, r7.yyzw 					-> [新spec] * {距离缩放因子 * 探针返回颜色} 
        												-> r3.z = {(1 - T12.a)*[T11.x*(0.04*scale + bias)]} * saturate(R0Y - 1) 
        mad r6.xyz, r7.yzwy, r0.yyyy, r6.xyzx  			-> [spec * IBL_base_col] * [|Rn|和T11.Y(另一个Rough)关联 の 强度值] + 0 
        mad r5.y, -r8.w, r7.x, l(1.000000)  			-> 1 - IBL_base_alpha * 距离缩放因子 
        mul r3.z, r3.z, r5.y 							-> r3.z * {1 - IBL_base_alpha * 距离缩放因子} -> 对r3.z进行缩放修正(注意Loop条件) 
      endif 
      iadd r4.w, r4.w, l(1) 							-> i++ 
    endloop 

    //和采样天空盒同一个开关，总是true 
    if_nz r1.x
      add r0.x, -r2.w, cb2[0].x 						-> 1.815 - [1 - 1.2 * ln(T11.y)] 
      add r0.x, r0.x, l(-1.000000) 						-> 1.815 - [1 - 1.2 * ln(T11.y)] - 1 -> 注意,若T11.y=0, ln(0)=-∞ 

      //使用 View_Reflection 采样 天空盒 
      sample_l_indexable(texturecube)(float,float,float,float) r4.xyz, r11.yzwy, t0.xyzw, s1, r0.x
      mul r4.xyz, r4.xyzx, cb1[180].xyzx 				-> 天空盒返回值 * [4.9, 4.19, 3.1] 
      lt r0.z, l(0.000000), cb2[0].w 					-> 0 < -0.00087 -> false 

      if_nz r0.z 
      	//采样另一个天空盒 
        sample_l_indexable(texturecube)(float,float,float,float) r0.xzw, r11.yzwy, t1.xwyz, s2, r0.x 
        mad r0.xzw, r0.xxzw, cb1[180].xxyz, -r4.xxyz 
        mad r4.xyz, cb2[0].wwww, r0.xzwx, r4.xyzx 
      endif 

      mad r1.yzw, r4.xxyz, r0.yyyy, r1.yyzw 
      		-> 天空盒放大后颜色 * [|Rn|和T11.Y(另一个Rough)关联 の 强度值] + [0.045, 0.051, 0.029] * 某种与|Rn|关联值强度  
    endif 

    mul r0.xyz, r1.yzwy, r3.zzzz 						-> 天空盒返回值 * Spec_Intense_2 = 天空盒最终值 
    mad r0.xyz, r6.xyzx, cb1[156].xyzx, r0.xyzx			-> IBL_spec2&rough2_col * 1 + 天空盒最终值 
    mad r0.xyz, cb1[134].yyyy, r0.xyzx, r5.xzwx			-> 1 * (IBL_spec2&rough2_col + 天空盒最终值) + 第一个IBL计算后输出的 GI_spec 结果 
    													-> 叠加了2次 IBL 采样和计算结果 -> prefilter_Specular_Final 
  else 
  	//不是4号材质的时候进入这个分支 
    sample_l_indexable(texture2d)(float,float,float,float) r1.xy, r3.xwxx, t5.xyzw, s4, l(0.000000)  -> 采样 LUT 
    mul_sat r0.w, r9.y, l(50.000000) 					-> R9色.Y通道 * 50 -> 待考: R9颜色似乎是一种环境光底色 
    mul r0.w, r1.y, r0.w 								-> bias * saturate(50 * R9.y) 
    mad r1.xyz, r9.xyzx, r1.xxxx, r0.wwww 				-> R9色 * scale + bias * saturate(50 * R9.y) 
    mul r0.xyz, r1.xyzx, r2.xyzx 						-> prefilter_Specular * [R9色 * scale + bias * saturate(50 * R9.y)]
    													-> prefilter_Specular_Final  
  endif 

  min r0.xyz, -r0.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)	-> 去除 r0 颜色中小于 0 的部分 
  add o0.xyz, -r0.xyzx, r10.xyzx  									-> 最终输出颜色由: prefilter_Specular_Final + Diffuse 构成 
  																	-> R10颜色 据此推断为 Diffuse 
else 
  mov o0.xyz, r10.xyzx 		-> 对于 0号 或 7号 材质渲染方案来说，直接使用 R10.xyz的颜色(Diffuse) 输出值作为 GI 
endif 
ret 
// Approximately 0 instruction slots used
