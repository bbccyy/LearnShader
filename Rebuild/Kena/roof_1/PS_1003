PS
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// TEXCOORD                10   xyzw        0     NONE   float   xyz 
// TEXCOORD                11   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xyzw        2     NONE   float   xy  
// PRIMITIVE_ID             0   x           3     NONE    uint   x   
// SV_Position              0   xyzw        4      POS   float   xyzw
// SV_IsFrontFace           0   x           5    FFACE    uint   x   
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
// SV_Target                1   xyzw        1   TARGET   float   xyzw
// SV_Target                2   xyzw        2   TARGET   float   xyzw
// SV_Target                3   xyzw        3   TARGET   float   xyzw
// SV_Target                4   xyzw        4   TARGET   float   xyzw
// SV_DepthLessEqual        0    N/A oDepthLE  DEPTHLE   float    YES
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[178], immediateIndexed   ->  与 PS_796 一致 CBV 1433
dcl_constantbuffer CB1[7], immediateIndexed     ->  区别于 PS_796  ->  当前使用CBV 1318
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_sampler s2, mode_default
dcl_sampler s3, mode_default
dcl_resource_structured t0, 16                          -> Data Buffer 
dcl_resource_texture2d (float,float,float,float) t1     -> Normal Tex rg
dcl_resource_texture2d (float,float,float,float) t2     -> Grass RGBA 
dcl_resource_texture2d (float,float,float,float) t3     -> Purple RGB 
dcl_resource_texture2d (float,float,float,float) t4     -> Common Noise R 

dcl_input_ps linear centroid v0.xyz         -> NormalWS
dcl_input_ps linear centroid v1.xyzw        -> TangentWS
dcl_input_ps linear v2.xy                   -> UV
dcl_input_ps constant v3.x                  -> PRIMITIVE_ID

dcl_input_ps_siv linear noperspective centroid v4.xyzw, position     -> [pixelIdx.xy, NDC.z, -Clip.w] 
dcl_input_ps_sgv constant v5.x, is_front_face 

dcl_output o0.xyzw        未知 -> 类似剪影，基本上只渲染上了天空盒，以及极少数半透明物件(灯笼？)  T:8264 
                          o0 = [混淆后的BaseColor.rgb, 0]  ->  混淆是基于空间位置的，分为靠近世界中心部分和远离世界中心部分 
dcl_output o1.xyzw        可能是 normal  A通道在角色上0.66，在某些其他物件上0.33                T:8220 
                          o1 = [NormalWS.xyz, t0[PRIMTIVE_ID]]                               -> [NormalWS.xyz, 0.333] 
dcl_output o2.xyzw        未知 -> 偏蓝 且 w分量为手K的值                                       T:8241 
                          o2 = [Purple.y, cb1[5].w=0.2(环境光底色), Purple.y偏移值(urban一级控制Flag), 0.694118(粗糙度)]   
                              -> [?,0.2,?,0.694118] 
dcl_output o3.xyzw        可能是 base color -> 存放了 采样base Color 且经过变换后的颜色         T:8222 
                          o3 = [去除强度的BaseColor.rgb, 随机化处理的PurpleRGB.z]              -> [rgb, ?] 
dcl_output o4.xyzw        未知 -> 似乎区分了角色衣服布料和树叶 -> 推测用于区分动态和静态物体      T:8223 
                          o4 = [0, Roughness?, 0, 0]  ->  [0,0,0,0]  
dcl_output oDepthLE
dcl_temps 8

//获取 BitangentWS -> r0.xyz = Cross(NormalWS，TangentWS) * sign 
mul r0.xyz, v0.yzxy, v1.zxyz
mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx
mul r0.xyz, r0.xyzx, v1.wwww

//r1.x = VertexInput.z * VertexInput.w  ->  NDC.z * Clip.w = Clip.z 所有r1.x保存了Clip.z的数值 
//r1.y = 1 
//r1.z = VertexInput.w  
mov r1.x, v4.z 
mov r1.y, l(1.000000) 
mul r1.xz, r1.xxyx, v4.wwww 

//此处通过采样和解码，似乎是为了获得 Bitangent的朝向w 
imad r2.xy, v3.xxxx, l(35, 35, 0, 0), l(4, 20, 0, 0) 
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r0.w, r2.x, l(12), t0.xxxx 
mul r0.w, r0.w, cb0[140].w 
movc r1.w, v5.x, l(1.000000), l(-1.000000)    -> 根据VFACE判断当前像素所在几何体是正面朝向视点还是背面 
mul r0.w, r0.w, r1.w                          -> 这里赋值r0.w 而r0.xyz是Bitangent 

//采样法线纹理，解码位于切线空间的法线原始数据 
mul r2.xz, v2.xxyx, cb1[4].xxxx     -> UV *= 2，随后拿去采样 Normal 纹理（只有RG通道） -> cb1[4].x = 2 
sample_b_indexable(texture2d)(float,float,float,float) r3.xy, r2.xzxx, t1.xyzw, s0, cb0[142].y
mad r3.xy, r3.xyxx, l(2.000000, 2.000000, 0.000000, 0.000000), l(-1.000000, -1.000000, 0.000000, 0.000000)  从[0,1]转[-1,1]区间 
dp2 r1.w, r3.xyxx, r3.xyxx
add r1.w, -r1.w, l(1.000000)
max r1.w, r1.w, l(0.000000)   -> w在 [0,1] 区间
sqrt r3.z, r1.w               -> 到这里从RG通道中解出了第三个通道B
add r4.xyz, -r3.xyzx, l(0.000000, 0.000000, 1.000000, 0.000000)   -> 这两行add + mad的组合符合 lerp 指令 -> lerp((0,0,1), Norm, Rate) 
mad r3.xyz, cb1[4].yyyy, r4.xyzx, r3.xyzx                         -> cb1[4].y = Rate = 0 -> [float3(0,0,1) - TexNorm] * Rate + TexNorm 
mad r3.xyz, r3.xyzx, cb0[137].wwww, cb0[137].xyzx                 -> 对切线空间法线进行 Scale 和 Offset 等常规操作 
dp3 r1.w, r3.xyzx, r3.xyzx                                        -> 以下 3 行负责 归一化 TexNormal 
rsq r1.w, r1.w 
mul r3.xyz, r1.wwww, r3.xyzx 

//应用TBN矩阵将贴图法线转换到世界空间下，随后归一化，调整朝向 
mul r0.xyz, r0.xyzx, r3.yyyy
mad r0.xyz, r3.xxxx, v0.xyzx, r0.xyzx
mad r0.xyz, r3.zzzz, v1.xyzx, r0.xyzx
dp3 r1.w, r0.xyzx, r0.xyzx
rsq r1.w, r1.w
mul r0.xyz, r0.xyzx, r1.wwww    再归一化
mul r0.xyz, r0.wwww, r0.xyzx    调整朝向

mul r3.xyz, cb1[1].xyzx, cb1[4].zzzz    ->  r3.xyz = cb1[1].xyzx * cb1[4].z -> 0 

//采样 Grass 纹理，获取基础色 
sample_b_indexable(texture2d)(float,float,float,float) r4.xyz, r2.xzxx, t2.xyzw, s1, cb0[142].y 
mul r4.xyz, r4.xyzx, cb1[3].xyzx    -> 对采样Grass颜色RGB分别调整  cb1[3].xyz = [0.149,0.1098,0.078]  -> 此后称 R4 颜色 
mul r5.xyz, r4.xyzx, cb1[5].yyyy    -> 对调整后的颜色缩放 cb1[5].y = [1]  -> R5 颜色 -> 本质还是 R4 颜色 

//设 k = float3(0.577350, 0.577350, 0.577350)
//按照cb1[5].x规定的角度，旋转色调，返回值存入 R4.xyz 
dp3 r0.w, l(0.577350, 0.577350, 0.577350, 0.000000), r5.xyzx                  -> 则有 r0.w = dot(R5, k)
mul r1.w, r0.w, l(0.577350)                                                   -> r1.w = k * dot(R5, k)
mad r4.xyz, r4.xyzx, cb1[5].yyyy, -r1.wwww  -> 接下来会对临时颜色R4'(存入了r4)进行色调变换，设此处返回值 R4' = R5 - k * dot(R5, k) 
mul r5.xyz, r4.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000)                -> mul + mad 组合 -> 标准叉乘形式 
mad r5.xyz, r4.zxyz, l(0.577350, 0.577350, 0.577350, 0.000000), -r5.zxyz      -> cross(R4', k) 
sincos r6.x, r7.x, cb1[5].x                                                   -> cb1[5].x = 0 记为角度A 
mul r5.xyz, r5.xyzx, r6.xxxx                                                  -> cross(R4', k) * sinA 
mad r4.xyz, r4.xyzx, r7.xxxx, r5.xyzx                                         -> R4' * cosA + cross(R4', k) * sinA 
mad r4.xyz, r0.wwww, l(0.577350, 0.577350, 0.577350, 0.000000), r4.xyzx       -> k * dot(R4, k) + R4' * cosA + cross(R4', k) * sinA 

//已知 Color dot (0.3,0.59,0.11) = Color_Intensity 
//以下逻辑用于求取 R4 颜色的 强度 Intensity 或叫做 Cdlum 
dp3 r0.w, r4.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000)

//通过 Lerp 得到最终基础色
add r5.xyz, -r4.xyzx, r0.wwww                   -> Cdlum - R4
mad_sat r4.xyz, cb1[5].zzzz, r5.xyzx, r4.xyzx   -> cb1[5].z=Rate=0.2 -> R4=saturate((Cdlum - R4) * Rate + R4) -> 从 R4 lerp 到 Cdlum 

//采样 Purple RGB 纹理 -> 存放在 R2.xz 中
sample_b_indexable(texture2d)(float,float,float,float) r2.xz, r2.xzxx, t3.yxzw, s2, cb0[142].y   -> r2.xz = PurpleRGB.yz 
mul_sat r0.w, r2.x, cb1[6].x                    -> R0.w = saturate(1.5 * PurpleRGB.y) 

//利用 VertexInput.xy 构造噪声         -> 存入 r1.w   ->  此噪声基于屏幕空间，与EyePosition相关 
add r5.xy, v4.xyxx, -cb0[129].xyxx    -> cb0[129] = 0,0,0,0 
add r5.zw, r5.xxxy, cb0[151].xxxx     -> cb0[151] = 0,0,0,0  可以认为 r5.xy|zw 是对当前fragment在屏幕上的坐标进行前后两次偏移后获得 
ftou r5.zw, r5.zzzw                   -> r5.xy是屏幕坐标原始值，r5.zw是屏幕坐标‘整数’值 -> 这步可以佐证 VertexInput.xy = 屏幕像素坐标 
ishl r1.w, r5.w, l(1)                 -> VertexInput.y << 1 
iadd r1.w, r1.w, r5.z                 -> VertexInput.y * 2 + VertexInput.x 
udiv null, r1.w, r1.w, l(5)           -> (VertexInput.y * 2 + VertexInput.x) mod 5 -> 求余数 -> 记为 R1.w (可取值: 0,1,2,3,4) 
utof r1.w, r1.w 

//采样 Common Noise，采样uv来自于屏幕像素坐标的变换，纹理的尺寸是 64 x 64  
//输出的随机值 R1.w -> 基于屏幕像素位置 -> 理论上会随着 视点View 的改变而改变 -> 并不是固定在模型空间上的随机数 
mul r5.xy, r5.xyxx, l(0.015625, 0.015625, 0.000000, 0.000000)    -> 0.015625=1/64 -> 屏幕坐标XY/64 -> [1/64]的整数倍 
sample_b_indexable(texture2d)(float,float,float,float) r2.w, r5.xyxx, t4.yzwx, s3, cb0[142].y 
add r1.w, r1.w, r2.w                  -> r1.w            取值 0.0 ~ 4.99   
mul r1.w, r1.w, cb1[6].y              -> cb1[6].y = 10   取值 0.0 ~ 49.99 
mul r1.w, r1.w, l(0.166667)           -> 0.1667 = 1/6    取值 0.0 ~ 8.33  

//目的是为了转换出 R1.y -> 某种基于距离的 Noise 
//R1.y 等效于一种计算出来的 NDC.z 
//若 Clip.w 没有落在 [24~280] 间，则下面的 div_sat 指令会在结果小于24时返回值恒为0，大于280时返回恒为1 
//Clip.w 等效视空间z轴距离 
mad r1.y, r1.y, v4.w, l(-24.000000)   -> r1.y = 1 * Clip.w - 24 -> 视空间z轴距离 - 常量24 
div_sat r1.y, r1.y, cb1[6].z          -> cb1[6].z=256 -> r1.y = saturate((Clip.w-24)/256) 
mad r1.y, r1.y, r1.w, r1.z            -> r1.y = saturate((Clip.w-24)/256) * rand[0, 8.33] + Clip.w 
div r1.y, r1.x, r1.y                  -> r1.y = Clip.z / (saturate((Clip.w-24)/256) * rand[0, 8.33] + Clip.w) 
min r1.y, r1.y, v4.z                  -> r1.y 不能大于 NDC.z -> 既取到的 R1.y 总是在原始 NDC.z 之前（靠近摄像机) 

mov_sat r1.w, cb1[5].w                  -> cb1[5].w=0.2 -> R1.w = 0.2
mov_sat r2.xz, r2.xxzx                  -> R2.xz = saturate(PurpleRGB.yz)

//**填充 o2.z**
//r0.w 存放 PurpleRGB.y 采样并放大1.5倍的结果，这里通过某种缩放和平移(cb0部分数据感觉不对)，变换后输出到偏蓝图片Blue通道中去 
//从输出截图来看，效果类似于原始的 PurpleRGB.y 通道采样结果 
mad o2.z, r0.w, cb0[138].y, cb0[138].x  -> cb0[138].y可能是 1 / 1.5 

//**填充 o1.w** -> 采样自 t0 buffer 
//r2.y = PRIMITIVE_ID * 35 + 20
//o1.w = 0.333
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) o1.w, r2.y, l(4), t0.xxxx

//对baseCol颜色R4进行小范围调整，期间利用了新的 PurpleRGB 的 y 通道作为底子，分别产生了 R5 和 R6 两个分支颜色 
mul r0.w, r1.w, l(0.080000)     -> cb1[5].w * 0.08 = 0.2 * 0.08 
mad r5.xyz, -r1.wwww, l(0.080000, 0.080000, 0.080000, 0.000000), r4.xyzx  -> R4颜色 - 0.2 * 0.08^2 -> 先对R4向下做个微调 
mad r5.xyz, r2.xxxx, r5.xyzx, r0.wwww     -> R5 = PurpleRGB.y * R5颜色 + 0.2*0.08 -> 本质是对 R4 颜色做基于 PurpleRGB.y 的上下波动 
mad r6.xyz, -r4.xyzx, r2.xxxx, r4.xyzx    -> R6 = R4颜色 * (1 - PurpleRGB.y) 
mad r6.xyz, r6.xyzx, cb0[135].wwww, cb0[135].xyzx       -> 对R6颜色 -> 进行未知缩放 + 平移 -> 可以默认为 scale=1，offset=0 
mad r5.xyz, r5.xyzx, cb0[136].wwww, cb0[136].xyzx       -> 对R5颜色 -> 进行未知缩放 + 平移 

//这里是读取预设的逻辑开关，控制是否使用独立的 R5,R6 颜色 还是使用合并后的 R7 颜色 
ne r0.w, l(0.000000, 0.000000, 0.000000, 0.000000), cb0[177].w            -> r0.w = ( cb0[177].w != 0 )  -> false 
mad r7.xyz, r5.xyzx, l(0.450000, 0.450000, 0.450000, 0.000000), r6.xyzx   -> R7 是 R5 和 R6 的混合结果 -> R5 * 0.45 + R6 
movc r6.xyz, r0.wwww, r7.xyzx, r6.xyzx                                    -> R6 应该还是 R6 
movc r5.xyz, r0.wwww, l(0,0,0,0), r5.xyzx                                 -> R5 应该还是 R5 

//**填充 o3.w**
//利用 R5 颜色的光强度和两组随机数构建混淆因子，随后作用到 PurpleRGB.z 通道上
//o3.w = max(随机化处理的PurpleRGB.z, PurpleRGB.z原始值) 
dp3 r0.w, r5.xyzx, l(0.300000, 0.590000, 0.110000, 0.000000)      -> r0.w = R5 颜色的光强度 Intensity 
mad r7.xyz, r0.wwww, l(2.040400, -4.795100, 2.755200, 0.000000), l(-0.332400, 0.641700, 0.690300, 0.000000) -> 基于光强度的随机值 
mad r0.w, r2.z, r7.x, r7.y
mad r0.w, r0.w, r2.z, r7.z
mul r0.w, r2.z, r0.w              -> 利用随机数 R7 对 PurpleRGB.z 进行处理 
max o3.w, r0.w, r2.z              -> max(随机化处理的PurpleRGB.z, PurpleRGB.z原始值) 

mad r2.yzw, r5.xxyz, l(0.000000, 0.450000, 0.450000, 0.450000), r6.xxyz     -> R2.yzw 是 R5 和 R6 的混合结果 -> R5 * 0.45 + R6 
max r3.xyz, r3.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)              -> R3 = max(cb1[1].xyzx * cb1[4].z, 0) -> 0 

//依据buffer参数控制开关：会影响部分(基于空间的)后处理效果 
lt r0.w, l(0.000000), cb0[139].x                                            -> 0 < cb0[139].x ? true : false -> false 

//这部分具体参考 PS_796, 两者是一样的 
if_nz r0.w
  mul r5.xyzw, v4.yyyy, cb0[45].xyzw
  mad r5.xyzw, v4.xxxx, cb0[44].xyzw, r5.xyzw
  mad r5.xyzw, v4.zzzz, cb0[46].xyzw, r5.xyzw
  add r5.xyzw, r5.xyzw, cb0[47].xyzw
  div r5.xyz, r5.xyzx, r5.wwww
  add r6.xyz, r5.xyzx, -cb0[70].xyzx
  dp3 r0.w, -r5.xyzx, -r5.xyzx
  rsq r0.w, r0.w
  mul r5.xyz, r0.wwww, -r5.xyzx
  mad r0.w, -r1.y, r1.z, r1.x
  div r0.w, r0.w, r1.y
  mad r5.xyz, r5.xyzx, r0.wwww, r6.xyzx
  imad r1.xz, v3.xxxx, l(35, 0, 35, 0), l(5, 0, 19, 0)
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r6.xyz, r1.x, l(0), t0.xyzx
  add r6.xyz, r5.xyzx, -r6.xyzx
  ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r7.xyz, r1.z, l(0), t0.xyzx
  add r7.xyz, r7.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000)
  lt r6.xyz, r7.xyzx, |r6.xyzx|
  or r0.w, r6.y, r6.x
  or r0.w, r6.z, r0.w
  dp3 r1.x, r5.xyzx, l(0.577000, 0.577000, 0.577000, 0.000000)
  mul r1.x, r1.x, l(0.002000)
  frc r1.x, r1.x
  lt r1.x, l(0.500000), r1.x
  movc r5.xyz, r1.xxxx, l(0,1.000000,1.000000,0), l(1.000000,1.000000,0,0)

  //这是分支计算的最后返回值 R3.xyz 
  movc r3.xyz, r0.wwww, r5.xyzx, r3.xyzx  -> 要么r3是 [0,1,1]或[1,1,0] 这种固定范式，要么是 max(cb1[1].xyzx * cb1[4].z, 0) 的值
endif 

mad r2.yzw, cb0[144].yyyy, r2.yyzw, r3.xxyz  ->  R5,R6混合色缩放 + 偏移 (此时数值可能超 1.0)
mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) -> [0,1]区间的NormalWS 
mul o0.xyz, r2.yzwy, cb0[134].yyyy  -> 缩放修正，确保输出值小于1.0 
mov o0.w, l(0)
mov o2.x, r2.x                      -> PurpleRGB.y 
mov o2.w, l(0.694118)
mov o2.y, r1.w                      -> cb1[5].w = 0.2 
mov o3.xyz, r4.xyzx                 -> 经过Hue shift，并重新调整了Intensity的 BaseColor 
mov o4.xyzw, l(0,0,0,0)
mov oDepthLE, r1.y
ret 
// Approximately 0 instruction slots used
