MI_TreeStructure_Outside


Shader hash b9e0deef-690c5440-6ddd0889-2e680f0b

ps_5_0
      dcl_globalFlags refactoringAllowed
      dcl_constantbuffer cb0[178], immediateIndexed
      dcl_constantbuffer cb1[1], immediateIndexed
      dcl_constantbuffer cb2[25], immediateIndexed
      dcl_sampler s0, mode_default
      dcl_sampler s1, mode_default
      dcl_sampler s2, mode_default
      dcl_sampler s3, mode_default
      dcl_sampler s4, mode_default
      dcl_sampler s5, mode_default
      dcl_sampler s6, mode_default

      dcl_resource_structured t0, 16
      dcl_resource_texture2d (float,float,float,float) t1 			T_TreeStructure_Outside_N -> 4K Normal           OK
                                                                        Mochi/Art/Inorganic/Structures/Village/TreeStructure/Textures/
                                                                        
      dcl_resource_texture2d (float,float,float,float) t2 			T_BarkTest_02_N -> 2K Normal           OK
      											Mochi\Environment\Tests\MaterialBlending_Tests\Textures/T_BarkTest_02_N

      dcl_resource_texture2d (float,float,float,float) t3 			???_N -> 0.5k Normal           OK
                                                                        Mochi/Environment/Prototype/Assets/Tiles/Textures/Moss/moss_normal
                                                                        or Mochi\MaterialLibrary\Textures\Moss\T_Moss_01_N

      dcl_resource_texture2d (float,float,float,float) t4 			T_TreeStructure_Outside_Comp_Msk_Curv_Aol           OK
                                                                        Mochi/Art/Inorganic/Structures/Village/TreeStructure/Textures/

      dcl_resource_texture2d (float,float,float,float) t5 			WaterWave_Noise -> T_NoiseCaustic02
                                                                        Game/ThirdParty/InteractiveForceFields/Textures/T_NoiseCaustic02

      dcl_resource_texture2d (float,float,float,float) t6 			GoodCommon_Noise -> T_NoiseClassic01
                                                                        Game/ThirdParty/InteractiveForceFields/Textures/T_NoiseClassic01

      dcl_resource_texture2d (float,float,float,float) t7 			T_BarkTest_03_D           OK
      											Mochi\Environment\Tests\MaterialBlending_Tests\Textures

      dcl_resource_texture2d (float,float,float,float) t8			1K_D -> 1K Diffuse           OK
                                                                        Mochi/Art/Organic/Trees/Textures/DeadMoss

      dcl_resource_texture2d (float,float,float,float) t9 			T_BarkTest_03_comp_H_R_Ao_Msk           OK
      											Mochi\Environment\Tests\MaterialBlending_Tests\Textures

      dcl_resource_texture2d (float,float,float,float) t10 			??? T_Moss_01_Comp_H_R_Ao           OK
                                                                        Mochi/MaterialLibrary/Textures/Moss/

      dcl_input_ps linear centroid v0.xyz 					Normal
      dcl_input_ps linear centroid v1.xyzw 					Tangent   -> 疑惑，后续很多逻辑最好将这个变量解释为 Normal 不然就不合理了 
      dcl_input_ps linear v2.xy 							UV
      dcl_input_ps nointerpolation v3.x 						InstanceID
      dcl_input_ps linear v4.xyz 							some positionWS(not dir)
      dcl_input_ps_siv linear noperspective v5.xyz, position 		SV_Position

      dcl_output o0.xyzw                CameraColor
      dcl_output o1.xyzw                Normal
      dcl_output o2.xyzw                M_D_R_I
      dcl_output o3.xyzw                Diffuse
      dcl_output o4.xyzw                Custom

      dcl_temps 13

   0: mul r0.xyz, v0.yzxy, v1.zxyz
   1: mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx
   2: mul r0.xyz, r0.xyzx, v1.wwww                  float3 BitangentWS = cross(i.NormalWS, i.TangentWS) * i.TangentWS.w

   3: mul r1.xyzw, v5.yyyy, cb0[45].xyzw
   4: mad r1.xyzw, v5.xxxx, cb0[44].xyzw, r1.xyzw
   5: mad r1.xyzw, v5.zzzz, cb0[46].xyzw, r1.xyzw
   6: add r1.xyzw, r1.xyzw, cb0[47].xyzw
   7: div r1.xyz, r1.xyzx, r1.wwww 			此处计算后的r1.xyz 与 v4.xyz 非常相似 (-1093.98889, 1826.24487, 2765.40552, 0.00032)

   8: add r2.xyz, r1.xyzx, -cb0[70].xyzx                    cb0[70].xyz -> WorldSpaceCameraPosition
   9: add r3.xyz, v4.xyzx, -cb0[70].xyzx                    推测是把坐标变换到WorldSpace的最后一步（目的是为了避免精度损失）

  10: dp3 r0.w, -r1.xyzx, -r1.xyzx 					
  11: rsq r0.w, r0.w
  12: mul r1.xyz, r0.wwww, -r1.xyzx					推测是 view direction (从着色点指向摄像机，且归一化了)
                                                            r1.xyz = 0.86626, -0.48576, -0.11676

  13: sample_b(texture2d)(float,float,float,float) r4.xy, v2.xyxx, t1.xyzw, s1, cb0[142].y                  UV采样4K_Normal
  14: mad r4.xy, r4.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)            转到[-1，+1]区间
  15: dp2 r0.w, r4.xyxx, r4.xyxx
  16: add r0.w, -r0.w, l(1.0000)
  17: max r0.w, r0.w, l(0)
  18: sqrt r4.z, r0.w                                       求解出 4K_Normal.xyz -> r4

  19: mul r5.xyz, r4.xyzx, cb2[2].xyzx                      4K_Normal.xyz * [2,2,1] -> 4K_Normal      
  20: mad r0.w, r4.z, cb2[2].z, l(1.0000)                   4K_Normal.z * 1 + 1

  21: div r6.xyz, r3.xyzx, cb2[16].wwww                     posWS / -376.8 -> r6 = [158.43385, -63.32237, 17.52998]
  22: sample_indexable(texture2d)(float,float,float,float) r7.xy, r6.xzxx, t2.xyzw, s0                      用基于世界坐标的随机 UV1 采样2K_Normal
  23: mad r7.xy, r7.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
  24: dp2 r1.w, r7.xyxx, r7.xyxx
  25: add r1.w, -r1.w, l(1.0000)
  26: max r1.w, r1.w, l(0)
  27: sqrt r7.z, r1.w                                       求解出 2K_Normal_1.xyz -> r7

  28: sample_indexable(texture2d)(float,float,float,float) r8.xy, r6.yzyy, t2.xyzw, s0                      用基于世界坐标的随机 UV2 采样2K_Normal
  29: mad r8.xy, r8.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
  30: dp2 r1.w, r8.xyxx, r8.xyxx
  31: add r1.w, -r1.w, l(1.0000)
  32: max r1.w, r1.w, l(0)
  33: sqrt r8.z, r1.w                                       求解出 2K_Normal_2.xyz -> r8

  34: mad_sat r9.xy, abs(v1.xzxx), l(3.0000, 3.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)   -> sat(tangent.xy * 3 - 1) = [0, 0]
  35: add r8.xyz, -r7.xyzx, r8.xyzx                         2K_Normal_2 - 2K_Normal_1
  36: mad r7.xyz, r9.xxxx, r8.xyzx, r7.xyzx                 lerp(2K_Normal_1, 2K_Normal_2, r9.x) -> 使用 2K_Normal_1

  37: sample_indexable(texture2d)(float,float,float,float) r8.xy, r6.xyxx, t2.xyzw, s0                      用基于世界坐标的随机 UV3 采样2K_Normal
  38: mad r8.xy, r8.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
  39: dp2 r1.w, r8.xyxx, r8.xyxx
  40: add r1.w, -r1.w, l(1.0000)
  41: max r1.w, r1.w, l(0)
  42: sqrt r8.z, r1.w                                       求解出 2K_Normal_3.xyz -> r8

  43: add r8.xyz, -r7.xyzx, r8.xyzx
  44: mad r7.xyz, r9.yyyy, r8.xyzx, r7.xyzx                 lerp(2K_Normal_1, 2K_Normal_3, r9.y) -> 使用 2K_Normal_1

  45: mad r7.xyz, cb2[4].xyzx, r7.xyzx, r7.xyzx             2K_Normal * [0.2, 0.2, 0] + 2K_Normal
  46: mad r5.w, r4.z, cb2[2].z, l(1.0000)                   4K_Normal.z * 1 + 1
  47: mul r7.xyz, r7.xyzx, l(-1.0000, -1.0000, 1.0000, 0.0000)       2K_Normal * [-1, -1, 1] 
  48: dp3 r1.w, r5.xywx, r7.xyzx                            4K_Normal dot 2K_Normal  -> 注意 4K_Normal.z 使用了 w 通道 -> similarity
  49: mul r7.xyz, r0.wwww, r7.xyzx                          2K_Normal * scaler(r0.w)
  50: mad r7.xyz, r5.xywx, r1.wwww, -r7.xyzx                4K_Normal * similarity - 2K_Normal -> mix_norm

  51: add r8.xyz, r2.xyzx, -cb0[67].xyzx                    回滚cb0[70]的处理，获得刨去Transition变换的 “世界空间”坐标 -> 求的是相机到着色点的距离！
  52: dp3 r0.w, r8.xyzx, r8.xyzx
  53: sqrt r0.w, r0.w                                       当前着色点到模型中心点的距离 d
  54: div r0.w, r0.w, cb2[17].x                             d / 1863.49 -> 似乎是除以了模型球形轮廓的半径 -> 距离模型表面的比例 rate
  55: max r0.w, r0.w, l(0.0000)
  56: mul r0.w, r0.w, r0.w
  57: mul r0.w, r0.w, r0.w                                  rate^4
  58: min r0.w, r0.w, l(1.0000)                             min(~, 1) -> rate 不能超过1 

  59: mad r4.xyz, r4.xyzx, cb2[2].xyzx, -r7.xyzx            4K_Normal * [2,2,1] - mix_norm
  60: mad r4.xyz, r0.wwww, r4.xyzx, r7.xyzx                 4K_Normal = lerp(mix_norm, 4K_Normal * [2,2,1], rate)

  61: div r3.xyz, r3.xyzx, cb2[18].wwww                     posWS / -250.99

  62: sample_b(texture2d)(float,float,float,float) r7.xy, r3.xzxx, t3.xyzw, s2, cb0[142].y                      用基于世界坐标的随机 UV1 采样 HalfK_Normal
  63: mad r7.xy, r7.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
  64: dp2 r0.w, r7.xyxx, r7.xyxx
  65: add r0.w, -r0.w, l(1.0000)
  66: max r0.w, r0.w, l(0)
  67: sqrt r0.w, r0.w

  68: mul r8.y, r0.w, v1.y                                  求解值 * tangent.y
  69: mov r8.xz, -r7.xxyx                                   求解出 HalfK_Normal_1 -> 注意 y 通道是求解出来的 xz 通道是采样出来的

  70: sample_b(texture2d)(float,float,float,float) r7.xy, r3.yzyy, t3.xyzw, s2, cb0[142].y                      用基于世界坐标的随机 UV2 采样 HalfK_Normal
  71: mad r7.xy, r7.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
  72: dp2 r0.w, r7.xyxx, r7.xyxx
  73: add r0.w, -r0.w, l(1.0000)
  74: max r0.w, r0.w, l(0)
  75: sqrt r0.w, r0.w

  76: mul r10.x, r0.w, v1.x                                 求解值 * tangent.x
  77: mov r10.yz, -r7.xxyx                                  求解出 HalfK_Normal_2 -> 注意 x 通道是求解出来的 yz 通道是采样出来的

  78: min r7.xy, abs(v1.xzxx), l(1.0000, 1.0000, 0.0000, 0.0000)       min(tangent.xz, 1) -> rate
  79: add r10.xyz, -r8.xyzx, r10.xyzx
  80: mad r7.xzw, r7.xxxx, r10.xxyz, r8.xxyz                lerp(HalfK_Normal_1, HalfK_Normal_2, rate.x) -> HalfK_Normal_A

  81: sample_b(texture2d)(float,float,float,float) r8.xy, r3.xyxx, t3.xyzw, s2, cb0[142].y                      用基于世界坐标的随机 UV3 采样 HalfK_Normal
  82: mad r8.xy, r8.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
  83: dp2 r0.w, r8.xyxx, r8.xyxx
  84: add r0.w, -r0.w, l(1.0000)
  85: max r0.w, r0.w, l(0)
  86: sqrt r0.w, r0.w

  87: mov r8.xy, -r8.xyxx
  88: mul r8.z, r0.w, v1.z                                  求解出 HalfK_Normal_3  

  89: add r8.xyz, -r7.xzwx, r8.xyzx
  90: mad r7.xyz, r7.yyyy, r8.xyzx, r7.xzwx                 lerp(HalfK_Normal_A, HalfK_Normal_3, rate.y) -> HalfK_Normal_B
  91: dp3 r0.w, r7.xyzx, r7.xyzx
  92: sqrt r0.w, r0.w
  93: div r7.xyz, r7.xyzx, r0.wwww                          normalize(HalfK_Normal_B) -> HalfK_N

  94: dp3 r8.x, v0.xyzx, r7.xyzx
  95: dp3 r8.y, r0.xyzx, r7.xyzx
  96: dp3 r8.z, v1.xyzx, r7.xyzx                            (Dot(VertexNorm, HalfK_N), Dot(BitangentWS, HalfK_N), Dot(Tangent, HalfK_N)) -> HalfK_Norm

  97: mad r7.xyz, cb2[6].xyzx, r8.xyzx, r8.xyzx             [1,1,0] * HalfK_Norm + HalfK_Norm -> HalfK_Norm

  98: dp3 r0.w, v1.xyzx, cb2[9].xyzx                        Dot(Tangent, [0.27268, 0.00, 0.9621]) 
  99: mad r0.w, r0.w, l(0.5000), l(0.5000)                  ~ * 0.5 + 0.5
 100: mad_sat r0.w, r0.w, cb2[19].z, cb2[20].y              sat(~ * 2 - 1.36) -> rate

 101: add r7.xyz, -r4.xyzx, r7.xyzx
 102: mad r4.xyz, r0.wwww, r7.xyzx, r4.xyzx                 lerp(4K_Normal, HalfK_Norm, rate) -> norm

 103: mad r4.xyz, r4.xyzx, cb0[137].wwww, cb0[137].xyzx     norm * 1 + 0
 104: dp3 r0.w, r4.xyzx, r4.xyzx
 105: rsq r0.w, r0.w
 106: mul r4.xyz, r0.wwww, r4.xyzx                          norm = normalize(norm)  -> or local_norm

 107: mul r0.xyz, r0.xyzx, r4.yyyy
 108: mad r0.xyz, r4.xxxx, v0.xyzx, r0.xyzx
 109: mad r0.xyz, r4.zzzz, v1.xyzx, r0.xyzx                 mul(TBN, norm) 

 110: dp3 r0.w, r0.xyzx, r0.xyzx
 111: rsq r0.w, r0.w
 112: mul r0.xyz, r0.wwww, r0.xyzx                          norm = normalize(norm)


 113: sample_b(texture2d)(float,float,float,float) r4.xy, v2.xyxx, t4.zyxw, s3, cb0[142].y      拿 UV 采样 T_GodTreeStump01_Comp_Msk_Curv_AO 注意返回zy通道

 114: add r4.zw, -r4.xxxy, l(0.0000, 0.0000, 1.0000, 1.0000)            1 - (AO, Curv) -> r4 = (AO, Curv, 1-AO, 1-Curv)
 115: mad r0.w, cb2[20].w, r4.w, r4.y                                   0.5 * (1-Curv) + Curv
 116: mul r0.w, r0.w, r4.z                                              (0.5 * (1-Curv) + Curv) * (1-AO) = a
 117: add r1.w, -cb2[21].y, cb2[21].x                                   2 + (-(-1)) = 3
 118: mad_sat r7.x, r0.w, r1.w, cb2[21].y                               sat(a * 3 - 1) = b
 119: mov r7.yzw, l(0.0000, 1.0000, 0.0000, 0.5000)                     r7.xyzw = [b, 1, 0, 0.5]
 120: mul r8.xyz, r7.xxyx, cb1[0].yyyy                                  * 0 -> 0
 121: mul r7.xyz, r7.zwxz, r8.xyzx                                      0                 r7.x ~> b * switcher -> 本质是屏蔽后面一连串扰乱贴图效果

 122: mul r8.xyzw, v2.xyxy, l(10.0000, 10.0000, 0.1000, 0.1000)         (10 * UV, 0.1 * UV)
 123: mad r8.xy, cb0[141].zzzz, l(0.0100, 0.0050, 0.0000, 0.0000), r8.xyxx          47.1054 * (0.01, 0.005) + 10 * UV -> r8.xy

 124: sample_b(texture2d)(float,float,float,float) r0.w, r8.xyxx, t5.yzwx, s4, cb0[142].y       拿缩放和偏移后的 UV1 采样 WaterWave_Noise -> n1
 125: mad r8.xy, r0.wwww, l(0.0800, 0.0800, 0.0000, 0.0000), r8.zwzz                n1 * 0.08 + 0.1 * UV -> r8.xy
 126: mad r8.xy, cb0[141].zzzz, l(0.0500, 0.0100, 0.0000, 0.0000), r8.xyxx          47.1054 * (0.05, 0.01) + r8.xy -> r8.xy

 127: sample_b(texture2d)(float,float,float,float) r0.w, r8.xyxx, t6.yzwx, s5, cb0[142].y       拿缩放和偏移后的 UV2 采样 GoodCommon_Noise -> n2
 128: mad r8.xy, v2.xyxx, l(10.0000, 10.0000, 0.0000, 0.0000), r0.wwww              10 * UV + n2 -> r8.xy
 129: mad r8.xy, cb0[141].zzzz, l(0.0100, 0.0200, 0.0000, 0.0000), r8.xyxx          47.1054 * (0.01, 0.02) + r8.xy -> r8.xy

 130: sample_b(texture2d)(float,float,float,float) r0.w, r8.xyxx, t5.yzwx, s4, cb0[142].y       拿缩放和偏移后的 UV3 采样 WaterWave_Noise -> n3
 131: mul r8.xyz, r0.wwww, r7.xyzx                                      0
 132: mad r7.xyz, -r7.xyzx, r0.wwww, cb2[10].xyzx                       0
 133: mad r7.xyz, cb2[21].zzzz, r7.xyzx, r8.xyzx                        0

 134: mul r8.xy, v2.xyxx, cb2[21].wwww                                  14.06 * UV
 135: sample_b(texture2d)(float,float,float,float) r8.xyz, r8.xyxx, t7.xyzw, s6, cb0[142].y     拿放大14倍的UV采样 T_BarkTest_03_D 
 136: mul r8.xyz, r8.xyzx, cb2[22].xxxx                                 Bark_D * 2.57 -> Bark_D
 137: mul r10.xyz, r8.xyzx, cb2[12].xyzx                                (0.0625, 0.03371, 0.01582) * Bark_D -> Bark_D
 138: dp3 r0.w, r10.xyzx, l(0.3000, 0.5900, 0.1100, 0.0000)             lum(Bark_D)
 139: mad r8.xyz, -r8.xyzx, cb2[12].xyzx, r0.wwww                       lum(Bark_D) - Bark_D
 140: mad r8.xyz, cb2[22].yyyy, r8.xyzx, r10.xyzx                       Bark_D - 0.0095 * (lum(Bark_D) - Bark_D) -> Bark_D
 141: add r10.xyz, -r8.xyzx, l(1.0000, 1.0000, 1.0000, 0.0000)          1 - Bark_D
 142: add r10.xyz, r10.xyzx, r10.xyzx                                   2 * (1 - Bark_D) -> Re_Bark_D

 143: add r0.w, r4.y, l(-1.0000)                                        local_norm.y - 1
 144: mad r0.w, r0.w, l(0.6500), l(1.0000)                              
 145: add r1.w, -r0.w, l(1.0000)                                        1 - (1 + 0.65 * (local_norm.y - 1))
 146: mad r10.xyz, -r10.xyzx, r1.wwww, l(1, 1, 1, 0)                    1 - Re_Bark_D * ~ -> D_1

 147: mul r11.xyz, r0.wwww, r8.xyzx                                     (1 + 0.65 * (local_norm.y - 1)) * Bark_D
 148: add r11.xyz, r11.xyzx, r11.xyzx                                   2 * ~ -> D_2
 149: ge r8.xyz, r8.xyzx, l(0.5000, 0.5000, 0.5000, 0.0000)
 150: movc r8.xyz, r8.xyzx, r10.xyzx, r11.xyzx                          Bark_D = Bark_D >= 0.5 ? D_1 : D_2 

 151: max r0.w, r4.x, l(0.0000)
 152: log r0.w, r0.w
 153: mul r0.w, r0.w, cb2[22].z
 154: exp r0.w, r0.w                                                    local_norm.x ^ 2

 155: mul r10.xyz, r0.wwww, r8.xyzx                                     (local_norm.x ^ 2) * Bark_D

 156: sample_indexable(texture2d)(float,float,float,float) r11.xyz, r3.xzxx, t8.xyzw, s0        用基于世界坐标的随机 UV1 采样 1K_D 
 157: sample_indexable(texture2d)(float,float,float,float) r12.xyz, r3.yzyy, t8.xyzw, s0        用基于世界坐标的随机 UV2 采样 1K_D 
 158: add r12.xyz, -r11.xyzx, r12.xyzx
 159: mad r11.xyz, r9.xxxx, r12.xyzx, r11.xyzx                          lerp(1K_D_1, 1K_D_2, r9.x) -> 1K_D_1
 160: sample_indexable(texture2d)(float,float,float,float) r12.xyz, r3.xyxx, t8.xyzw, s0        用基于世界坐标的随机 UV3 采样 1K_D
 161: add r12.xyz, -r11.xyzx, r12.xyzx
 162: mad r11.xyz, r9.yyyy, r12.xyzx, r11.xyzx                          lerp(1K_D_1, 1K_D_3, r9.y) -> 1K_D_1

 163: mul r11.xyz, r11.xyzx, cb2[22].wwww                               1K_D * 2
 164: mul r11.xyz, r11.xyzx, cb2[14].xyzx                               (0.25818, 0.53948, 0.33716) * (1K_D * 2) -> 1K_D

 165: add r12.xyzw, v1.zxyz, l(1.0000, 0.0000, 0.0000, 1.0000)          (tangent.z+1, tangent.xy, tangent.z+1)
 166: mul r5.xyz, r5.xyzx, l(-1.0000, -1.0000, 1.0000, 0.0000)          4K_Normal * (-1, -1, 1)

 167: dp3 r1.w, r12.yzwy, r5.xyzx                                       Dot(tg.yzw, 4k_n)
 168: mul r5.xyz, r5.xyzx, r12.xxxx                                     4k_n * tg.x
 169: mad r5.xyz, r12.yzwy, r1.wwww, -r5.xyzx                           tg.yzw * Dot(tg.yzw, 4k_n) - 4k_n * tg.x -> N'
 170: dp3 r1.x, r5.xyzx, r1.xyzx                                        Dot(N', viewDir) -> NoV
 171: max r1.x, r1.x, l(0)                                              max(NoV, 0)
 172: add r1.x, -r1.x, l(1.0000)                                        
 173: max r1.x, abs(r1.x), l(0.0000)                                    abs(1 - max(NoV, 0)) -> c
 174: log r1.x, r1.x
 175: mul r1.x, r1.x, cb2[23].x
 176: exp r1.x, r1.x                                                    c ^ 2
 177: add r1.x, r1.x, l(0.4000)                                         c ^ 2 + 0.4 -> c

 178: mul r1.yzw, r1.xxxx, r11.xxyz                                     c * 1K_D -> 1K_D
 179: dp3 r2.w, r1.yzwy, l(0.3000, 0.5900, 0.1100, 0.0000)              lum(1K_D)
 180: mad r5.xyz, -r11.xyzx, r1.xxxx, r2.wwww                           lum(1K_D) - 1K_D
 181: mad r1.xyz, cb2[23].yyyy, r5.xyzx, r1.yzwy                        lerp(1K_D, lum(1K_D) - 1K_D, 0) -> 1K_D

 182: dp3 r1.w, r0.xyzx, cb2[9].xyzx                                    Dot(norm, (0.27268, 0.00, 0.9621)) -> NoL (推测这个Vector是LightDir)
 183: mad r1.w, r1.w, l(0.5000), l(0.5000)                              NoL = 0.5 * NoL + 0.5
 184: mad_sat r1.w, r1.w, cb2[19].z, cb2[20].y                          sat(2 * NoL - 1.36)
 185: mad r1.xyz, -r8.xyzx, r0.wwww, r1.xyzx                            1K_D - (local_norm.x ^ 2) * Bark_D -> 1K_Bark_D
 186: mad_sat r1.xyz, r1.wwww, r1.xyzx, r10.xyzx                        Final Diffuse =  1K_Bark_D * sat(2 * NoL - 1.36) + (local_norm.x ^ 2) * Bark_D

 187: sample_indexable(texture2d)(float,float,float,float) r0.w, r6.xzxx, t9.xzwy, s0     用基于世界坐标的随机 UV1 采样 T_BarkTest_03_comp_H_R_Ao_Msk -> Rgh
 188: sample_indexable(texture2d)(float,float,float,float) r2.w, r6.yzyy, t9.xzwy, s0     用基于世界坐标的随机 UV2 采样 T_BarkTest_03_comp_H_R_Ao_Msk
 189: add r2.w, -r0.w, r2.w 
 190: mad r0.w, r9.x, r2.w, r0.w                                        lerp(Rgh_1, Rgh_2, r9.x) -> Rgh_1
 191: sample_indexable(texture2d)(float,float,float,float) r2.w, r6.xyxx, t9.xzwy, s0     用基于世界坐标的随机 UV3 采样 T_BarkTest_03_comp_H_R_Ao_Msk
 192: add r2.w, -r0.w, r2.w
 193: mad r0.w, r9.y, r2.w, r0.w                                        lerp(Rgh_1, Rgh_3, r9.y) -> Rgh_1 -> Rgh

 194: mul r0.w, r0.w, cb2[24].x                                         5 * Rgh
 195: mad r2.w, r4.z, cb2[24].y, -r0.w                                  (1 - AO) * 4.9 - 5 * Rgh
 196: mad r0.w, r2.w, l(0.5000), r0.w                                   ~ * 0.5 + 5 * Rgh -> AO_R

 197: sample_indexable(texture2d)(float,float,float,float) r2.w, r3.xzxx, t10.xzwy, s0     用基于世界坐标的随机 UV1 采样 T_Moss_01_Comp_H_R_Ao 的通道 #2
 198: sample_indexable(texture2d)(float,float,float,float) r3.z, r3.yzyy, t10.xzyw, s0     用基于世界坐标的随机 UV2 采样 T_Moss_01_Comp_H_R_Ao 的通道 #2
 199: add r3.z, -r2.w, r3.z
 200: mad r2.w, r9.x, r3.z, r2.w                                        lerp(r_1, r_2, r9.x)
 201: sample_indexable(texture2d)(float,float,float,float) r3.x, r3.xyxx, t10.yxzw, s0     用基于世界坐标的随机 UV3 采样 T_Moss_01_Comp_H_R_Ao 的通道 #2
 202: add r3.x, -r2.w, r3.x
 203: mad r2.w, r9.y, r3.x, r2.w                                        lerp(r_1, r_3, r9.y) -> r_1

 204: mad r2.w, r2.w, cb2[24].z, -r0.w                                  2 * r_1 - AO_R
 205: mad_sat r0.w, r1.w, r2.w, r0.w                                    sat(2 * NoL - 1.36) * (2 * r_1 - AO_R) + AO_R -> AO_R_r

 206: mov_sat r3.xy, cb2[23].zwzz                                       (0, 0.03)   -> 对应了(Metallic, Dialetric)
 207: mov_sat r4.x, r4.x                                                sat(local_norm.x)

 208: mad o2.z, r0.w, cb0[138].y, cb0[138].x                            Final Roughness = AO_R_r * 1 + 0

 209: imad r0.w, v3.x, l(35), l(20)                                     SV_InstanceID * 35 + 20
 210: ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) o1.w, r0.w, l(4), t0.xxxx         Final Mask = 0

 211: mul r0.w, r3.y, l(0.0800)                                         0.03 * 0.08 -> Dialetric * 0.08 = DielectricSpecular
                                                                        或者对应方法： DielectricSpecularToF0(float Specular)

 212: mad r4.yzw, -r3.yyyy, l(0.0000, 0.0800, 0.0800, 0.0800), r1.xxyz  Final Diffuse - F0 其中 F0 = 0.08 * 0.03
 213: mad r4.yzw, r3.xxxx, r4.yyzw, r0.wwww                             Metallic(0) * ~ + 0.03 * 0.08 = (0.0024, 0.0024, 0.0024) -> ComputeF0函数 
 214: mad r5.xyz, -r1.xyzx, r3.xxxx, r1.xyzx                            Final Diffuse - (Final Diffuse * Metallic) -> Final Diffuse'
 215: mad r5.xyz, r5.xyzx, cb0[135].wwww, cb0[135].xyzx                 Final Diffuse' * 1 + 0
 216: mad r4.yzw, r4.yyzw, cb0[136].wwww, cb0[136].xxyz                 (0.0024, 0.0024, 0.0024) * 1 + 0

 217: ne r0.w, l(0, 0, 0, 0), cb0[177].w                                0 != 0 ? false
 218: mad r6.xyz, r4.yzwy, l(0.4500, 0.4500, 0.4500, 0.0000), r5.xyzx   (0.0024, 0.0024, 0.0024) * 0.45 + Final Diffuse'
 219: movc r5.xyz, r0.wwww, r6.xyzx, r5.xyzx                            Final Diffuse'
 220: movc r4.yzw, r0.wwww, l(0, 0, 0, 0), r4.yyzw                      (0.0024, 0.0024, 0.0024)

//参考 UnrealEngine-4.25\Engine\Shaders\Private\BasePassPixelShader.usf -> AOMultiBounce 方法 
 221: dp3 r0.w, r4.yzwy, l(0.3000, 0.5900, 0.1100, 0.0000)              lum((0.0024, 0.0024, 0.0024))
 222: mad r6.xyz, r0.wwww, l(2.0404, -4.7951, 2.7552, 0.0000), l(-0.3324, 0.6417, 0.6903, 0.0000)     ~ * const_1 + const_2 -> c
 223: mad r0.w, r4.x, r6.x, r6.y                                        sat(local_norm.x) * c.x + c.y
 224: mad r0.w, r0.w, r4.x, r6.z                                        ~ * sat(local_norm.x) + c.z
 225: mul r0.w, r4.x, r0.w                                              ~ * sat(local_norm.x)
 226: max o3.w, r0.w, r4.x                                              Final Diffuse_AO = max(~, sat(local_norm.x))  

((a * c.x + c.y) * a + c.z) * a = a^3*c.x + a^2*c.y + a*c.z


 227: mad r4.xyz, r4.yzwy, l(0.4500, 0.4500, 0.4500, 0.0000), r5.xyzx
 228: max r5.xyz, r7.xyzx, l(0, 0, 0, 0)

 229: lt r0.w, l(0), cb0[139].x                 0 < 0 ? -> false
 230: if_nz r0.w                                -> 推测判断材质是否自发光 
 231:   imad r3.zw, v3.xxxx, l(0, 0, 35, 35), l(0, 0, 5, 19)
 232:   ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r6.xyz, r3.z, l(0), t0.xyzx
 233:   add r6.xyz, r2.xyzx, -r6.xyzx
 234:   ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r7.xyz, r3.w, l(0), t0.xyzx
 235:   add r7.xyz, r7.xyzx, l(1.0000, 1.0000, 1.0000, 0.0000)
 236:   lt r6.xyz, r7.xyzx, abs(r6.xyzx)
 237:   or r0.w, r6.y, r6.x
 238:   or r0.w, r6.z, r0.w
 239:   dp3 r1.w, r2.xyzx, l(0.5770, 0.5770, 0.5770, 0.0000)            (0.577,0.577,0.577)是一个归一化后的单位向量 
 240:   mul r1.w, r1.w, l(0.0020)
 241:   frc r1.w, r1.w
 242:   lt r1.w, l(0.5000), r1.w
 243:   movc r2.xyz, r1.wwww, l(0.0000, 1.0000, 1.0000, 0.0000), l(1.0000, 1.0000, 0.0000, 0.0000)
 244:   movc r5.xyz, r0.wwww, r2.xyzx, r5.xyzx
 245: endif

 246: mad r2.xyz, cb0[144].yyyy, r4.xyzx, r5.xyzx           cb0[144].y == 0 -> r5.xyz + 0

 247: mad o1.xyz, r0.xyzx, l(0.5, 0.5, 0.5, 0), l(0.5, 0.5, 0.5, 0)       Norm * 0.5 + 0.5 -> 转到[0, 1]区间
 248: mul o0.xyz, r2.xyzx, cb0[134].yyyy        DONE  -> Emition = 0
 249: mov o0.w, l(0)                            DONE
 250: mov o2.w, l(0.6941)                       DONE  -> Flag
 251: mov o2.xy, r3.xyxx                        DONE  -> M_D_
 252: mov o3.xyz, r1.xyzx                       Diffuse
 253: mov o4.xyzw, l(0, 0, 0, 0)                DONE
 254: ret
