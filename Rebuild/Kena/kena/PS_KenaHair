PS_KenaHair

Shader hash f5bd91e6-037b1389-7ca21366-05f2fe5a

ps_5_0
      dcl_globalFlags refactoringAllowed
      dcl_constantbuffer cb0[178], immediateIndexed
      dcl_constantbuffer cb1[21], immediateIndexed
      dcl_constantbuffer cb2[1], immediateIndexed
      dcl_constantbuffer cb3[5], immediateIndexed
      dcl_constantbuffer cb4[24], immediateIndexed
      dcl_sampler s0, mode_default
      dcl_sampler s1, mode_default
      dcl_sampler s2, mode_default

      dcl_resource_texture2d (float,float,float,float) t0               hair_DEPTH
      dcl_resource_texture2d (float,float,float,float) t1               Noise_cloudsmed
      dcl_resource_texture2d (float,float,float,float) t2               hair_ROOT
      dcl_resource_texture2d (float,float,float,float) t3               Good64x64TilingNoiseHighFreq
      dcl_resource_texture2d (float,float,float,float) t4               hair_DEPTH
      dcl_resource_texture2d (float,float,float,float) t5               hair_ALPHA

      dcl_input_ps linear centroid v0.xyz                               Tangent
      dcl_input_ps linear centroid v1.xyzw                              Normal + Sign
      dcl_input_ps linear v2.xy                                         UV
      dcl_input_ps linear v3.xy
      dcl_input_ps linear v4.x
      dcl_input_ps_siv linear noperspective centroid v5.xyzw, position
      dcl_input_ps_sgv nointerpolation v6.x, isfrontface

      dcl_output o0.xyzw                CameraColor
      dcl_output o1.xyzw                Normal
      dcl_output o2.xyzw                M_D_R_I
      dcl_output o3.xyzw                Diffuse
      dcl_output o4.xyzw                Custom
      dcl_output oDepthLessEqual
      dcl_temps 10

   0: mul r0.xyz, v0.yzxy, v1.zxyz
   1: mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx
   2: mul r0.xyz, r0.xyzx, v1.wwww                          BitangentWS = cross(TangentWS, NormalWS) * sign

   3: mov r1.x, v5.z
   4: mov r1.y, l(1.0000)                                   (NDC.z, 1)
   5: mul r1.xy, r1.xyxx, v5.wwww                           (NDC.z, 1) * EyeDepth -> 对Reflection分支起作用，主体内无效 

   6: mul r2.xyzw, v5.yyyy, cb0[45].xyzw
   7: mad r2.xyzw, v5.xxxx, cb0[44].xyzw, r2.xyzw
   8: mad r2.xyzw, v5.zzzz, cb0[46].xyzw, r2.xyzw
   9: add r2.xyzw, r2.xyzw, cb0[47].xyzw
  10: div r2.xyz, r2.xyzx, r2.wwww                          PosWS' -> 缺少最后的仿射平移 

  11: dp3 r0.w, -r2.xyzx, -r2.xyzx
  12: rsq r0.w, r0.w
  13: mul r3.xyz, r0.wwww, -r2.xyzx                         Normalize(PosWS') = viewDirWS 

  14: mul r0.w, cb0[140].w, cb1[4].w                        flag -> dont flip norm -> true -> 1

  15: movc r1.z, v6.x, l(1.0000), l(-1.0000)
  16: mul r0.w, r0.w, r1.z                                  flip boolean -> signed_dir

  17: sample_b(texture2d)(float,float,float,float) r1.z, v2.xyxx, t0.yzxw, s0, cb4[18].x              Sample hair_DEPTH

  18: add r4.xyz, cb4[3].xyzx, -cb4[4].xyzx                 TangentB(0,0,-0.3);TangentA(0,0,0.3)
  19: mad r4.xyz, r1.zzzz, r4.xyzx, cb4[4].xyzx             TangentAB = lerp(TangentA, TangentB, hair_DEPTH)

  20: add r4.xyz, r4.xyzx, cb4[6].xyzx          TangentTS = TangentAB + TangentC(0,-1,0) -> 注意，在UE语境中，y周位于模型空间的水平面上 
  21: dp3 r1.z, r4.xyzx, r4.xyzx
  22: sqrt r1.z, r1.z
  23: div r4.xyz, r4.xyzx, r1.zzzz                          Normalize(TangentTS)

  24: mad r4.xyz, r4.xyzx, cb0[137].wwww, cb0[137].xyzx     TangentTS * GlobalNormalScaler + GlobalNormalBias
  25: dp3 r1.z, r4.xyzx, r4.xyzx
  26: rsq r1.z, r1.z
  27: mul r4.xyz, r1.zzzz, r4.xyzx                          Normalize(TangentTS)    -> 在Hair计算中，以头发朝向的Tangent替代正常Normal 

  28: mul r0.xyz, r0.xyzx, r4.yyyy
  29: mad r0.xyz, r4.xxxx, v0.xyzx, r0.xyzx
  30: mad r0.xyz, r4.zzzz, v1.xyzx, r0.xyzx
  31: dp3 r1.z, r0.xyzx, r0.xyzx
  32: rsq r1.z, r1.z
  33: mul r0.xyz, r0.xyzx, r1.zzzz                          nDirWS = normalize(mul(TangentTS, tbn)) -> 依据习惯，任然记作 nDirWS

  34: mul r0.xyz, r0.wwww, r0.xyzx                          nDirWS *= Sign

  35: lt r0.w, l(0.0000), abs(cb4[19].x)                    0 < cb4[19].x=0 ? -> false -> ConditionD
  36: ge r1.z, cb4[19].x, l(0)                              0 >= 0 ? -> true -> 0xFFFFFFFF -> ConditionC
  37: and r1.w, r1.z, cb4[19].z                             0xFFFFFFFF & cb4[19].z=0.02 -> 0.02
  38: and r1.w, r0.w, r1.w                                  0.02 & 0x00000000 -> 0 -> noise_base

  39: mul r4.xy, v2.xyxx, cb4[19].wwww                      UV * 1
  40: sample_b(texture2d)(float,float,float,float) r2.w, r4.xyxx, t1.yzwx, s1, cb0[142].y       Sample Noise_cloudsmed
  41: add r3.w, r1.w, -r2.w                                 noise_base - noise
  42: lt r3.w, l(0.0000), abs(r3.w)                         0 < abs(~)  -> 除非等于0，不然都是true -> 0xFFFFFFFF -> ConditionA

  43: ge r1.w, r1.w, r2.w                       noise_base >= noise -> 在noise_base=0的情况下，基本都是 false -> 0x00000000 -> ConditionB
  44: and r4.xyz, r1.wwww, cb4[11].xyzx                     
  45: and r4.xyz, r3.wwww, r4.xyzx                          ConditionA & (ConditionB & GlowColor(0,0.5,1)) -> 0 = GlowColor'
  46: mad r4.xyz, r4.xyzx, cb4[20].xxxx, cb4[12].xyzx       
                                          Emissive = DissolveEmissiveAmount=cb4[20].x=50 * GlowColor' + EmissiveTint=cb4[12].xyz=(0,0,0)

  47: add r5.xyz, -r4.xyzx, cb4[13].xyzx
  48: mad r4.xyz, cb4[20].yyyy, r5.xyzx, r4.xyzx            lerp(Emissive, _Emissive_Color, cb4[20].y=0) -> 0 -> EmitCol

  49: sample_indexable(texture2d)(float,float,float,float) r1.w, v2.xyxx, t2.yzwx, s0           Sample hair_ROOT 

  50: add r5.xyz, cb4[16].xyzx, -cb4[17].xyzx               TipColor(0.020897, 0.028864, 0.045139) - RootColor(0.011024, 0.012202, 0.020833)
  51: mad r5.xyz, r1.wwww, r5.xyzx, cb4[17].xyzx            lerp(RootColor, TipColor, hair_ROOT.x)
                                                            用UV确定当前位置属于hair_root还是hair_tip，从而决定对应色调 -> HairColor

  52: mul r6.xy, v2.xyxx, cb4[20].zzzz                      UV * Noisetiling=24
  53: sample_indexable(texture2d)(float,float,float,float) r3.w, r6.xyxx, t3.yzwx, s0           Sample Good64x64Noise -> n64
  54: mad r5.xyz, r5.xyzx, r3.wwww, r5.xyzx                 HairColor * (n64 + 1)
  55: mul r5.xyz, r5.xyzx, cb4[20].wwww                     HairColor * cb4[20].w=0(Brightness)
  56: max r5.xyz, r5.xyzx, l(0.0010, 0.0010, 0.0010, 0.0000)      HairColor = max(HairColor, 0.001)
  57: min r5.xyz, r5.xyzx, l(0.9990, 0.9990, 0.9990, 0.0000)      HairColor = min(HairColor, 0.999) -> dBase

  58: max r3.w, cb3[0].z, l(0)                              max(cb3[0].z=0, 0)      -> MinWet(0)
  59: min r3.w, r3.w, cb4[21].z                             min(~, cb4[21].z=0.7)   -> MaxWet(0.7)
  60: add r3.w, r3.w, l(-1.0000)                            WetA - 1 = -1

  61: max r6.xy, cb3[1].xyxx, l(0,0,0,0)                    max((0,0), (0,0.00001)) -> (0, 0.00001)
  62: min r4.w, r6.x, cb4[21].z                             min(0, MaxWet) -> 0
  63: add r4.w, r4.w, l(-1.0000)                            WetB - 1 = -1

  64: mul r6.xzw, v3.yyyy, cb1[1].xxyz
  65: mad r6.xzw, v3.xxxx, cb1[0].xxyz, r6.xxzw
  66: mad r6.xzw, v4.xxxx, cb1[2].xxyz, r6.xxzw
  67: add r6.xzw, r6.xxzw, cb1[3].xxyz                      PosWS

  68: add r6.xzw, r6.xxzw, -cb3[4].xxyz                     PosWS - CameraPosWS = -V
  69: dp3 r5.w, r6.xzwx, r6.xzwx
  70: sqrt r5.w, r5.w                                       Distance(V)

  71: div r6.x, l(1.0000, 1.0000, 1.0000, 1.0000), r6.y     1 / 0.00001 = 100000
  72: mad r5.w, -r5.w, r6.x, l(1.0000)                      1 - Dist * 100000
  73: mul_sat r5.w, r5.w, l(6.6667)                         saturate(-1.0E+7 * 6.667) -> 0

  74: add r4.w, abs(r4.w), -r5.w                            abs(WetB=-1) - 0 = 1
  75: add r4.w, r4.w, l(1.0000)                             1 + 1 = 2
  76: min r4.w, r4.w, l(1.0000)                             min(2, 1) -> 1

  77: mul r3.w, abs(r3.w), r4.w                             abs(WetA=-1) * 1 = 1
  78: mul_sat r3.w, r3.w, cb4[21].w                         R = saturate(1 * cb4[21].w=0.35) -> Roughness=cb4[21].w=0.35 

  79: add r4.w, -r2.w, cb4[19].x                            cb4[19].x=0 - noise -> RefractionDepthBias = 0?
  80: lt r4.w, l(0.0000), abs(r4.w)                         0 < abs(~) -> 大概率是 0xFFFFFFFF -> BooleanA
  81: ge r2.w, cb4[19].x, r2.w                              RefractionDepthBias >= noise -> 大概率是 0x00000000 -> BooleanB
  82: movc r2.w, r2.w, l(0), l(1.0000)                      BooleanB ? 0 : 1 -> ValA(非0既1) -> 大概率1
  83: and r2.w, r2.w, r4.w                                  ValA & BooleanA -> 大概率还是ValA(非0既1) -> 大概率1
  84: movc r1.z, r1.z, r2.w, l(1.0000)                      ConditionC ? (~) : 1 -> 大概率(~) -> 1
  85: movc r0.w, r0.w, r1.z, l(1.0000)                      ConditionD ? (~) : 1 -> 大概率1 -> 1 -> ConditionValA

  86: sample_indexable(texture2d)(float,float,float,float) r1.z, v2.xyxx, t4.yzxw, s0     Sampel hair_DEPTH
  87: max r2.w, r1.z, l(0.0000)                             max(hair_DEPTH.x, 0) -> 确保Depth不小于0
  88: mul r4.w, r2.w, r2.w                                  pow2(hair_DEPTH)

  89: dp3 r5.w, r3.xyzx, v1.xyzx                            Dot(N, V) in world space
  90: mul r5.w, abs(r5.w), l(1.5000)                        1.5 * abs(NoV) -> NoV
  91: add r6.x, -cb4[22].z, cb4[22].y                       cb4[22].y=2 - cb4[22].z=-1 -> Fringe(2) - MipBias(-1)
  92: mad_sat r5.w, r5.w, r6.x, cb4[22].z                   saturate(lerp(MipBias, Fringe, NoV))  -> 注意这里最大值为1

  93: add r6.x, -cb4[22].w, l(1.0000)                       1 - DyeRoughness(0.5)
  94: mad r5.w, r5.w, r6.x, cb4[22].w                       lerp(DyeRoughness, 1, lerp(...))
  95: mad r2.w, -r2.w, r2.w, l(1.0000)
  96: mad r2.w, r5.w, r2.w, r4.w                            lerp(pow2(hair_DEPTH), 1, lerp(...)) -> 3次连续lerp -> 某种 HairDepthValue

  97: sample_b(texture2d)(float,float,float,float) r4.w, v2.xyxx, t5.yzwx, s0, cb4[18].x        Sample hair_ALPHA
  98: mul r2.w, r2.w, r4.w                                  Soft_HairDepth = HairDepthValue * hair_ALPHA

//利用hair_ALPHA修正深度
  99: add r6.xy, v5.xyxx, -cb0[129].xyxx                    vertex.xy - 0
 100: add r6.zw, r6.xxxy, cb0[151].xxxx                     vertex.zw = vertex.xy + 4
 101: ftou r6.zw, r6.zzzw                                   uint(~) -> pixelId.xy
 102: ishl r4.w, r6.w, l(1)
 103: iadd r4.w, r4.w, r6.z                                 pixelId.y * 2 + pixelId.x
 104: udiv null, r4.w, r4.w, l(5)                           (~) mod with 5 
 105: utof r4.w, r4.w                                       float(mod) -> mod_val -> range form 0 ~ 4

 106: ge r5.w, cb0[141].z, -cb0[141].z                      cb0[141].z=14.6236 >= 0 ? true -> 0xFFFFFFFF -> ConditionE
 107: frc r6.z, abs(cb0[141].z)                             frac(cb0[141].z)  -> 推测为Time.x
 108: movc r5.w, r5.w, r6.z, -r6.z                          ConditionE ? time_frc : -time_frc
 109: mul r5.w, r5.w, l(0.1000)                             time_frc * 0.1

 110: mad r6.xy, r6.xyxx, l(0.0156, 0.0156, 0.0000, 0.0000), r5.wwww                            vertex.xy / 64 + time_frc
 111: sample_b(texture2d)(float,float,float,float) r5.w, r6.xyxx, t3.yzwx, s2, cb0[142].y       Sample Good64x64Noise -> n64_2
 112: add r4.w, r4.w, r5.w                                  mod_val += n64_2
 113: mad r1.z, r4.w, l(0.1667), -r1.z                      hair_DEPTH = mod_val * 0.1667 - hair_DEPTH
 114: add r1.z, r1.z, l(0.5000)                             hair_DEPTH += 0.5
 115: mad r1.z, r1.z, cb4[23].w, r1.y                       hair_DEPTH = hair_DEPTH * cb4[23].w=1 + EyeDepth; 其中 PixelDepthOffset=1
 116: div r1.z, r1.x, r1.z                                  shifted_NDCz = NDC.z * EyeDepth / hair_DEPTH
 117: min r1.z, r1.z, v5.z                                  shifted_NDCz = min(shifted_NDCz, NDC.z)
                                                            用于输出到 oDepthLessEqual 

//判断是否 Dissolve 
//推测cb2[0].x == DissolveAmount
 118: ne r4.w, cb2[0].x, l(0)                               cb2[0].x=0 != 0 ? false -> BooleanC
 119: lt r5.w, l(0.0010), abs(cb2[0].x)                     0.001 < abs(cb2[0].x=0) ? false -> BooleanD
 120: and r4.w, r4.w, r5.w                                  BooleanC & BooleanD -> false 

 121: round_ni r6.xy, v5.xyxx                               round(vertex.xy) -> 向下取整
 122: dp2 r5.w, r6.xyxx, l(347.8345, 3343.2837, 0, 0)       round_xy dot (347.8345, 3343.2837)
 123: sincos null, r5.w, r5.w                               cos(~)
 124: mul r5.w, r5.w, l(1000.0000)                          1000 * (~)
 125: frc r5.w, r5.w                                        frac(~) -> frac_val
 126: lt r6.x, cb2[0].x, l(0)                               cb2[0].x=0 < 0 ? false -> BooleanE
 127: add r6.y, cb2[0].x, l(1.0000)                         cb2[0].x=0 + 1
 128: lt r6.y, r5.w, r6.y                                   frac_val < (~)=1 ? true -> BooleanF
 129: lt r5.w, cb2[0].x, r5.w                               cb2[0].x=0 < frac_val ? true -> BooleanG
 130: movc r5.w, r6.x, r6.y, r5.w                           BooleanE ? BooleanF : BooleanG -> BooleanH -> true
 131: ieq r5.w, r5.w, l(0)                                  BooleanH == 0 ? false -> 0x00000000 -> BooleanI
 132: and r4.w, r4.w, r5.w                                  (BooleanC & BooleanD) & BooleanI -> false
 133: discard_nz r4.w                                       如果 not_zero 那么就丢弃 -> 不丢弃

 134: mad r0.w, r0.w, r2.w, l(-0.3300)                      Threshold = ConditionValA * Soft_HairDepth - 0.33
 135: lt r0.w, r0.w, l(0)                                   Threshold < 0 ? true(0xFFFF) or false(0X0000)
 136: discard_nz r0.w                                       如果不为0 则丢弃

 137: mov_sat r6.xy, cb4[21].xyxx                           saturate(Scatter=0.36127, Spec=0.2) -> Scatter对应了Metallic 

 138: mad o2.z, r3.w, cb0[138].y, cb0[138].x                R * _GlobalRoughnessScaler + _GlobalRoughnessBias

 139: dp3 r0.w, l(1, 1, 1, 0), abs(r0.xyzx)                 dot(nDirWS.xyz, (1,1,1)) -> sum(nDirWS.xyz)
 140: div r6.zw, r0.xxxy, r0.wwww                           nXY = nDirWS.xy / sum(nDirWS.xyz)
 141: ge r0.w, l(0), r0.z                                   0 >= nDirWS.z (注意，在Unity中使用y分量，代表Vertical) -> ConditionIsDownword
 142: add r7.xy, -abs(r6.wzww), l(1.0000, 1.0000, 0, 0)     1 - nXY.yx
 143: ge r7.zw, r6.zzzw, l(0, 0, 0, 0)                      nXY.xy > 0 ? -> ConditionXY
 144: movc r7.zw, r7.zzzw, l(0, 0, 1, 1), l(0, 0, -1, -1)   ConditionXY.xy ? 1 : -1 -> SignXY
 145: mul r7.xy, r7.zwzz, r7.xyxx                           SignXY.xy * (1 - nXY.yx) -> (SignXY.x*(1-nXY.y), SignXY.y*(1-nXY.x)) -> FixXY
 146: movc r6.zw, r0.wwww, r7.xxxy, r6.zzzw                 ConditionIsDownword ? FixXY : nXY -> FinalNormXY
 147: mad o4.xy, r6.zwzz, l(0.5, 0.5, 0, 0), l(0.5, 0.5, 0, 0)    CustomData.xy = FinalNormXY * 0.5 + 0.5

 148: max r0.w, r1.w, l(0.0000)                             hairRoot = max(hair_ROOT.x, 0.00001)
 149: log r0.w, r0.w
 150: mul r0.w, r0.w, cb4[23].x                             推测 TipPower = cb4[23].x = 1
 151: exp r0.w, r0.w                                        hairRoot = pow(hairRoot, 1)
 152: add r1.w, -cb4[23].z, cb4[23].y                       OcclusionAmtRootTip=cb4[23].y=0.8; OcclusionAmtRoot=cb4[23].z=0
 153: mad_sat o4.z, r0.w, r1.w, cb4[23].z                   CustomData.z = lerp(OcclusionAmtRoot, OcclusionAmtRootTip, hairRoot)

 154: mul r0.w, r6.y, l(0.0800)                             Spec = r6.y
 155: mad r7.xyz, -r6.yyyy, l(0.08, 0.08, 0.08, 0), r5.xyzx 
 156: mad r7.xyz, r6.xxxx, r7.xyzx, r0.wwww                 SpecCol = ComputeF0(Spec, dBase, Scatter)

 157: mad r8.xyz, -r5.xyzx, r6.xxxx, r5.xyzx                BaseCol = dBase * (1 - Scatter)
 158: mad r8.xyz, r8.xyzx, cb0[135].wwww, cb0[135].xyzx     BaseCol * _GlobalBaseColScaler + _GlobalBaseColBias
 159: mad r7.xyz, r7.xyzx, cb0[136].wwww, cb0[136].xyzx     SpecCol * _GlobalSpecColScaler + _GlobalSpecColBias

 160: ne r0.w, l(0, 0, 0, 0), cb0[177].w                    0 != 0 ? -> false -> not View.RenderingReflectionCaptureMask
 161: mad r9.xyz, r7.xyzx, l(0.4500, 0.4500, 0.4500, 0.0000), r8.xyzx
 162: movc r8.xyz, r0.wwww, r9.xyzx, r8.xyzx
 163: movc r7.xyz, r0.wwww, l(0, 0, 0, 0), r7.xyzx          EnvBRDFApproxFullyRough(BaseCol, SpecCol)

 164: dp3 r0.w, r7.xyzx, l(0.3000, 0.5900, 0.1100, 0.0000)
 165: mad r1.w, r0.w, l(2.0404), l(-0.3324)
 166: mad r1.w, r0.w, l(-4.7951), r1.w
 167: mad r0.w, r0.w, l(2.7552), r1.w
 168: add r0.w, r0.w, l(1.3320)
 169: max o3.w, r0.w, l(1.0000)                             FinalAO = AOMultiBounce(Luminance(SpecCol), baseAo=1)

 170: mad r7.xyz, r7.xyzx, l(0.4500, 0.4500, 0.4500, 0.0000), r8.xyzx
                                                            EnvBRDFApproxFullyRough(BaseCol, SpecCol) -> ReflectionCol
 171: max r4.xyz, r4.xyzx, l(0, 0, 0, 0)                    FinalEmit = max(EmitCol, 0)

 172: lt r0.w, l(0), cb0[139].x
 173: if_nz r0.w
 174:   add r2.xyz, r2.xyzx, -cb0[70].xyzx
 175:   mad r0.w, -r1.z, r1.y, r1.x
 176:   div r0.w, r0.w, r1.z
 177:   mad r1.xyw, r3.xyxz, r0.wwww, r2.xyxz
 178:   add r2.xyz, r1.xywx, -cb1[5].xyzx
 179:   add r3.xyz, cb1[19].xyzx, l(1.0000, 1.0000, 1.0000, 0.0000)
 180:   lt r2.xyz, r3.xyzx, abs(r2.xyzx)
 181:   or r0.w, r2.y, r2.x
 182:   or r0.w, r2.z, r0.w
 183:   dp3 r1.x, r1.xywx, l(0.5770, 0.5770, 0.5770, 0.0000)
 184:   mul r1.x, r1.x, l(0.0020)
 185:   frc r1.x, r1.x
 186:   lt r1.x, l(0.5000), r1.x
 187:   movc r1.xyw, r1.xxxx, l(0.0000, 1.0000, 0.0000, 1.0000), l(1.0000, 1.0000, 0.0000, 0.0000)
 188:   movc r4.xyz, r0.wwww, r1.xywx, r4.xyzx
 189: endif

 190: mad r1.xyw, cb0[144].yyyy, r7.xyxz, r4.xyxz     _GlobalRelectionAmount * ReflectionCol + FinalEmit = BaseRTCol
 191: mad o1.xyz, r0.xyzx, l(0.5, 0.5, 0.5, 0), l(0.5, 0.5, 0.5, 0)     nDirWS * 0.5 + 0.5
 192: mul o0.xyz, r1.xywx, cb0[134].yyyy              BaseRTCol * _GlobalBouncingColorIntensity
 193: mov o0.w, l(0)                                  Intensity = 0
 194: mov o1.w, cb1[20].y                             cb1[20].y=0.6667 -> Ao
 195: mov o2.w, l(0.6549)                             Flag = 167.0f / 255.0f
 196: mov o2.xy, r6.xyxx                              (Scatter, Spec)
 197: mov o3.xyz, r5.xyzx                             dBase
 198: mov o4.w, l(0)                                  CustomData.w = 0
 199: mov oDepthLessEqual, r1.z                       new Depth -> shifted_NDCz
 200: ret
