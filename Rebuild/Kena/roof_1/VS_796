VS
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// ATTRIBUTE                0   xyzw        0     NONE   float   xyz 
// ATTRIBUTE               13   x           1     NONE    uint   x   
// SV_VertexID              0   x           2   VERTID    uint   x   
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// TEXCOORD                10   xyzw        0     NONE   float   xyzw
// TEXCOORD                11   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xyzw        2     NONE   float   xyzw
// PRIMITIVE_ID             0   x           3     NONE    uint   x   
// SV_POSITION              0   xyzw        4      POS   float   xyzw
// SV_ClipDistance          0   x           5  CLIPDST   float   x   
//
vs_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[128], immediateIndexed
dcl_constantbuffer CB1[1], immediateIndexed
dcl_resource_structured t0, 16
dcl_resource_buffer (float,float,float,float) t1  	-> 使用 half2 格式查看数据 -> 里面存放的应该是 UV 
dcl_resource_buffer (float,float,float,float) t2  	-> 似乎是用来存放顶点关联的向量数据，比如某个顶点的 vertexId，拿vid*2索引normal，拿vid*2+1索引tangent
------输入
dcl_input v0.xyz                      v0 -> 顶点 
dcl_input v1.x                        v1 -> 索引 -> PRIMITIVE_ID 
dcl_input_sgv v2.x, vertex_id         v2 -> SV_VertexID 
------输出
dcl_output o0.xyzw   10 			  o0 -> xyz -> NormalWS 
dcl_output o1.xyzw   11   			  o1 -> xyz -> TangentWS 
dcl_output o2.xyzw    0 			  o2 -> [uv,0,0] 既前两位 xy 记录了 uv 
dcl_output o3.x                       o3 -> PRIMITIVE_ID -> 就是 v1.x 
dcl_output_siv o4.xyzw, position      o4 -> POS 
dcl_output_siv o5.x, clip_distance    o5 -> distance 
dcl_temps 9
o0.w = 0
r0.x = v2.x + cb1[0].w    	<-- 考虑到 r0.x 后续将用于索引，这里参与计算的都应当认为是int类型数值 cb1[0].w = 12960 
r0.y = r0.x << 1  			<-- r0.y = 索引值 r0.x * 2 也是个索引  
r0.yzw = t2[r0.y].xyz       <-- r0.yzw 来自用指令 ‘ld_structured’ 从 t2 缓冲中提取的 -> 一个向量 
r1.x = r0.x << 1 + 1    	<-- r1.x 索引 == r0.x * 2 + 1
r0.x = r0.x * cb1[0].y  	<-- r0.x 此时是索引 cb1[0].y = 50
r1.yz = t1[r0.x].xy    		从t1缓冲中索引到的xy分量 似乎是一种uv 直接输出到了 o2.xy 寄存器中流向了 fs 阶段 
o2.xy = r1.yz 
r1.xyzw = t2[r1.x].xyzw					r1来自ld_structured t2缓冲 -> 是一个向量，其中w分量表示朝向 
r2.xyz = r0.yzw * r1.yzx
r0.xyz = r1.xyz * r0.zwy - r2.xyzx   	求r0和r1的叉乘 -> 赋值给r0
mul r0.xyz, r1.wwww, r0.xyzx 		 	修正叉乘向量的朝向 -> 副切朝向？ 
mul r2.xyz, r1.yzxy, r0.xyzx
mad r0.xyz, r0.zxyz, r1.zxyz, -r2.xyzx  再次求r0和r1的叉乘  -> 赋值给r0
mul r0.xyz, r1.wwww, r0.xyzx		 	修正朝向 	->  r0.xyz = NORMAL; r1.xyz = TANGENT

imad r2.xyzw, v1.xxxx, l(35, 35, 35, 35), l(1, 2, 4, 3)
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r3.xyz, r2.x, l(0), t0.xyzx
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r4.xyzw, r2.z, l(0), t0.xyzw	     r4 向量通过索引获得，w应该是朝向  
mul r5.xyz, r3.xyzx, r4.yyyy		r3是变换矩阵中的一列，分别作用到了向量 r4 的 y 分量上，以及模型顶点 v0 的 y分量上 
mul r3.xyz, r3.xyzx, v0.yyyy		这里变换了 v0.y 
mul r6.xyz, r0.yyyy, r5.xyzx		
mul r5.xyz, r1.yyyy, r5.xyzx


imul null, r0.y, v1.x, l(35)  	-> 相当于比 r2.x 小一个单元 
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r7.xyz, r0.y, l(0), t0.xyzx
mul r8.xyz, r4.xxxx, r7.xyzx
mad r3.xyz, r7.xyzx, v0.xxxx, r3.xyzx
mad r0.xyw, r0.xxxx, r8.xyxz, r6.xyxz
mad r5.xyz, r1.xxxx, r8.xyzx, r5.xyzx


//以下r2应当是基于GPU Instance技术传入的对于当前渲染对象的空间变换矩阵 -> MVP 的一部分
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r2.xyz, r2.y, l(0), t0.xyzx	
ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r6.xyz, r2.w, l(0), t0.xyzx	
add r6.xyz, r6.xyzx, cb0[70].xyzx
mul r4.xyz, r4.zzzz, r2.xyzx				 用r2（变换矩阵的一列）乘上 r4.z分量 -> 完成对r4的变换 
mad r2.xyz, r2.xyzx, v0.zzzz, r3.xyzx    	 拿r2对v0.z分量进行矩阵操作，最后加上前两维的变换结果r3 -> 完成对v0（模型坐标）的空间变换 
add r2.xyz, r6.xyzx, r2.xyzx				 r2应该是‘世界坐标’（待考），r6应该存放的是世界坐标的偏移和修正分量 


mul o1.w, r1.w, r4.w
mad o1.xyz, r1.zzzz, r4.xyzx, r5.xyzx		o1 存放了 r1 关联数据 -> TANGENT -> 且处于：世界空间下
mad o0.xyz, r0.zzzz, r4.xyzx, r0.xywx  		o0 存放了 r0 关联数据 -> NORMAL  -> 且处于：世界空间下 
mov o2.zw, l(0,0,0,0)
mov o3.x, v1.x  			PRIMITIVE_ID


mul r0.xyzw, r2.yyyy, cb0[1].xyzw
mad r0.xyzw, r2.xxxx, cb0[0].xyzw, r0.xyzw
mad r0.xyzw, r2.zzzz, cb0[2].xyzw, r0.xyzw   矩阵 x 向量 -> r2.xyz 是‘世界空间’坐标  （此处是否是world space还需要佐证）

add r1.xyz, r2.xyzx, -cb0[70].xyzx		r1点 -> 来自于视空间点 r2 的平移变换 
add o4.xyzw, r0.xyzw, cb0[3].xyzw     	o4 -> PositionCS  add 操作用于‘点’的平移变换 
mov r1.w, l(1.000000)				  	r1.xyzw 代表一个向量‘点’，而不是一个‘向量’,因为w分量是1 
dp4 o5.x, cb0[127].xyzw, r1.xyzw		求 clipDistance 
ret 
// Approximately 0 instruction slots used
