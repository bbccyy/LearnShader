PS_KenaEye

Shader hash 81859c82-4cd15941-e48c8aa5-3458ced0

ps_5_0
      dcl_globalFlags refactoringAllowed
      dcl_constantbuffer cb0[201], immediateIndexed
      dcl_constantbuffer cb1[21], immediateIndexed
      dcl_constantbuffer cb2[6], immediateIndexed
      dcl_constantbuffer cb3[34], immediateIndexed
      dcl_sampler s0, mode_default
      dcl_sampler s1, mode_default
      dcl_sampler s2, mode_default
      dcl_sampler s3, mode_default
      dcl_sampler s4, mode_default

      dcl_resource_texture2d (float,float,float,float) t0               T_Eye_Wet_Normal
      dcl_resource_texture2d (float,float,float,float) t1               S_EyeScleraBaseColor
      dcl_resource_texture2d (float,float,float,float) t2               EYE_NORMALS
      dcl_resource_texture2d (float,float,float,float) t3               EyeMidPlaneDisplacement_Example
      dcl_resource_texture2d (float,float,float,float) t4               kena_eyes_DIFFUSE
      dcl_resource_texture2d (float,float,float,float) t5               Noise_cloudsmed
      dcl_resource_texturecube (float,float,float,float) t6             EpicQuadPanorama_CC -> TexCube

      dcl_input_ps linear centroid v0.xyz                               Tangent
      dcl_input_ps linear centroid v1.xyzw                              Norm + Sign
      dcl_input_ps linear v2.xy                                         UV
      dcl_input_ps_siv linear noperspective v3.xyz, position

      dcl_output o0.xyzw                CameraColor
      dcl_output o1.xyzw                Normal
      dcl_output o2.xyzw                M_D_R_I
      dcl_output o3.xyzw                Diffuse
      dcl_output o4.xyzw                Custom
      dcl_temps 11

   0: mul r0.xyz, v0.yzxy, v1.zxyz
   1: mad r0.xyz, v1.yzxy, v0.zxyz, -r0.xyzx
   2: mul r0.xyz, r0.xyzx, v1.wwww                          BitangentWS = cross(TangentWS, NormalWS) * sign

   3: mul r1.xyzw, v3.yyyy, cb0[45].xyzw
   4: mad r1.xyzw, v3.xxxx, cb0[44].xyzw, r1.xyzw
   5: mad r1.xyzw, v3.zzzz, cb0[46].xyzw, r1.xyzw
   6: add r1.xyzw, r1.xyzw, cb0[47].xyzw
   7: div r1.xyz, r1.xyzx, r1.wwww                          变换到 ViewSpace 中 -> 没有归一化的 Eye2ShadingPointDir

   8: dp3 r0.w, -r1.xyzx, -r1.xyzx
   9: rsq r0.w, r0.w
  10: mul r2.xyz, r0.wwww, -r1.xyzx                         归一化的 ViewDirWS

  11: div r3.xyzw, v2.xyxy, cb3[21].xxzz                    UV / cb3[21].x=2.4=NormalUVScale    UV / cb3[21].z=1.65=ScaleByCenter
  12: add r3.xyzw, r3.xyzw, l(0.5000, 0.5000, 0.5000, 0.5000)     UV + 0.5
  13: add r3.xyzw, r3.xyzw, -cb3[21].yyww                   UV - [0.2083333, 0.3030303]
  14: sample_indexable(texture2d)(float,float,float,float) r3.xy, r3.xyxx, t0.xyzw, s0          Sampel T_Eye_Wet_Normal using UV.xy
  15: mad r4.xy, r3.xyxx, l(2.0000, 2.0000, 0.0000, 0.0000), l(-1.0000, -1.0000, 0.0000, 0.0000)
  16: dp2 r1.w, r4.xyxx, r4.xyxx
  17: add r1.w, -r1.w, l(1.0000)
  18: max r1.w, r1.w, l(0)
  19: sqrt r4.z, r1.w                                       Unpack Eye_Wet_NormalTS -> r4.xyz

  20: add r3.xy, r3.zwzz, l(-0.5000, -0.5000, 0.0000, 0.0000)     UV.zw - 0.5

  21: dp2 r1.w, r3.xyxx, r3.xyxx
  22: sqrt r1.w, r1.w                                       Distance(UV.zw)

  23: add r3.xy, -cb3[1].xyxx, cb3[22].zzzz           UV = [Iris UV Radius=0.1] - [LimbusUVWidthColor=0.01, LimbusUVWidthShading=0.045]
  24: add r3.xy, r1.wwww, -r3.xyxx                          DistanceUV - UV
  25: div r3.xy, r3.xyxx, cb3[1].xyxx                       UV / [LimbusUV].xy -> UV ->?
  26: add_sat r3.xy, -r3.xyxx, l(1.0000, 1.0000, 0, 0)      sat(1 - UV)
  27: mad r5.xy, r3.xyxx, l(-2, -2, 0, 0), l(3, 3, 0, 0)    3 - 2 * UV -> UV2
  28: mul r3.xy, r3.xyxx, r3.xyxx
  29: mul r3.xy, r3.xyxx, r5.xyxx                           UV * UV * UV2 -> UV
  30: add r2.w, -cb3[22].w, l(1.0000) 
  31: mad r2.w, r3.x, r2.w, cb3[22].w                       lerp(FlattenNormal=0.95, 1, UV.x) -> flatN

  32: add r5.xyz, -r4.xyzx, l(0, 0, 1.0000, 0) 
  33: mad r4.xyz, r2.wwww, r5.xyzx, r4.xyzx                 lerp(wetNormTS, (0,0,1), flatN) -> 注意UE和Unity坐标空间的不同 

  34: mad r4.xyz, r4.xyzx, cb0[137].wwww, cb0[137].xyzx     wetNormTS * GlobalNormalScaler + GlobalNormalBias
  35: dp3 r2.w, r4.xyzx, r4.xyzx
  36: rsq r2.w, r2.w
  37: mul r4.xyz, r2.wwww, r4.xyzx                          normalize(wetNormTS)

  38: mul r5.xyz, r0.xyzx, r4.yyyy
  39: mad r4.xyw, r4.xxxx, v0.xyxz, r5.xyxz
  40: mad r4.xyz, r4.zzzz, v1.xyzx, r4.xywx
  41: dp3 r2.w, r4.xyzx, r4.xyzx
  42: rsq r2.w, r2.w
  43: mul r4.xyz, r2.wwww, r4.xyzx                          nWetDirWS = normalize(mul(wetNormTS, tbn))

  44: dp3 r2.w, r4.xyzx, r2.xyzx                            NoV

  45: mul r5.xyz, r2.wwww, r4.xyzx
  46: mad r5.xyz, r5.xyzx, l(2.0000, 2.0000, 2.0000, 0.0000), -r2.xyzx        2 * NoV * nWetDirWS - V -> ReflectDir

  47: add r6.xyz, cb2[5].xyzx, cb3[3].xyzx                  [0] + FakeHighlightRotationAxis=[-4.5102582, 2.5374241, -1]
  48: dp3 r4.w, r6.xyzx, r6.xyzx
  49: sqrt r4.w, r4.w
  50: div r6.xyz, r6.xyzx, r4.wwww                          normalize(FakeRotAxis)

  51: mul r7.xyz, r6.yyyy, cb0[17].xyzx
  52: mad r6.xyw, r6.xxxx, cb0[16].xyxz, r7.xyxz
  53: mad r6.xyz, r6.zzzz, cb0[18].xyzx, r6.xywx            FakeRotAxisWS

  54: mad r6.xyz, -r1.xyzx, r0.wwww, r6.xyzx                ViewDirWS * FakeRotAxisWS -> RotViewDirWS
  55: dp3 r4.w, r6.xyzx, r6.xyzx
  56: sqrt r4.w, r4.w
  57: div r6.xyz, r6.xyzx, r4.wwww                          normalize(RotViewDirWS)

  58: dp3_sat r4.w, r6.xyzx, r4.xyzx                        sat(NoVr) -> sat(nWetDirWS dot RotViewDirWS)

  59: add r6.xy, cb2[2].yzyy, cb3[23].xyxx                  [0] + [FakeHighlightPower=1204.189, FakeHighligtBrighness=0.8]

  60: max r4.w, r4.w, l(0.00001)                            max(NoVr, 0.00001)
  61: log r4.w, r4.w
  62: mul r4.w, r4.w, r6.x
  63: exp r4.w, r4.w                                        pow(NoVr, FakeHighlightPower)

  64: mul r6.xzw, cb0[17].xxyz, cb3[6].yyyy                 cb3[6].xyz = [0.6607623, 0.5187197, -0.5425155] -> LightDir?
  65: mad r6.xzw, cb3[6].xxxx, cb0[16].xxyz, r6.xxzw
  66: mad r6.xzw, cb3[6].zzzz, cb0[18].xxyz, r6.xxzw        LitDirWS

  67: mad r6.xzw, -r1.xxyz, r0.wwww, r6.xxzw                ViewDirWS * LitDirWS -> RotViewDirWS_2
  68: dp3 r0.w, r6.xzwx, r6.xzwx
  69: sqrt r0.w, r0.w
  70: div r6.xzw, r6.xxzw, r0.wwww                          normalize(RotViewDirWS_2)

  71: dp3_sat r0.w, r6.xzwx, r4.xyzx                        sat(NoVr_2)
  72: max r0.w, r0.w, l(0.0000)                             max(NoVr_2, 0.00001)
  73: log r0.w, r0.w
  74: mul r0.w, r0.w, cb3[23].x
  75: exp r0.w, r0.w                                        pow(NoVr_2, FakeHighlightPower)

  76: mul r0.w, r0.w, cb3[23].y                             powed_NoVr_2 * FakeHighligtBrighness -> Brightness_2
  77: mul r0.w, r0.w, cb3[24].x                             Brightness_2 * SecondHighlightMultiplier=0

  78: mad r0.w, r4.w, r6.y, r0.w                            powed_NoVr * FakeHighligtBrighness -> Brightness_1 + (~) -> Brightness

  79: dp3 r4.w, cb3[8].xyzx, r5.xyzx                        SecondaryEnvRotationAxis=[0,0,1] dot ReflectDir -> 注意UE和Unity区别 
                                                            -> AoR
  80: mad r5.xyz, -cb3[8].xyzx, r4.wwww, r5.xyzx            RefDir = ReflectDir - SecondaryEnvRotationAxis * AoR

  81: mul r6.xyz, r5.yzxy, cb3[8].zxyz
  82: mad r6.xyz, cb3[8].yzxy, r5.zxyz, -r6.xyzx            cross(RefDir, SecondaryEnvRotationAxis) -> SecondaryEnvTangent

  83: sincos r7.x, r8.x, cb3[24].w                          sin=0, cos=1 -> cb3[24].w=0=SecondaryEnvRotation
  84: mul r6.xyz, r6.xyzx, r7.xxxx                          SecondaryEnvTangent * sin(SecondaryEnvRotation)
  85: mad r5.xyz, r5.xyzx, r8.xxxx, r6.xyzx                 RefDir * cos(SecondaryEnvRotation) + SecondaryEnvTangent
  86: mad r5.xyz, cb3[8].xyzx, r4.wwww, r5.xyzx             SecondaryEnvRotationAxis * AoR + (~) -> EyeRefDir
  87: dp3 r4.w, r5.xyzx, r5.xyzx
  88: sqrt r4.w, r4.w
  89: div r5.xyz, r5.xyzx, r4.wwww                          normalize(EyeRefDir)

  90: sample_indexable(texturecube)(float,float,float,float) r5.xyz, r5.xyzx, t6.xyzw, s4       Sample TexCube using EyeRefDir -> EnvCol
  91: mad r5.xyz, r5.xyzx, cb3[10].xyzx, r0.wwww            EnvCol = EnvCol * SecondaryEnvBalance=[0.010417] + Brightness
  92: add r5.xyz, r5.xyzx, cb3[13].xyzx                     EnvCol + [0]
  93: add r6.xyz, -r5.xyzx, cb3[14].xyzx                    
  94: mad r5.xyz, cb3[25].yyyy, r6.xyzx, r5.xyzx            lerp(EnvCol, SecondaryEnvTint=0, 0) -> EnvCol

  95: mad r0.w, -r1.w, cb3[26].x, l(1.0000)                 uvDist = 1 - DistanceUV * 1.5384616
  96: mul_sat r0.w, r0.w, cb3[27].x                         uvDist = uvDist * 1.1111112
  97: add r6.xyz, -cb3[16].xyzx, l(1, 1, 1, 0)              
  98: mad r6.xyz, r0.wwww, r6.xyzx, cb3[16].xyzx            lerp(ScleraInnerColor=[1,1,1], 1, uvDist) -> ScleraInCol

  99: add r7.xyz, cb3[18].xyzx, l(-1, -1, -1, 0)
 100: mad r7.xyz, r0.wwww, r7.xyzx, l(1, 1, 1, 0)           lerp(1, ScleraOuterColor=[1,1,1], uvDist) -> ScleraOutCol

 101: add r7.xyz, -r6.xyzx, r7.xyzx
 102: mad r6.xyz, r0.wwww, r7.xyzx, r6.xyzx                 lerp(ScleraInCol, ScleraOutCol, uvDist) -> ScleraCol

 103: sample_indexable(texture2d)(float,float,float,float) r7.xyz, v2.xyxx, t1.xyzw, s0   Sample S_EyeScleraBaseColor using rawUV 
                                                            -> ScleraBaseCol
 104: add r7.xyz, r7.xyzx, l(-1, -1, -1, 0)
 105: mad r7.xyz, cb3[27].yyyy, r7.xyzx, l(1, 1, 1, 0)      lerp(1, ScleraBaseCol, ScleraRougness=0) -> ScleraBaseCol

 106: mul r7.xyz, r7.xyzx, cb3[27].zzzz                     ScleraBaseCol = ScleraBaseCol * ScleraBrightness=0.5
 107: mul r6.xyz, r6.xyzx, r7.xyzx                          ScleraCol *= ScleraBaseCol

 108: dp3 r0.w, v0.xyzx, v0.xyzx                            
 109: sqrt r0.w, r0.w
 110: div r7.xyz, v0.zxyz, r0.wwww                          normalize(TangentWS) -> TangentWS

 111: sample_b(texture2d)(float,float,float,float) r8.xy, v2.xyxx, t2.xyzw, s1, cb0[142].y      Sample EYE_NORMALS
 112: mad r8.xy, r8.xyxx, l(2,2,0,0), l(-1,-1,0,0)
 113: dp2 r0.w, r8.xyxx, r8.xyxx
 114: add r0.w, -r0.w, l(1.0000)
 115: max r0.w, r0.w, l(0)
 116: sqrt r0.w, r0.w                                       Unpack NormalTS -> r8.xy + r0.w

 117: mul r0.xyz, r0.xyzx, r8.yyyy
 118: mad r0.xyz, r8.xxxx, v0.xyzx, r0.xyzx
 119: mad r0.xyz, r0.wwww, v1.xyzx, r0.xyzx                 mul(NormalTS, tbn) -> RawNormWS

 120: dp3 r0.w, r7.yzxy, r0.xyzx                            dot(TangentWS.yzx, RawNormWS.xyz)
 121: mad r7.xyz, -r0.wwww, r0.zxyz, r7.xyzx                TangentWS - (~) * RawNormWS -> NewTanWS

 122: dp3 r0.w, r7.xyzx, r7.xyzx
 123: sqrt r0.w, r0.w
 124: div r7.xyz, r7.xyzx, r0.wwww                          NewTanWS = normalize(NewTanWS)

 125: div r0.w, l(1.0003), cb3[28].y                        1.0003 / IoR=1.336 -> InvIoR
 126: mad r1.w, r0.w, r2.w, -r0.w                           IoR_A = NoV * InvIoR - InvIoR
 127: mad r4.w, r0.w, r2.w, r0.w                            IoR_B = NoV * InvIoR + InvIoR
 128: mad r1.w, r1.w, r4.w, l(1.0000)                       IoR_A * IoR_B + 1 -> IoR_AB
 129: sqrt r1.w, r1.w                                       
 130: mad r1.w, r0.w, r2.w, -r1.w                           NoV * InvIoR - sqrt(IoR_AB) -> IoR_Factor

 131: mul r8.xyz, r2.xyzx, r0.wwww 
 132: mad r8.xyz, r1.wwww, r4.xyzx, -r8.xyzx                BiasDir = nWetDirWS * IoR_Factor - ViewDirWS * InvIoR
 133: dp3 r0.w, r8.xyzx, r8.xyzx
 134: rsq r0.w, r0.w
 135: mul r8.xyz, r0.wwww, r8.xyzx                          BiasDir = normalize(BiasDir)

 136: sample_b(texture2d)(float,float,float,float) r9.xyz, v2.xyxx, t3.xyzw, s2, cb0[142].y     Sample EyeMidPlaneDisplacement_Example
                                                            -> EyeMidPlaneDisp_Cur
 137: sample_b(texture2d)(float,float,float,float) r0.w, cb3[19].xyxx, t3.yzwx, s2, cb0[142].y  cUV=[0.665, 0.5] -> Setup by C++
                                                            -> EyeMidPlaneDisp_Center

 138: add r9.xyz, -r0.wwww, r9.xyzx                         EyeMidPlaneDisp = EyeMidPlaneDisp_Cur - EyeMidPlaneDisp_Center
 139: max r9.xyz, r9.xyzx, l(0, 0, 0, 0)                    max(EyeMidPlaneDisp, 0)
 140: mul r9.xyz, r9.xyzx, cb3[29].xxxx                     EyeMidPlaneDisp = EyeMidPlaneDisp * DepthScale=1.1

 141: dp3 r0.w, r2.xyzx, r0.xyzx                            ViewDirWS dot RawNormWS -> NoV' -> NoV

 142: mul r0.w, r0.w, r0.w
 143: mad r0.w, r0.w, l(0.6750), l(0.3250)                  NoV = NoV * NoV * 0.675 + 0.325

 144: div r2.xyz, r9.xyzx, r0.wwww 
 145: mul r2.xyz, r2.xyzx, -r8.xyzx                         EyeMidPlaneDisp / NoV * (-BiasDir) -> PlaneNorm

 146: dp3 r8.x, r7.yzxy, r2.xyzx                            dot(NewTanWS.yzx, PlaneNorm) -> ToP

 147: mul r9.xyz, r0.yzxy, r7.xyzx                          
 148: mad r7.xyz, r7.zxyz, r0.zxyz, -r9.xyzx                cross(RawNormWS, NewTanWS) -> BiNewTangentWS

 149: dp3 r8.y, r7.xyzx, r2.xyzx                            dot(BiNewTangentWS, PlaneNorm) -> BoP

 150: mul r2.xy, r8.xyxx, cb3[20].xyxx                      [ToP, BoP] * [-0.1, 0.1]
 151: mul r2.zw, r2.xxxy, r3.xxxx                           [-0.1*ToP, 0.1*BoP] * UV.x -> rawNeoUV.xy -> neoUV.xy

 152: mad r2.zw, cb3[29].yyyy, r2.zzzw, r3.zzzw             cb3[29].y=1=PupilScale * neoUV + UV.zw -> neoUV
 153: add r2.zw, r2.zzzw, l(0, 0, -0.5000, -0.5000)         neoUV = neoUV - 0.5
 154: mul r2.zw, r2.zzzw, cb3[29].wwww                      neoUV *= cb3[29].w=5
 155: dp2 r0.w, r2.zwzz, r2.zwzz
 156: sqrt r1.w, r0.w                                       Dist(neoUV)
 157: rsq r0.w, r0.w
 158: mul r2.zw, r0.wwww, r2.zzzw                           neoUV = normalize(neoUV)
 159: mul r2.zw, r2.zzzw, l(0, 0, 0.5000, 0.5000)           neoUV *= 0.5

 160: mad r0.w, -r1.w, l(2.0000), l(1.0000)                 1 - 2 * Dist(neoUV) -> distNeo
 161: mul_sat r0.w, r0.w, cb3[30].x                         distNeo = sat(distNeo * cb3[30].x=1)
 162: mad r2.zw, r0.wwww, -r2.zzzw, r2.zzzw                 neoUV = neoUV - neoUV * distNeo

 163: add r7.xy, r2.zwzz, l(0.5000, 0.5000, 0, 0)           neoUV + 0.5 -> DiffuseUV
 164: sample_indexable(texture2d)(float,float,float,float) r7.xyz, r7.xyxx, t4.xyzw, s0   Sample kena_eyes_DIFFUSE using DiffuseUV
                                                            -> rawDiffuse
 165: mul r8.xyz, r7.xyzx, cb3[30].yyyy                     dBase = rawDiffuse * IrisBRightness=0.409524

 166: dp3 r0.w, l(0.5774, 0.5774, 0.5774, 0), r8.xyzx
 167: mul r1.w, r0.w, l(0.5774)
 168: mad r7.xyz, r7.xyzx, cb3[30].yyyy, -r1.wwww
 169: mul r8.xyz, r7.zxyz, l(0.5774, 0.5774, 0.5774, 0.0000)
 170: mad r8.xyz, r7.zxyz, l(0.5774, 0.5774, 0.5774, 0.0000), -r8.zxyz
 171: sincos r9.x, r10.x, cb3[28].x
 172: mul r8.xyz, r8.xyzx, r9.xxxx
 173: mad r7.xyz, r7.xyzx, r10.xxxx, r8.xyzx
 174: mad r7.xyz, r0.wwww, l(0.5774, 0.5774, 0.5774, 0.0000), r7.xyzx         dBase = applyHue(dBase, cb3[28].x=0=IrisHueShift)

 175: dp3 r0.w, r7.xyzx, l(0.3000, 0.5900, 0.1100, 0.0000)
 176: add r8.xyz, -r7.xyzx, r0.wwww
 177: mad r7.xyz, cb3[30].zzzz, r8.xyzx, r7.xyzx            lerp(dBase, Luminance(dBase), IrisDesaturation=0) -> dBase

 178: mul r2.zw, r2.zzzw, cb3[30].wwww                      neoUV = neoUV * cb3[30].w=1.9299999
 179: dp2 r0.w, r2.zwzz, r2.zwzz
 180: sqrt r0.w, r0.w                                       Distance(neoUV) -> d_limb

 181: min r0.w, r0.w, l(1.0000)                             d_limb = min(d_limb, 1)
 182: max r0.w, r0.w, l(0.0000)                             d_limb = max(d_limb, 0.00001)
 183: log r0.w, r0.w
 184: mul r0.w, r0.w, cb3[31].x
 185: exp r0.w, r0.w                                        limbus = pow(d_limb, LimbusPow=8)

 186: add r0.w, -r0.w, l(1.0000)
 187: mad r7.xyz, r7.xyzx, r0.wwww, -r6.xyzx                dBase = (1 - limbus) * dBase - ScleraCol
 188: mad_sat r6.xyz, r3.xxxx, r7.xyzx, r6.xyzx             ScleraCol = sat(UV.x * dBase + ScleraCol)

 189: add r0.w, -cb3[31].z, cb3[31].y
 190: mad_sat r0.w, r3.x, r0.w, cb3[31].z                   Spec = lerp(SpecularityScelera=0.1, SpecularityIris=0.1, UV.x)

 191: add r1.w, cb3[31].w, -cb3[32].x
 192: mad_sat r1.w, r3.x, r1.w, cb3[32].x                   R = lerp(ScleraRougness=0, IrisRoughness=0.1, UV.x)

 193: mul r2.zw, v2.xxxy, cb3[32].zzzz                      rawUV * 1
 194: sample_b(texture2d)(float,float,float,float) r2.z, r2.zwzz, t5.yzxw, s3, cb0[142].y       Sample Noise_cloudsmed
 195: add r2.w, -r2.z, cb3[32].w                            cb3[32].w=0
 196: lt r2.w, l(0.0000), abs(r2.w)                         0 < abs(0 - noise)
 197: ge r2.z, cb3[32].w, r2.z                              cb3[32].w=0 >= noise
 198: movc r2.z, r2.z, l(0), l(1.0000)
 199: and r2.z, r2.z, r2.w                                  
 200: lt r2.w, l(0.0000), abs(cb3[32].w)                    
 201: ge r4.w, cb3[32].w, l(0)                              
 202: add r2.z, r2.z, l(-0.3333)                            
 203: lt r2.z, r2.z, l(0)                                   
 204: and r2.z, r2.z, r4.w                                  
 205: and r2.z, r2.z, r2.w                                  dissolveVal = DissolveMix(noise, DissolveAmount=0) -> todo
 206: discard_nz r2.z                                       clip(dissolveVal - 0.33333);

 207: mov_sat r2.z, cb3[33].w                               baseAo = 0.45

 208: mad o2.z, r1.w, cb0[138].y, cb0[138].x                R * _GlobalRoughnessScaler + _GlobalRoughnessBias

 209: min r1.w, r3.y, l(1.0000)
 210: add o4.w, -r1.w, l(1.0000)                            CustomData.w = 1 - min(UV.y, 1)

 211: mad r2.xy, r3.xxxx, r2.xyxx, r3.zwzz                  neoUV = rawNeoUV.xy + UV.zw
 212: add r2.xy, r2.xyxx, l(-0.5000, -0.5000, 0, 0)         neoUV -= 0.5
 213: dp2 r1.w, r2.xyxx, r2.xyxx
 214: sqrt r1.w, r1.w                                       Distance(neoUV) -> d_limb_2

 215: div r1.w, r1.w, cb3[22].z                             d_limb_2 / [Iris UV Radius=0.1] -> IrisConcavity
 216: mul r1.w, r1.w, cb3[33].y                             IrisConcavity *= [Iris Concavity Scale=0.111628]
 217: max r1.w, r1.w, l(0.0000)                             max(IrisConcavity, 0.00001)
 218: log r1.w, r1.w
 219: mul r1.w, r1.w, cb3[33].z
 220: exp r1.w, r1.w                                        pow(IrisConcavity, [Iris Concavity Power=0.276744])

 221: min o2.x, r1.w, l(1.0000)                             M_D_R_I.x = min(powed_IrisConcavity, 1) -> Metalic

 222: dp3 r1.w, r0.xyzx, r0.xyzx
 223: rsq r1.w, r1.w
 224: mul r0.xyz, r0.xyzx, r1.wwww                          normalize(RawNormWS) -> NormWS

 225: dp3 r1.w, l(1,1,1,0), abs(r0.xyzx)                    dot((1,1,1), abs(NormWS)) -> sum(NormWS.xyz)
 226: div r0.xy, r0.xyxx, r1.wwww                           NormWS.xy /= sum(NormWS.xyz)
 227: ge r0.z, l(0), r0.z                                   0 >= NormWS.z -> 世界坐标空间中法线在垂直方向的分量是否朝下 -> A
 228: add r2.xy, -abs(r0.yxyy), l(1,1,0,0)                  1 - abs(NormWS.yx)
 229: ge r3.xy, r0.xyxx, l(0, 0, 0, 0)                      NormWS.xy >= 0 ? -> B
 230: movc r3.xy, r3.xyxx, l(1,1,0,0), l(-1,-1,0,0)         B ? (1,1) : (-1,-1) -> NormWS_XY
 231: mul r2.xy, r2.xyxx, r3.xyxx                           (1 - abs(NormWS.yx)) * NormWS_XY -> ComplementNormWS_YX
 232: movc r0.xy, r0.zzzz, r2.xyxx, r0.xyxx                 A ? ComplementNormWS_YX : NormWS.xy -> CustomedNormWS_XY
 233: mad o4.yz, r0.xxyx, l(0,0.5,0.5,0), l(0,0.5,0.5,0)    CustomData.yz = CustomedNormWS_XY * 0.5 + 0.5

 234: mul r0.x, r0.w, l(0.0800)                             F0 = DielectricSpecularToF0(Spec)

 235: ftou r0.yz, v3.xxyx
 236: ftou r1.w, cb0[151].x
 237: iadd r0.y, r0.z, r0.y
 238: iadd r0.y, r1.w, r0.y
 239: and r0.y, r0.y, l(1)                                  bool bCheck = CheckerFromSceneColorUV(i.vertex.xy);

 240: lt r0.z, l(0), cb0[155].x                             useSSMode5 -> true 
 241: lt r1.w, l(0), cb0[200].z                             useSeperate -> true

 242: and r0.z, r0.z, r1.w                                  useSSMode5 and useSeperate -> true

 243: ne r1.w, l(0, 0, 0, 0), cb0[155].x                    encodeDiffuse -> true

 244: movc r2.xyw, r1.wwww, l(1,1,0,1), r6.xyxz             eDiffuse = encodeDiffuse ? (1,1,1) : ScleraCol
 245: movc r3.xy, r0.yyyy, l(1,0,0,0), l(0,1,0,0)           half2 checkboard = bCheck ? half2(1, 0) : half2(0, 1);
 246: mul r0.y, r0.x, r3.y                                  encodedEmiSpec = F0 * checkboard.y;
 247: movc r2.xyw, r0.zzzz, r3.xxxx, r2.xyxw                eDiffuse = (useSSMode5 and useSeperate) ? checkboard.xxx : eDiffuse
 248: movc r0.x, r0.z, r0.y, r0.x                           eSpec = (useSSMode5 and useSeperate) ? encodedEmiSpec : F0

 249: mad r2.xyw, r2.xyxw, cb0[135].wwww, cb0[135].xyxz     BaseCol = eDiffuse * _GlobalBaseColorScaler + _GlobalBaseColorBias;
 250: mad r3.xzw, r0.xxxx, cb0[136].wwww, cb0[136].xxyz     SpecCol = eSpec.xxx * _GlobalSpecularColorScaler + _GlobalSpecularColorBias;

 251: ne r0.x, l(0, 0, 0, 0), cb0[177].w                    0 != 0 ? -> false -> not View.RenderingReflectionCaptureMask
 252: mad r7.xyz, r3.xzwx, l(0.4500, 0.4500, 0.4500, 0), r2.xywx
 253: movc r2.xyw, r0.xxxx, r7.xyxz, r2.xyxw
 254: movc r3.xzw, r0.xxxx, l(0, 0, 0, 0), r3.xxzw          EnvBRDFApproxFullyRough(BaseCol, SpecCol)

 255: dp3 r0.x, r3.xzwx, l(0.3000, 0.5900, 0.1100, 0.0000)
 256: mad r7.xyz, r0.xxxx, l(2.0404, -4.7951, 2.7552, 0), l(-0.3324, 0.6417, 0.6903, 0)
 257: mad r0.x, r2.z, r7.x, r7.y
 258: mad r0.x, r0.x, r2.z, r7.z
 259: mul r0.x, r2.z, r0.x
 260: max o3.w, r0.x, r2.z                                  FinalAO = AOMultiBounce(Luminance(SpecCol), baseAo)

 261: mad r2.xyz, r3.xzwx, l(0.45, 0.45, 0.45, 0), r2.xywx  EnvBRDFApproxFullyRough(BaseCol, SpecCol) -> ReflectionCol
 262: max r3.xzw, r5.xxyz, l(0, 0, 0, 0)                    FinalEmit = max(EnvCol, 0)

 263: lt r0.x, l(0), cb0[139].x
 264: if_nz r0.x
 265:   add r1.xyz, r1.xyzx, -cb0[70].xyzx
 266:   add r5.xyz, r1.xyzx, -cb1[5].xyzx
 267:   add r7.xyz, cb1[19].xyzx, l(1.0000, 1.0000, 1.0000, 0.0000)
 268:   lt r5.xyz, r7.xyzx, abs(r5.xyzx)
 269:   or r0.x, r5.y, r5.x
 270:   or r0.x, r5.z, r0.x
 271:   dp3 r0.y, r1.xyzx, l(0.5770, 0.5770, 0.5770, 0.0000)
 272:   mul r0.y, r0.y, l(0.0020)
 273:   frc r0.y, r0.y
 274:   lt r0.y, l(0.5000), r0.y
 275:   movc r1.xyz, r0.yyyy, l(0.0000, 1.0000, 1.0000, 0.0000), l(1.0000, 1.0000, 0.0000, 0.0000)
 276:   movc r3.xzw, r0.xxxx, r1.xxyz, r3.xxzw
 277: endif

 278: mad r1.xyz, cb0[144].yyyy, r2.xyzx, r3.xzwx           _GlobalRelectionAmount * ReflectionCol + FinalEmit = BaseRTCol
 279: mul r2.xyz, r3.yyyy, r1.xyzx                          checkboard.y * BaseRTCol
 280: movc r0.xyz, r0.zzzz, r2.xyzx, r1.xyzx                (useSSMode5 and useSeperate) ? (~) : BaseRTCol -> FinalBaseRTCol
 281: mad o1.xyz, r4.xyzx, l(0.5,0.5,0.5,0), l(0.5,0.5,0.5,0)    Normal.xyz =  nWetDirWS * 0.5 + 0.5
 282: mul o0.xyz, r0.xyzx, cb0[134].yyyy                    CameraColor.xyz = FinalBaseRTCol * _GlobalBouncingColorIntensity
 283: mov o0.w, l(0)                                        CameraColor.w = 0
 284: mov o1.w, cb1[20].y                                   Normal.w = 2/3
 285: mov o2.w, l(0.6627)                                   M_D_R_I.w = 0.6627 = 169 / 255
 286: mov o2.y, r0.w                                        M_D_R_I.y = Spec
 287: mov o3.xyz, r6.xyzx                                   Diffuse.xyz = ScleraCol
 288: mov o4.x, cb3[33].x                                   CustomData.x = 0.0039216
 289: ret
