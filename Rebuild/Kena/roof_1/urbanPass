以下内容来自：DC=2183   ->  关注输出 Tex 8264
本DC主要负责 GI 效果 -> 不处理直接光照 
备注1：对于DC=2181   ->  Tex 8269  ->  可能是上一帧的输出 
备注2：SSAO 的DC = 2091 -> 输出到 Tex 8232 上 -> 再通过DC=2903 输出到 单通道的 Tex 6681 上

//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Position              0   xyzw        0      POS   float   xy w
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[10], immediateIndexed
dcl_constantbuffer CB1[201], immediateIndexed
dcl_constantbuffer CB2[1], immediateIndexed
dcl_constantbuffer CB3[4], immediateIndexed
dcl_constantbuffer CB4[1023], dynamicIndexed
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_sampler s2, mode_default
dcl_sampler s3, mode_default
dcl_sampler s4, mode_default
dcl_sampler s5, mode_default
dcl_sampler s6, mode_default
dcl_sampler s7, mode_default
dcl_resource_texturecube (float,float,float,float) t0 			-> 天空 
dcl_resource_texturecube (float,float,float,float) t1 			-> cubemap 几乎全黑 
dcl_resource_texturecubearray (float,float,float,float) t2 		-> 确认是 IBL 探针，有 57 张  
dcl_resource_buffer (uint,uint,uint,uint) t3  					-> 似乎是一张映射表 
dcl_resource_buffer (uint,uint,uint,uint) t4 
dcl_resource_texture2d (float,float,float,float) t5				-> BRDF LUT 
dcl_resource_texture2d (float,float,float,float) t6 			-> [NormalWS.xyz, Depth] (看起来像) 被模糊过，且分辨率减半 
																-> 后续可能关联计算: Motion Blur;  Depth of Field; ... 
dcl_resource_texture2d (float,float,float,float) t7 			-> Depth (R通道) 
dcl_resource_texture2d (float,float,float,float) t8 			-> [NormalWS.xyz, 0.333] 
dcl_resource_texture2d (float,float,float,float) t9 			-> [PurpleRGB.y, 0.2, PurpleRGB.y偏移值, 0.694118(roughness)] 
dcl_resource_texture2d (float,float,float,float) t10 			-> [去除强度的BaseColor.rgb, 随机化处理的PurpleRGB.z] 
dcl_resource_texture2d (float,float,float,float) t11   			-> 似乎区分了角色+衣服+树叶, 其他为黑 -> 动态vs静态? -> [0,0,0,0] 
																-> X 通道似乎是控制 Fresnel 效果用 
dcl_resource_texture2d (float,float,float,float) t12 			-> 似乎是自发光物体相关的值 
dcl_resource_texture2d (float,float,float,float) t13 			-> AO (R通道) -> TODO 

dcl_input_ps_siv linear noperspective v0.xyw, position 			-> 全屏Blit对应的 VertexInputPS 
dcl_output o0.xyzw 												-> 输出纹理 T:8264 
dcl_temps 20


mul r0.xy, v0.xyxx, cb1[131].zwzz  		屏幕像素序号xy * 像素倒数  ->  用于采样贴图的屏幕 UV 

//r1.xy -> 经过如下变换后，r1.xy 介于 ScreenSpace & ClipSpace 之间... 
//注意 v0.w 对应全屏 Blit 使用的三角形面片的视深度 
add r0.zw, v0.xxxy, -cb1[129].xxxy     -> cb1[129].xy = 0 		-> v0.xy 是屏幕像素索引(+0.5) 
mad r1.xy, r0.zwzz,  [130].zwzz, l(-0.5, -0.5, 0.0, 0.0) 		-> v0.xy / [height, width] - [0.5, 0.5] -> [-0.5, +0.5]区间UV 
mul r1.xy, r1.xyxx, v0.wwww    	-> [-0.5, +0.5] * v0.w 	-> v0.w = Clip.w 
mul r1.xy, r1.xyxx, l(2.000000, -2.000000, 0.000000, 0.000000)  -> [-1.0, +1.0] * v0.w -> 上下翻转 -> 预乘"三角面片深度"的半成品 

sample_l_indexable(texture2d)(float,float,float,float) r2.xyz, r0.xyxx, t8.xyzw, s0, l(0.000000) 	-> Normal, 0.33 
sample_l_indexable(texture2d)(float,float,float,float) r3.xyzw, r0.xyxx, t9.xywz, s0, l(0.000000) 	-> P.y, 0.2, P.y, 0.69 
sample_l_indexable(texture2d)(float,float,float,float) r4.xyzw, r0.xyxx, t10.xyzw, s0, l(0.000000) 	-> BaseColor.rgb, P.z 
sample_l_indexable(texture2d)(float,float,float,float) r5.xyzw, r0.xyxx, t11.xyzw, s0, l(0.000000)  -> 0,0,0,0  
sample_l_indexable(texture2d)(float,float,float,float) r1.z, r0.xyxx, t7.yzxw, s0, l(0.000000)    	-> 深度 R1.Z 

//Decode Depth
//R1.z 应该是趋向 Clip.w' 的数值，基本上取值大于 100, 既大于1米  
//注意: UE4 默认距离单位 = 厘米 
mad r1.w, r1.z, cb1[65].x, cb1[65].y   								-> 0 
mad r1.z, r1.z, cb1[65].z, -cb1[65].w  								-> 0.1 * depthRaw 
div r1.z, l(1.000000, 1.000000, 1.000000, 1.000000), r1.z 			-> 1/(0.1*depthRaw) 
add r1.z, r1.z, r1.w 												-> 1/(0.1*depthRaw) + (depthRaw*a+b) 

mul r6.xy, r0.xyxx, cb1[131].xyxx 									-> 像素坐标索引 
ftou r6.xy, r6.xyxx

//Condition: 某种 2x2 块状像素分割逻辑 
ftou r1.w, cb1[151].x 		-> 1 
iadd r2.w, r6.y, r6.x 		-> x + y 
iadd r1.w, r1.w, r2.w 		-> x + y + 1 
and r1.w, r1.w, l(1)        -> 判断奇偶?   ->  某种块状分割逻辑 

//法线 
mad r2.xyz, r2.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), l(-1.000000, -1.000000, -1.000000, 0.000000) 
dp3 r2.w, r2.xyzx, r2.xyzx
rsq r2.w, r2.w
mul r6.xyz, r2.wwww, r2.xyzx   -> R6 

//r3.zy = [Purple.y修改值, 0.2]
//利用采样 T9 纹理的 Z 通道，获取当前urbanPass分支逻辑控制符 
//利用采样 T9 纹理的 Y 通道，计算环境光底色 
mul r7.xy, r3.zyzz, l(255.000000, 0.080000, 0.000000, 0.000000)  	-> 255用于将8bit通道转换到整数范围，0.08推测是环境光缩放因子 
round_ne r6.w, r7.x     -> 四舍五入到整数float值 ->  颜色[0~255]
ftou r6.w, r6.w 
and r7.xz, r6.wwww, l(15, 0, 16, 0)   	-> (Z= r6.w & 10000) -> 筛选出第五bit位=0或1的值； (X= r6.w & 1111) -> 返回:[0~15] 
movc r5.xyzw, r7.zzzz, l(0,0,0,0), r5.xyzw  -> T11 纹理采样返回值 
ieq r8.xyz, r7.xxxx, l(9, 5, 4, 0)    	-> Condition: r7.x 返回值是否落在给定区间 
movc r6.w, r8.x, l(0), r3.x    			-> r3.x = Purple.y  -> 若为0，则下面R9写入的环境光底色 = 0.2*0.08 
mad r9.xyz, -r3.yyyy, l(0.08, 0.08, 0.08, 0), r4.xyzx  		-> BaseCol.rgb - 0.2*0.08 
mad r9.xyz, r6.wwww, r9.xyzx, r7.yyyy   -> (BaseCol.rgb - 0.2*0.08) * [0 or Purple.y] + 0.2*0.08  -> R9 颜色似乎是环境光底色 

or r7.y, r8.x, r8.y 					-> Condition: 比 r8 单个通道几率更高 -> 是 9号 或 5号 材质渲染方案的话 
lt r7.z, l(0.000000), cb1[155].x 		-> 0 < 1 ? true 
lt r7.w, l(0.000000), cb1[200].z  		-> 0 < 1 ? true  -> 这2个开关负责什么? TODO 
and r7.z, r7.w, r7.z 					-> 同时满足上面2个开关 -> 才OK 
ne r7.w, l(0, 0, 0, 0), cb1[155].x  	-> false 
movc r8.xyw, r7.wwww, l(1,1,0,1), r4.xyxz		-> r8.xyw = BaseCol.rgb 

//构建了 R10 颜色/遮罩 -> TODO 
movc r10.xy, r1.wwww, l(1,0,0,0), l(0,1,0,0) 	-> 某种2x2块状分割逻辑 -> r10.xy = [1,0] or [0,1] 
mul r11.xyz, r9.xyzx, r10.yyyy 					-> R11 颜色 -> R9 颜色 * 方块Mask.y  -> 可颜色 可0 
mul r11.w, r3.y, r10.y 		 					-> 0.2 * [1 or 0] -> 0.2 * 方块Mask.y 
movc r10.xyz, r7.zzzz, r10.xxxx, r8.xywx 		-> R10 颜色 -> 要么是 方块Mask.x 既[0 or 1] (√)，要么 BaseCol.rgb 
mov r9.w, r3.y 
movc r11.xyzw, r7.zzzz, r11.xyzw, r9.xyzw 		-> R11 颜色 <- [R9颜色*方块Mask.y] (√) 还是 [R9颜色.rgb, 0.2] 
mov r10.w, r11.w 								-> R10 颜色透明通道 = 0.2 * 方块Mask.y -> rgba = [0,0,0,0.2] or [1,1,1,0] 
mov r12.xyz, r4.xyzx 							-> R12 颜色 = BaseCol.rgb 
mov r12.w, r9.w 								-> R12 颜色.Alpha = R11.w = r3.y = 0.2 
movc r10.xyzw, r7.yyyy, r10.xyzw, r12.xyzw 		-> 新 R10 = 概率选 R10 或 R12=[BaseCol.rgb, 0.2] -> 是9号或5号方案就选10 

//重构世界坐标 
//先通过 [-1, +1] * Clip.w * View.z 计算出 Clip Space 下当前点xy，随后结合采样深度z重建世界空间坐标 
//注意1: 矩阵运算的目标向量处在Clip Space中，所以变换矩阵理应是 Inv_VP，且P矩阵只修改了XY分量(最后一列为[0,0,1,0])，保留Z分量不动 
//注意2: r1.xy 一直保持在 [-1, +1] * Clip.w 状态 
mul r4.xy, r1.zzzz, r1.xyxx 				-> R4.xy -> ClipSpace.xy -> [-1, +1] * (Clip.w * View.z) 
mul r8.xyw, r4.yyyy, cb1[49].xyxz 			-> cb1[49] ~ cb1[50] -> Matrix_Inv_VP -> 将物体从裁剪空间转回世界空间的矩阵 
mad r4.xyz, r4.xxxx, cb1[48].xyzx, r8.xywx 
mad r4.xyz, r1.zzzz, cb1[50].xyzx, r4.xyzx 
add r4.xyz, r4.xyzx, cb1[51].xyzx 			-> 最后一列存有: 'CameraPosWS' 
											-> toCameraVector= (inverse(viewMatrix)*vec4(0,0,0,1.0)).xyz-worldPosition.xyz; 

//-ViewDirWS -> R8 -> From Camera To ViewPoint 
add r8.xyw, r4.xyxz, -cb1[67].xyxz    		-> 摄像机的世界空间坐标[-58890, 27509, -6150] 
dp3 r1.w, r8.xywx, r8.xywx 
rsq r1.w, r1.w 
mul r8.xyw, r1.wwww, r8.xyxw 				-> 归一化 


//计算不同材质的参数 R7.Z 和 R9.W：基于NdotV，掠视时值小， 俯视时值大 
//参数用于表现GI下物体表面漫反射强度 -> Diffuse部分 -> 一般基于 NdotV 
dp3 r1.w, r6.xyzx, -r8.xywx  					-> NdotV -> Normal 和 ViewDir 都是单位向量，所有点乘后得到 cosθ 
mov_sat r3.x, r1.w   							-> saturate(NdotV) = NdotV -> 做sat似乎没必要 
mad r7.z, r3.x, l(0.500000), l(0.500000)    	-> NdotV * 0.5 + 0.5 
mad r7.z, r7.z, r3.x, l(-1.000000) 				-> (NdotV * 0.5 + 0.5) * NdotV - 1  -> 若(V ⊥ N) 得-1，反之得0 
mad_sat r7.w, -r3.w, l(1.250000), l(1.250000)	-> saturate(1.25 - 1.25*[t9.w=0.69]) -> 不同材质不同缩放比例 
mul r9.w, r7.w, r7.z 							-> saturate(1.25 - 1.25*[t9.w=0.69]) * ((NdotV*0.5+0.5)*NdotV-1) -> [-1, 0]区间 
mad r7.z, r7.z, r7.w, l(1.000000) 				-> 类似 R9.w -> 转换到 [0, 1] 区间，垂直得0，同向得1 

//将 R10 颜色 与 NdotV 以某种形式混淆 
//基于R10颜色生成的 -> R13 属于 [0.15, 1.01]区间; R12 属于 [0, 1.11]区间 
//另外，(col^2 - col)*t + col -> 这种模式的颜色操作等效于对原始颜色进行 "非线性提亮" 
//中间变量 R13 特性: 当垂直看时三通道都为1，掠射时各通道按比例衰减一定幅度 
//输出 R12 颜色 按照视角的大小，表现出由暗到明(原始色)的过渡 
mul r12.xyz, r10.xyzx, l(1.111111, 1.111111, 1.111111, 0.000000)  				-> R12 颜色 = R10 颜色 * 1.11 -> "线性提亮" 
add r7.w, r3.x, l(-1.000000) 													-> NdotV - 1 
mul r7.w, r7.w, l(0.850000) 													-> 0.85 * (NdotV - 1) -> [-0.85, 0]区间 
mad r13.xyz, r12.xyzx, r12.xyzx, -r12.xyzx 										-> (R12)^2 - R12 -> [-0.25, 0.1221]区间 
mad r13.xyz, r13.xyzx, l(-0.780000, -0.780000, -0.780000, 0.000000), r12.xyzx   -> R12-0.78*[(R12)^2 - R12] -> [0, 1.01]区间 
add r13.xyz, -r13.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000) 				-> 1-{R12-0.78*[(R12)^2 - R12]}->[-0.01, 1]区间 
mad r13.xyz, r7.wwww, r13.xyzx, l(1.000000, 1.000000, 1.000000, 0.000000) -> R13=0.85*(NdotV-1)*{1+0.78*[(R12)^2 - R12]-R12} + 1 
mul r12.xyz, r12.xyzx, r13.xyzx 												-> R12 颜色 = R12 * R13 

//r5.x 来自 T11，既纹理11 (叶子+人物有颜色，其他为黑的纹理)，似乎用来控制(开关) 菲尼尔效果的Flag 
//如下的 r12.w 构成了 Shilick Fresnel 的核心元素: (1 - cosθ)^5, 而 r7.w 关联 Fresnel_Term (可通过函数曲线验证) 
//r7.z 与 r7.w 相比，随着视角倾斜，数值下降趋势比较缓和 
//对于屋顶和木墙而言，输出颜色 R12 任然只是趋向 R10 
//而树叶之类，其输出颜色 R12 受到Fresnel影响比较大 
add r7.w, -r3.x, l(1.000000)  				-> 1 - NdotV -> [0, 1] 
mul r11.w, r7.w, r7.w 						-> (1 - NdotV)^2 
mul r11.w, r11.w, r11.w 					-> (1 - NdotV)^4 
mul r12.w, r7.w, r11.w 						-> R12.w = (1 - NdotV)^5 
mad r7.w, -r11.w, r7.w, l(1.000000)  		-> 1 - (1 - NdotV)^5 
mad r7.w, r7.w, l(0.040000), r12.w  		-> 0.04 * [1 - (1 - NdotV)^5] + (1 - NdotV)^5 -> Fresnel_Term 
mad r7.w, r5.x, -r7.w, l(1.000000) 			-> 1 - Fresnel_Term * r5.x -> 如果r5.x为控制开启阀门，整体返回值是与1的互补数 
mul r13.xyz, r7.wwww, r10.xyzx 				-> R13 = R10颜色 * (1 - Fresnel_Term) -> 如果开启，掠视时R10会被压制 
mul r12.xyz, r7.zzzz, r12.xyzx 				-> R12颜色 * [形似(1-Fresnel_Term),但缓和] 
mul r7.z, r5.x, r6.w 						-> r7.z = [0] * [0 or Purple.y]  -> 开启条件:开启了F项，同时不是类型9的材质 
mad r12.xyz, r12.xyzx, l(0.90, 0.90, 0.90, 0.0), -r13.xyzx  -> R12 = 0.9 * R12颜色 - R13颜色 -> 用减号形成Fresnel现象 
mad r12.xyz, r7.zzzz, r12.xyzx, r13.xyzx 	-> R12 = r7.z * R12 + R13 -> 屋顶材质应当使用的是 R13颜色  

//采样 AO -> R7.z  
sample_l_indexable(texture2d)(float,float,float,float) r7.z, r0.xyxx, t13.yzxw, s7, l(0.000000) 

//求半分辨率下的 UV 
mad r13.xy, -cb1[129].xyxx, cb1[131].zwzz, r0.xyxx 						-> 屏幕UV - 0 * (屏幕长宽的倒数) -> UV 偏移 
min r13.xy, r13.xyxx, cb0[6].xyxx 										-> 不能超过 0.998 -> 确保在像素中点位置? 
mul r13.zw, cb1[131].xxxy, l(0.000000, 0.000000, 0.500000, 0.500000) 	-> 求 "半" 屏幕的长宽 
round_ni r13.zw, r13.zzzw  												-> floor("半"屏幕的长宽) 
div r14.xy, l(1.000000, 1.000000, 1.000000, 1.000000), r13.zwzz 		-> "半"屏幕的长宽 の 倒数 
mad r15.xy, r13.xyxx, r13.zwzz, l(-0.5, -0.5, 0, 0) -> 正常屏幕UV * "半"屏幕的长宽 - 0.5 -> '大'像素位置, 注意可能移到左/下邻'大'像素  
round_ni r15.xy, r15.xyxx 												-> floor("半"屏幕下的像素位置) , 最小为 0 
div r15.xy, r15.xyxx, r13.zwzz 											-> 新UV, 采样率相对原始UV减半，位置在田字格的左下角(真角落)  
mad r15.xy, r14.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000), r15.xyxx -> 增加1小像素偏移 -> 让当前降采样UV对准田字格正中心 
add r13.xy, r13.xyxx, -r15.xyxx   				-> 正常采样的当前点UV - 半分辨率UV = UV_delta -> 田的中心点到实际当前像素距离 
mul r15.zw, r13.zzzw, r13.xxxy					-> 半分辨率下 UV_delta 占用了(0.25或0.75)个大像素点长度  

//采样 T6 (疑似NormalWS纹理, 本身分辨率为原始值的一半)  
//采样了田字四邻域，分布存放在 R16,R17,R18和R14中 
//注意，降分辨率下的一个田字的每个口，都代表正常分辨率下的一个田 -> 采样覆盖正常分辨率下16邻域 
sample_l_indexable(texture2d)(float,float,float,float) r16.xyzw, r15.xyxx, t6.xyzw, s5, l(0.000000)  
mov r14.z, l(0)  						-> r14.xyz = ["半"屏幕的长宽の倒数, 0]; r15.xy = [降采样后当前点UV] 
add r17.xyzw, r14.xzzy, r15.xyxy		-> r17.xyzw = [降采样后U + 1, 降采样后V, 降采样后U, 降采样后V + 1] 
sample_l_indexable(texture2d)(float,float,float,float) r18.xyzw, r17.xyxx, t6.xyzw, s5, l(0.000000) 
sample_l_indexable(texture2d)(float,float,float,float) r17.xyzw, r17.zwzz, t6.xyzw, s5, l(0.000000) 
add r14.xy, r14.xyxx, r15.xyxx    		-> r14.xy = [UV + 一个像素] 
sample_l_indexable(texture2d)(float,float,float,float) r14.xyzw, r14.xyxx, t6.xyzw, s5, l(0.000000) 

//这里从T6纹理(半分辨率) W 通道获取 Depth_1，拿来和(全分辨率下)深度图的 Depth_2 求差异 
//最后基于当前像素在田字格位置，加权求和 Diff_Depth，存入 R7.w 
// r13 = [UV_delta, "半"屏幕的长宽] 
mad r13.xy, -r13.yxyy, r13.wzww, l(1.000000, 1.000000, 0.000000, 0.000000)	-> (1 - 大像素_delta).yx 
mul r19.x, r13.y, r13.x  				-> r19.x = [当前点在田字左下格时: 1], [右上: 0.25], [其他: 0.5]  ? 
mul r19.yz, r15.zzwz, r13.xxyx 			-> 大像素_delta.xy * (1 - 大像素_delta).yx  -> 可以区分 ↑，→，↗和本身共4中情况 ? 
mul r19.w, r15.z, r15.w 				-> 区分是否是 右上 格子 -> [右上: 0.25], [其他: 0] ? 
mov r13.x, r16.w 						-> R13 = [左下, 上，右, 右上].(看起来像距离参数，数值普遍大于100，天空在65530附近) 
mov r13.y, r18.w
mov r13.z, r17.w
mov r13.w, r14.w
add r13.xyzw, -r1.zzzz, r13.xyzw 		-> R13 = 田字4个位置的: T6纹理存的Depth - 当前帧深度纹理解码的Depth 
add r13.xyzw, |r13.xyzw|, l(0.000100, 0.000100, 0.000100, 0.000100) 	-> 给 Diff_Depth 加上一个很小的正数，确保都大于0 
div r13.xyzw, l(1.000000, 1.000000, 1.000000, 1.000000), r13.xyzw 		-> Diff_Depth の 倒数 
mul r13.xyzw, r13.xyzw, r19.xyzw 										-> 基于当前像素在田字格中位置，修正4个 (1/D_Depth) 
dp4 r7.w, r13.xyzw, l(1.000000, 1.000000, 1.000000, 1.000000) 			-> 求和田字格区域的这 4个 (1/D_Depth) 
div r7.w, l(1.000000, 1.000000, 1.000000, 1.000000), r7.w 				-> 相当于求解了4个 Diff_Depth 的加权平均 

mul r15.xyz, r18.xyzx, r13.yyyy 				-> 对应田字位置的 (1/D_Depth) * 对应位置的采样结果.xyz 
mad r15.xyz, r13.xxxx, r16.xyzx, r15.xyzx 		-> 4个位置的结果累加起来 -> R13 
mad r13.xyz, r13.zzzz, r17.xyzx, r15.xyzx 
mad r13.xyz, r13.wwww, r14.xyzx, r13.xyzx 

add r11.w, -r1.z, cb0[2].w 						-> 20000 - 当前帧深度纹理解码的Depth 
mul_sat r11.w, r11.w, cb0[3].x 					-> saturate((20000-Depth)/6000) -> 用于Scale，距离近:1，距离远:0 
mov r14.xyz, -r6.xyzx 							-> R14 = -Normal 
mad r13.xyz, r13.xyzx, r7.wwww, r14.xyzx 		-> (田字4方向独自通过(1/D_Depth)累加后 * D_Depth加权平均).xyz + (-Normal) 
mad r13.xyz, r11.wwww, r13.xyzx, r6.xyzx 		-> R13 = Scale * 从原Norm顶点指向新Norm顶点的向量(正向扰动矢量) + 原Normal向量 


if_nz r7.x  	-> 大概率能进，除非 [Purple.y修改值] * 255 的后4个bit位全是 0  
  mad r15.xyz, -r10.xyzx, r6.wwww, r10.xyzx 				-> R10颜色 - R10颜色 * Purple.y 
  mad r15.xyz, r15.xyzx, cb1[135].wwww, cb1[135].xyzx  		-> 上面的颜色 * 1 + 0 
  mad r16.xyz, -r12.xyzx, r6.wwww, r12.xyzx 				-> R12颜色 - R12颜色 * Purple.y 
  movc r15.xyz, r8.zzzz, r16.xyzx, r15.xyzx 				-> Condition 如果是 4号 材质方案的话，使用R16颜色，不然就用R15  

  dp3 r7.w, r13.xyzx, r13.xyzx  							-> 归一化 R13 扰动法线向量 -> R16 -> 定义为RandomNorm 或 (Rn)
  sqrt r7.w, r7.w
  max r11.w, r7.w, l(0.000010)
  div r16.xyz, r13.xyzx, r11.wwww

  //计算标量r11.w -> 无扰动时=1, 强扰动时=扰动向量模长 
  mad r17.xyz, r2.xyzx, r2.wwww, -r16.xyzx  				-> 法向量 - 扰动法线向量 = 反向扰动矢量 
  mad r17.xyz, r7.wwww, r17.xyzx, r16.xyzx 					-> 按R13的模长放大 '反向扰动矢量' 
  dp3 r11.w, r16.xyzx, r6.xyzx 								-> Dot(扰动法线向量, NormalWS) -> NdotRn 
  add r12.w, -r11.w, l(1.000000) 							-> 1 - NdotRn -> 扰动越大，值越大 
  mad r11.w, r7.w, r12.w, r11.w  							-> (1 - NdotRn) * 扰动向量模长 + NdotRn 

  //未知 
  mad r7.w, r7.w, l(10.000000), l(-5.000000)   				-> 扰动向量模长 * 10 - 5 
  mul r7.w, r7.w, -cb0[8].x 								-> (扰动向量模长 * 10 - 5) * (-0.01) 
  mul r7.w, r7.w, l(1.442695) 								-> -1.442695 * (10*模长 - 5) / 100 -> Log2E = 1.442695 
  exp r7.w, r7.w 											-> exp((5 - 10*模长) / 100) 	-> 这里假设 exp 实际上是 exp2 
  add r7.w, r7.w, l(1.000000) 								-> exp((5 - 10*模长) / 100) + 1 
  div r7.w, l(1.000000, 1.000000, 1.000000, 1.000000), r7.w -> 1 / [exp((5 - 10*模长) / 100) + 1] 
  mad_sat r7.w, r7.w, cb0[8].y, cb0[8].z 					-> saturate(40.0/[exp((5 - 10*模长) / 100) + 1] - 19.5) -> 记为X 
  log r7.w, r7.w 											-> r7.w = LOG(X) -> 小于0的数 
  mul r7.w, r7.w, cb0[8].w 									-> LOG(X) * 0.7 
  exp r7.w, r7.w 											-> exp(LOG(X) * 0.7) -> X^0.7 
  add r12.w, -r7.w, l(1.000000) 							-> 1 - X^0.7 
  mad r7.w, cb0[1].w, r12.w, r7.w 							-> (1 - X^0.7) * 0 + X^0.7 -> lerp 
  eq r12.w, cb0[9].x, l(0.000000) 							-> 1 != 0 -> r12.w = false
  min r13.w, r4.w, r7.z 									-> min(Purple.z, {Tex11.x * [0 or Purple.y]}) -> Tex11.x = 0
  min r15.w, r7.w, r13.w 									-> min(X^0.7, 0)
  mul r7.w, r7.w, r13.w 									-> X^0.7 * 0
  movc r7.w, r12.w, r15.w, r7.w 							-> 还是 r7.w -> 0

  ieq r16.xyzw, r7.xxxx, l(6, 2, 3, 7) 						-> [Purple.y修改值] * 255 的后4个bit <-> [6,2,3,7]
  //未知 
  if_nz r16.x 												-> 后4-bit == 6的情况 
    mov r14.w, l(1.000000)
    dp4 r18.x, cb1[181].xyzw, r14.xyzw 						-> r14 = -Normal
    dp4 r18.y, cb1[182].xyzw, r14.xyzw 						-> 似乎是某种朝向扰动 
    dp4 r18.z, cb1[183].xyzw, r14.xyzw
    mul r14.xyzw, r6.yzzx, r6.xyzz        					-> 无法理解的操作 -> 产生一个新的向量? 
    dp4 r19.x, cb1[184].xyzw, r14.xyzw 						-> 某种扰动操作 
    dp4 r19.y, cb1[185].xyzw, r14.xyzw
    dp4 r19.z, cb1[186].xyzw, r14.xyzw
    mul r12.w, r6.y, r6.y
    mad r12.w, r6.x, r6.x, -r12.w  							-> Normal.x^2 - Normal.y^2 
    add r14.xyz, r18.xyzx, r19.xyzx 						-> 叠加操作过后的2个向量 -> R14 
    mad r14.xyz, cb1[187].xyzx, r12.wwww, r14.xyzx 			-> [-0.016，-0.01，-0.003] * (Normal.x^2 - Normal.y^2) + R14 -> R14 
    max r14.xyz, r14.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)
    mul r14.xyz, r14.xyzx, cb1[180].xyzx 					-> [4.9, 4.1, 3.1] * R14 
    mul r18.xyz, r5.xyzx, r5.xyzx
    mul r14.xyz, r7.wwww, r14.xyzx
    mul r14.xyz, r18.xyzx, r14.xyzx 						-> 基于r7.w = 0, 返回值 R14 = 0 
  else 
    mov r14.xyz, l(0,0,0,0)
  endif 

  or r12.w, r16.z, r16.y 									-> 2个渲染分支条件满足一个即可，既r12.w用于控制 r16.zy 所对应分支的渲染 
  mul r16.xyz, r5.xyzx, r5.xyzx 							-> r5^2: r5 来自 T11 纹理，对除了人物和叶子外的区域，大多是[0,0,0,0] 
  mad r18.xyz, r5.xyzx, r5.xyzx, r15.xyzx  					-> r5^2 + r15颜色 
  movc r15.xyz, r12.wwww, r18.xyzx, r15.xyzx 				-> Condition: 选择 (r5^2 + r15颜色) or r15颜色

  //以下分支计算用于 新的 R15 颜色 
  if_nz r16.w 												-> r16.w 分支控制 
  	//求 -ViewDirWS? 
  	//r1.xy 存放了 [-1, +1] * Clip.w -> 没有乘具体Depth -> 全屏Blit使用的三角形片所处的深度切片，xy分量在那个深度上是正确的 
    mul r18.xyz, r1.yyyy, cb1[49].xyzx						-> Matrix_Inv_VP 的前 3X3 区域
    mad r18.xyz, r1.xxxx, cb1[48].xyzx, r18.xyzx			-> 相当于将视空间坐标的 z 分量设置为1
    add r18.xyz, r18.xyzx, cb1[50].xyzx    				 	-> 然后以行向量形式 左乘 逆矩阵中控制旋转和缩放的部分 
    dp3 r1.x, r18.xyzx, r18.xyzx
    rsq r1.x, r1.x
    mul r18.xyz, r1.xxxx, r18.xyzx 							-> 再归一化 -> 得到 -ViewDirWS -> 疑惑:为何不用 CamWS - PosWS 

    //求 ‘法-视平偏向量’ 
    dp3 r1.x, -r18.xyzx, r6.xyzx 							-> NdotV 
    mad r19.xyz, -r6.xyzx, r1.xxxx, -r18.xyzx 				-> NdotV * -Normal + ViewDir -> <法-视平偏向量> 
    dp3 r1.y, r19.xyzx, r19.xyzx
    rsq r5.z, r1.y
    mul r17.xyz, r5.zzzz, r19.xyzx 							-> 归一化 <法-视平偏向量> 

    //控制粗糙度范围 
    max r5.z, r3.w, l(0.003922) 							-> max([t9.w=0.69], 0.0039) -> roughness 
    min r5.z, r5.z, l(1.000000) 							-> min(0.69, 1.0) -> 粗糙度控制在[0,1]内 

	//<法-视平偏向量> dot ViewDir -> 视线趋向掠射角:得1,  视线趋向垂直物体表面:得0 
    dp3 r12.w, -r18.xyzx, r17.xyzx 							-> ViewDir dot <法-视平偏向量> -> 归一化前<法-视平偏向量>的模长 

    //这是比较疑惑的操作，r6法线与天然垂直于法线的r17<法-视平偏向量>之间的点乘永远得0，不知为何有此操作 
    dp3 r13.w, r6.xyzx, r17.xyzx 							-> Normal dot <法-视平偏向量> -> 0 

    //以下代码为: fast_acos(float v) -> 搜索关键数值'-0.156583'可得相关资料 
    //π/2 = 1.570796
    mad r14.w, |r1.x|, l(-0.156583), l(1.570796) 			-> -0.156583 * |NdotV| + 1.570796
    add r15.w, -|r1.x|, l(1.000000) 						-> 1 - |NdotV|
    sqrt r15.w, r15.w 										-> sqrt(1 - |NdotV|)
    mul r16.w, r14.w, r15.w 								-> (-0.156583 * NdotV + 1.570796) * sqrt(1 - |NdotV|) -> 记A角度
    ge r18.x, r1.x, l(0.000000) 							-> NdotV >= 0 ? true : false 
    mad r14.w, -r14.w, r15.w, l(3.141593) 					-> π - (-0.156583 * NdotV + 1.570796) * sqrt(1 - |NdotV|)
    movc r14.w, r18.x, r16.w, r14.w 						-> Condition: r14.w = A角度(true)  or  π-A角度(false) 
    add r14.w, -r14.w, l(1.570796) 							-> 角度r14.w  -> N与V的夹角 

    //以下代码为: fast_acos(float v) 
    mad r15.w, |r13.w|, l(-0.156583), l(1.570796)
    add r16.w, -|r13.w|, l(1.000000)
    sqrt r18.x, r16.w
    mul r18.y, r15.w, r18.x
    ge r18.z, r13.w, l(0.000000)
    mad r15.w, -r15.w, r18.x, l(3.141593)
    movc r15.w, r18.z, r18.y, r15.w
    add r15.w, -r15.w, l(1.570796) 							-> 角度r15.w -> N与<法-视平偏向量>的夹角 -> 固定 90° 

    //求 -ViewDir 与 -<法-视平偏向量> 夹角一半的余弦值 -> 未知用途 
    add r14.w, r14.w, -r15.w 								-> dif_Angle = N与V的夹角 - N与<法-视平偏向量>的夹角 
    mul r14.w, |r14.w|, l(0.500000)  						-> 0.5 * |dif_Angle| 
    sincos null, r14.w, r14.w 								-> cos(0.5 * |dif_Angle|) 

    //未知 
    mad r18.xyz, -r13.wwww, r6.xyzx, r17.xyzx 				-> -Normal * 0 + 归一化<法-视平偏向量> 
    dp3 r15.w, r18.xyzx, r19.xyzx 							-> 上面的向量 dot 原始<法-视平偏向量> -> 原始模长 
    dp3 r18.x, r18.xyzx, r18.xyzx 							-> 1 
    mad r1.y, r18.x, r1.y, l(0.000100) 						-> 原始<法-视平偏向量> 点乘自己的结果 + 0.0001 
    rsq r1.y, r1.y 											-> 原始<法-视平偏向量> 归一化系数 (确保取倒数时不会遇到除零的情况) 
    mul r1.y, r1.y, r15.w 									-> 1 
    mad r18.xy, r1.yyyy, l(0.5, 17.0, 0, 0), l(0.5, -16.780001, 0, 0)	-> 1*(0.5,17) + (0.5,-16.78) = (1, 0.219) 
    mov_sat r18.x, r18.x 									-> sat(1) = 1
    sqrt r1.y, r18.x 										-> 1

    mul r15.w, r5.z, r5.z 									-> roughness^2 = 0.69^2 = 0.476
    mad r5.z, r5.z, r5.z, l(0.200000) 						-> roughness^2 + 0.2 = 0.676 
    mad r15.w, r15.w, l(2.000000), l(0.200000)				-> 2*roughness^2+0.2 = 1.152
    mad r18.z, -r1.x, r1.x, l(1.000000) 					-> 1 - NdotV * NdotV = 1 - cosθ^2 = sinθ^2 
    sqrt r18.z, r18.z 										-> sinθ -> θ:N与V夹角 
    mul r18.xw, r1.yyyx, l(0.997551, 0, 0, -0.069943) 		-> [0.997551*1, -0.069943*NdotV] 
    mad r18.x, r18.x, r18.z, r18.w 							-> r18.x = 0.997*sinθ - 0.069943*cosθ 
    mul r5.z, r1.y, r5.z 									-> (roughness^2 + 0.2) * 1 = 0.676
    mul r18.zw, r5.zzzz, l(0, 0, 1.414214, 3.544908)		-> r18.zw = 1*(roughness^2 + 0.2) * [1.414214, 3.544908]
    add r1.x, r1.x, r13.w 									-> NdotV + 0
    mad r5.z, -r18.x, l(-0.139886), r1.x 					-> cosθ - 0.139886*(0.997*sinθ - 0.069943*cosθ) -> R5Z 
    mul r5.z, r5.z, r5.z 									-> R5Z^2
    mul r5.z, r5.z, l(-0.500000) 							-> -R5Z^2 / 2 
    mul r13.w, r18.z, r18.z 								-> sqrt(2)*1*(roughness^2+0.2) 
    div r5.z, r5.z, r13.w 									-> -R5Z^2 / (2 * sqrt(2)*1*(roughness^2+0.2))
    mul r5.z, r5.z, l(1.442695) 							-> 1.442695 * -R5Z^2 / (2 * sqrt(2)*1*(roughness^2+0.2))
    exp r5.z, r5.z 											-> exp( -R5Z^2 / (2*sqrt(2)*1*(roughness^2+0.2)) ) -> R5Z'
    div r5.z, r5.z, r18.w  									-> R5Z' / 3.544908*1*(roughness^2+0.2)
    mul r1.y, r1.y, r5.z 									-> r1.y = 上式 


    mad_sat r5.z, r12.w, l(0.500000), l(0.500000) 			-> (ViewDir dot <法-视平偏向量>) * 0.5 + 0.5
    sqrt r5.z, r5.z 										-> sqrt(dot(v, nvpv) * 0.5 + 0.5) 
    add r5.z, -r5.z, l(1.000000) 							-> 1 - sqrt(dot(v, nvpv)*0.5+0.5)
    mul r13.w, r5.z, r5.z  									-> [1 - sqrt(dot(v, nvpv)*0.5+0.5)]^2 
    mul r13.w, r13.w, r13.w 								-> [1 - sqrt(dot(v, nvpv)*0.5+0.5)]^4 
    mul r5.z, r5.z, r13.w 									-> [1 - sqrt(dot(v, nvpv)*0.5+0.5)]^5 
    mad r5.z, r5.z, l(0.953479), l(0.046521) 				-> 0.953479 * [1 - sqrt(dot(v, nvpv)*0.5+0.5)]^5 + 0.046521
    mul r1.y, r1.y, r5.z 									-> R5Z'/3.544908*1*(roughness^2+0.2) * [a*(1-sqrt(.))^5+b] 
    mul r1.y, r10.w, r1.y 									-> [0.2 or 0] * 上面r1.y -> R1Y 


    mov_sat r12.w, -r12.w 									-> saturate(-dot(v, nvpv)) 
    add r5.z, -r12.w, l(1.000000) 							-> 1 - saturate(-dot(v, nvpv)) 

    add r1.x, r1.x, l(-0.140000) 							-> NdotV - 0.14
    mul r1.x, r1.x, r1.x 									-> (NdotV - 0.14)^2
    mul r1.xy, r1.xyxx, l(-0.500000, 0.500000, 0, 0) 		-> [-0.5*(NdotV - 0.14)^2,  0.5*R1Y]
    mul r10.w, r15.w, r15.w 								-> (2*roughness^2+0.2)^2
    div r1.x, r1.x, r10.w 									-> -0.5*(NdotV - 0.14)^2 / (2*roughness^2+0.2)^2
    mul r1.x, r1.x, l(1.442695) 
    exp r1.x, r1.x 											-> exp(-0.5*(NdotV - 0.14)^2 / (2*roughness^2+0.2)^2)
    mul r10.w, r15.w, l(2.506628) 							-> (2*roughness^2+0.2)*2*sqrt(π)
    div r1.x, r1.x, r10.w 			-> exp(-0.5*(NdotV-0.14)^2/(2*roughness^2+0.2)^2) / (2*roughness^2+0.2)*2*sqrt(π)
    mad r10.w, -r14.w, l(0.500000), l(1.000000) 			-> 1 - 0.5 * cos(0.5 * |dif_Angle|) 
    mul r12.w, r10.w, r10.w 								-> (1-cos(|dif_Angle|/2)/2)^2 
    mul r12.w, r12.w, r12.w 								-> (1-cos(|dif_Angle|/2)/2)^4
    mul r10.w, r10.w, r12.w 								-> (1-cos(|dif_Angle|/2)/2)^5
    mad r10.w, r10.w, l(0.953479), l(0.046521) 				-> 0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521 	-> 	R10W
    add r12.w, -r10.w, l(1.000000) 							-> 1 - [0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]
    mul r12.w, r12.w, r12.w 								-> {1-[0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]}^2 
    mul r10.w, r10.w, r12.w 								-> {1-[0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]}^2 * R10W
    div r12.w, l(0.800000), r14.w 							-> 0.8 / cos(0.5 * |dif_Angle|)
    log r18.xzw, r10.xxyz 									-> ln(R10颜色) 
    mul r18.xzw, r12.wwww, r18.xxzw 						-> [0.8 / cos(|dif_Angle|/2)] * ln(R10颜色) 
    exp r18.xzw, r18.xxzw 									-> exp2([0.8 / cos(|dif_Angle|/2)] * ln(R10颜色))
    mul r12.w, r18.y, l(1.442695) 
    exp r12.w, r12.w 										-> exp(0.219)
    mul r1.x, r1.x, r12.w    -> exp(0.219) * exp(-0.5*(NdotV-0.14)^2/(2*roughness^2+0.2)^2) / (2*roughness^2+0.2)*2*sqrt(π) -> R1X
    mul r1.x, r10.w, r1.x 				-> R1X * {1-[0.953479*(1-cos(|dif_Angle|/2)/2)^5 + 0.046521]}^2 * R10W -> R1X'
    mul r18.xyz, r18.xzwx, r1.xxxx 							-> exp2([0.8 / cos(|dif_Angle|/2)] * ln(R10颜色)) * R1X' 
    mad r18.xyz, r1.yyyy, r5.zzzz, r18.xyzx  				-> 0.5*R1Y * [1-saturate(-dot(v, nvpv))] + 上面r18.xyz  -> R18 

    dp3 r1.x, r17.xyzx, r17.xyzx 							-> dot(nvpv, nvpv)
    add r1.x, r1.x, l(1.000000)								-> 1 + dot(nvpv, nvpv)
    mul r1.x, r1.x, l(0.250000) 							-> 0.25 * [1 + dot(nvpv, nvpv)]
    min r1.x, r1.x, l(1.000000) 							-> min(0.25 * [1 + dot(nvpv, nvpv)], 1) -> 不大于1 -> _R1X
    add r1.y, -r1.x, r16.w 									-> (1 - |dot(n, nvpv)|) - _R1X
    mad r1.x, r1.y, l(0.330000), r1.x 						-> lerp( _R1X, 1-|dot(n, nvpv)|, 0.33 ) 
    mul r1.x, r1.x, r6.w 									-> [0 or Purple.y] * lerp( _R1X, 1-|dot(n, nvpv)|, 0.33 ) 
    mul r1.x, r1.x, l(0.318310) 							-> 0.31831 * [0 or Purple.y] * lerp( _R1X, 1-|dot(n, nvpv)|, 0.33 ) 
    sqrt r10.xyz, r10.xyzx  								-> sqrt(R10颜色) 
    mad r10.xyz, r10.xyzx, r1.xxxx, r18.xyzx  -> R18颜色 + sqrt(R10颜色) * {0.31831*[0 or Purple.y]*lerp(_R1X,1-|dot(n,nvpv)|,0.33)}
    min r10.xyz, -r10.xyzx, l(0, 0, 0, 0)  					-> min(-新R10颜色, 0) -> 结合下面乘 -π -> 抹去负数 
    mul r15.xyz, r10.xyzx, l(-3.141593, -3.141593, -3.141593, 0)  -> R15颜色 = π * R10颜色 
  endif 

  //以下似乎用于计算 输出颜色的 Alpha 通道 
  ieq r1.x, r7.x, l(8) 							-> [Purple.y修改值] * 255 的后4个bit <-> [8] -> 是否是 8 号材质 
  mad r10.xyz, r16.xyzx, r5.wwww, r15.xyzx 		-> T11.w * [r5^2] + R15颜色 
  movc r10.xyz, r1.xxxx, r10.xyzx, r15.xyzx 	-> Condition: 依据 r1.x 选择 {[r5^2] + R15颜色} 或 R15颜色
  mov r17.w, l(1.000000) 						-> R17.xyz 是关于法线的一种扰动向量，在某些情况下等于 <法-视平偏向量> nvpv 
  dp4 r15.x, cb1[181].xyzw, r17.xyzw 			-> 调整向量朝向 -> R15 
  dp4 r15.y, cb1[182].xyzw, r17.xyzw
  dp4 r15.z, cb1[183].xyzw, r17.xyzw
  mul r16.xyzw, r17.yzzx, r17.xyzz 				-> 基于R17向量进行一个随机化处理? 
  dp4 r18.x, cb1[184].xyzw, r16.xyzw 			-> 对处理后向量再进行一次朝向调整 -> R18 
  dp4 r18.y, cb1[185].xyzw, r16.xyzw
  dp4 r18.z, cb1[186].xyzw, r16.xyzw
  mul r1.x, r17.y, r17.y
  mad r1.x, r17.x, r17.x, -r1.x 				-> x^2 - y^2 -> R17.xy 
  add r15.xyz, r15.xyzx, r18.xyzx 				-> 向量叠加 
  mad r15.xyz, cb1[187].xyzx, r1.xxxx, r15.xyzx -> [-0.016,-0.01,-0.003] * (x^2 - y^2) + 上面向量叠加结果 
  max r15.xyz, r15.xyzx, l(0,0,0,0) 
  mul r15.xyz, r15.xyzx, cb1[180].xyzx 			-> [4.9,4.19,3.1] * 上面结果 
  mul r1.x, r11.w, r7.w 						-> [(1 - NdotRn) * 扰动向量模长 + NdotRn] * 0? 
  add r1.y, -r7.w, l(1.000000) 					-> 1 - 0? = 1 
  mul r16.xyz, r1.yyyy, cb0[1].xyzx 			-> [0.045,0.05,0.029] * 1 
  mad r15.xyz, r1.xxxx, r15.xyzx, r16.xyzx 		-> 叠加并偏移后的向量 * 全局法线扰动Scale(对静态物体为0) + 基础值(向量?) 
  mad r10.xyz, r15.xyzx, r10.xyzx, r14.xyzx 	-> R10 = R15向量 * R10颜色 + R14(全0) 
  mul r10.xyz, r10.xyzx, cb1[134].yyyy 			-> R10 *= 1 -> 这是个颜色 
  eq r1.x, cb1[200].z, l(0.000000) 				-> 1 == 0 ? false 
  dp3 r1.y, r10.xyzx, l(0.300000, 0.590000, 0.110000, 0)  -> 取 R10 颜色 强度 
  and r1.y, r1.y, r1.x
  and r1.y, r1.y, r7.y 							-> r7.y = 是 9号 或 5号 材质渲染方案之一就为true 
  and o0.w, r1.y, r1.x 							-> 输出 Alpha, 因为连续使用了 and，且r1.x 肯定为 0， 这里输出应当为 0 
else 
  mov r10.xyz, l(0,0,0,0) 						-> 这是最外层 if 的 else 分支 
  mov o0.w, l(0) 								-> 设置 r10颜色为 全黑(0), a通道=0 
endif 

//下午干完下面全部! 
ine r1.xy, r7.xxxx, l(0, 7, 0, 0)  				-> [Purple.y修改值] * 255 的后4个bit <-> [0, 7] 
and r1.x, r1.y, r1.x 							-> 同时满足 -> 不是0号和7号材质渲染方案  
if_nz r1.x 
  movc r9.xyz, r7.yyyy, r11.xyzx, r9.xyzx 		-> 是5或9号材质渲染方案 -> 则使用 R11(环境光底色*方块Mask.y) -> 不然就用R9(环境光底色)  
  mad r9.xyz, r9.xyzx, cb1[136].wwww, cb1[136].xyzx 		-> R9 * 1 + 0 
  mad r1.x, r5.x, r9.w, l(1.000000)  			-> 1 + T11.x(菲涅尔等光照效果的开关?) * {[-1, 0]区间,与roughness和NoV有关}
  mul r1.y, r1.x, l(0.080000)  					-> 0.08 * (1 + T11.x * {[-1, 0]区间,与roughness和NoV有关}) 
  mad r11.xyz, -r1.xxxx, l(0.08, 0.08, 0.08, 0), r12.xyzx	->R11 = R12颜色 - 0.08*(1 + T11.x*{[-1, 0]区间,与roughness和NoV有关}) 
  mad r11.xyz, r6.wwww, r11.xyzx, r1.yyyy 		-> R11=[0 or Purple.y] * R11色 + 0.08*(1+T11.x*{[-1, 0]区间,与roughness和NoV有关}) 
  movc r9.xyz, r8.zzzz, r11.xyzx, r9.xyzx 		-> 依据是否是 4号 材质方案设置 R9颜色 (R11 or R9) 
  add r1.x, r1.w, r1.w  						-> NdotV + NdotV
  mad r11.yzw, r1.xxxx, r6.xxyz, r8.xxyw		-> Normal * 2(NdotV) + (-ViewDirWS) 
  mul r1.x, r3.w, r3.w 							-> roughness^2 
  mad r1.y, -r3.w, r3.w, l(1.000000) 			-> 1 - roughness^2 
  sqrt r1.w, r1.y 								-> sqrt(1 - roughness^2)
  mad r1.w, r3.w, r3.w, r1.w 					-> roughness^2 + sqrt(1 - roughness^2)
  mul r1.y, r1.w, r1.y 							-> (1 - roughness^2) * [roughness^2 + sqrt(1 - roughness^2)] -> 某种Scale 
  mad r2.xyz, -r2.xyzx, r2.wwww, r11.yzwy 		-> Normal * 2(NdotV) + (-ViewDirWS)  - Normal -> 略抬视向(-ViewDirUpLite)
  		-> 这是什么? -> 首先拔高Normal，变为[0,2]区间;其次从入射单位视线的尾，看向Normal的顶;最后用-Norm把视角向下拉一个单位长度 
  mad r2.yzw, r1.yyyy, r2.xxyz, r6.xxyz			-> 某种Scale * (-ViewDirUpLite) + Normal -> 超抬视向 (注:没有归一化) 

  //使用屏幕UV采样 T12 -> 自发光相关纹理 
  sample_indexable(texture2d)(float,float,float,float) r6.xyzw, r0.xyxx, t12.xyzw, s6 
  add r0.x, -r6.w, l(1.000000) 							-> 1 - T12.a 
  mad r12.xyzw, r6.xyzw, l(1, 1, 1, -1), l(0, 0, 0, 1)	-> [T12.xyz, 1 - T12.w] 
  add r14.xyzw, -r12.xyzw, l(0, 0, 0, 1)  				-> [-T12.xyz, T12.w] 
  mad r14.xyzw, r5.xxxx, r14.xyzw, r12.xyzw 			-> r14 = [-T12.xyz, T12.w] * T11.x(控制阀) + [T12.xyz, 1 - T12.w] 
  movc r12.xyzw, r8.zzzz, r14.xyzw, r12.xyzw 			-> r12 = 4号材质 ? r14 : [T12.xyz, 1 - T12.w] 
  
  mad r0.y, r4.w, r7.z, r3.x 							-> Purple.z * {Tex11.x * [0 or Purple.y]} + NdotV
  log r0.y, r0.y 										-> ln(Purple.z*{Tex11.x*[0 or Purple.y]} + NdotV) -> ln(NoV + noise?)
  mul r0.y, r0.y, r1.x 									-> ln(NoV + noise?) * roughness^2 
  exp r0.y, r0.y 										-> exp2( ln(NoV + noise?) * roughness^2 ) 
  mad r0.y, r4.w, r7.z, r0.y 			-> R0Y = Purple.z * {Tex11.x*[0 or Purple.y]} +  exp2( ln(NoV + noise?) * roughness^2 ) 
  add_sat r0.y, r0.y, l(-1.000000) 						-> saturate(R0Y - 1) 
  mul r1.x, r0.y, r12.w 								-> 自发光材质透明度 * saturate(R0Y - 1) 
  ftou r0.zw, r0.zzzw 									-> 屏幕像素索引(+0.5) to uint 
  mad r1.y, r1.z, cb3[3].x, cb3[3].y  					-> 当前帧深度纹理解码的Depth * 1 + 1 
  log r1.y, r1.y 										-> ln(Depth + 1) 
  mul r1.y, r1.y, cb3[3].z 								-> ln(Depth + 1) + 1 
  max r1.y, r1.y, l(0.000000) 							-> max(ln(Depth + 1) + 1, 0) -> 返回值不小于 0 
  ftou r1.y, r1.y 										-> max(ln(Depth + 1) + 1, 0) to uint 
  iadd r1.z, cb3[1].z, l(-1) 							-> 1 - 1 = 0 
  umin r1.y, r1.z, r1.y 								-> min(0, max(ln(Depth + 1) + 1, 0)) -> 似乎只能返回 0? -> 距离对数因子? 
  ushr r0.zw, r0.zzzw, cb3[2].xxxx 						-> 屏幕像素索引(+1) >> 1 -> 相当于半屏幕分辨率 
  imad r0.w, r1.y, cb3[1].y, r0.w 						-> 距离对数因子 * 1 + 半屏幕像素索引.v 
  imad r0.z, r0.w, cb3[1].x, r0.z 						-> 距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u 
  iadd r0.z, r0.z, cb3[0].w 							-> 距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1 
  ishl r0.w, r0.z, l(1) 								-> (距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 0 
  
  //访问 T3 表 -> 下标为 r0.w = (距离对数因子 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 0
  ld_indexable(buffer)(uint,uint,uint,uint) r0.w, r0.wwww, t3.yzwx 		-> 取第一个元素(X)
  umin r0.w, r0.w, cb3[0].y 											-> min(r0.w=[0,1,...,4,5,6,7...], 1) -> 不高于1? 
  bfi r0.z, l(31), l(1), r0.z, l(1) 					-> (距离对数因子 * 1 + 半屏幕像素索引.v  + 半屏幕像素索引.u + 1) << 1 + 1 
  ld_indexable(buffer)(uint,uint,uint,uint) r0.z, r0.zzzz, t3.yzxw  	-> 取第一个元素(X) 


  ieq r1.y, r7.x, l(6) 									-> [Purple.y修改值] * 255 的后4个bit <-> [6] 
  lt r1.z, l(0.000000), cb0[0].x 						-> 0 < 1 ? true -> 总是开启如下逻辑 
  if_nz r1.z 											-> 这里总是能进入 

  	//R13 = Scale * 从原Norm顶点指向新Norm顶点的向量(正向扰动矢量) + 原Normal向量 -> 记为 Rn 
    dp3 r1.w, r13.xyzx, r13.xyzx 						-> dot(Rn, Rn)
    sqrt r1.w, r1.w 									-> Rn 的模长 -> 记为 |Rn| 
    if_nz cb1[189].x 									-> cb1[189].x 用十六进制解码后的 0x00000001 -> true 

      if_z r1.y 										-> 是否当前像素属于 6号材质 

        max r1.y, r3.w, l(0.100000) 					-> max(roughness, 0.1) 
        mul r4.w, r1.w, cb0[0].y 						-> |Rn| * 1 
        mul r5.z, r4.w, l(3.141593) 					-> π * |Rn| 
        dp3 r5.w, r13.xyzx, r2.yzwy 					-> dot(Rn, '超抬视向') 
        max r6.w, r1.w, l(0.001000) 					-> max(|Rn|, 0.001) -> 模长不要小于 0.001 
        
        //构造传入函数asin_fast的入参 a -> (opposite / hypotenuse) 
        div r5.w, r5.w, r6.w 							-> R5W = dot(Rn, '超抬视向') / max(|Rn|, 0.001) 

        //asin_fast(a)
        add r6.w, -|r5.w|, l(1.000000) 					-> 1 - abs(dot(Rn, '超抬视向') / max(|Rn|, 0.001))
        sqrt r6.w, r6.w 								-> sqrt(1 - |dot(Rn, '超抬视向') / max(|Rn|, 0.001)|)
        mad r7.x, |r5.w|, l(-0.018729), l(0.074261) 	-> R7X = -0.018729 * |dot(Rn, '超抬视向') / max(|Rn|, 0.001)| + 0.074261
        mad r7.x, r7.x, |r5.w|, l(-0.212114) 			-> (a*|R5W|+b) * |R5W| - 0.212114
        mad r7.x, r7.x, |r5.w|, l(1.570729)
        mul r7.y, r6.w, r7.x
        mad r7.y, r7.y, l(-2.000000), l(3.141593)
        lt r5.w, r5.w, -r5.w
        and r5.w, r5.w, r7.y
        mad r5.w, r7.x, r6.w, r5.w 
        mad r6.w, r1.y, l(3.141593), -r5.z
        add r5.w, r5.w, -|r6.w|

        mad r1.y, r1.y, l(3.141593), r5.z
        add r1.y, -|r6.w|, r1.y
        div_sat r1.y, r5.w, r1.y
        add r1.y, -r1.y, l(1.000000)
        mad r5.z, r1.y, l(-2.000000), l(3.000000)
        mul r1.y, r1.y, r1.y
        mul r1.y, r1.y, r5.z
        mad r4.w, r4.w, l(3.141593), l(-0.100000)
        mul_sat r4.w, r4.w, l(5.000000)
        mul r1.w, r1.y, r4.w
      endif 
    endif 
    add r1.y, -r1.w, l(1.000000)
    mad r1.y, cb0[1].w, r1.y, r1.w
    add r1.w, -r1.y, l(1.000000)
    mul r7.xyz, r1.wwww, cb0[1].xyzx
  else 
    mov r7.xyz, l(0,0,0,0)
    mov r1.y, l(1.000000)
  endif 
  log r1.w, r3.w
  mad r1.w, -r1.w, l(1.200000), l(1.000000) 
  add r4.w, cb1[188].z, l(-1.000000)
  add r5.z, -r1.w, r4.w
  mov r2.x, l(0)
  mov r8.xyw, l(0,0,0,0)
  mov r5.w, r1.x 
  mov r6.w, l(0) 				-> Loop Index (i) -> 初始为 0 
  loop 
    uge r7.w, r6.w, r0.w  		-> index >= r0.w ? true : false 
    breakc_nz r7.w 				-> 如果 index >= buffer_size -> 跳出循环 
    lt r7.w, r5.w, l(0.001000)	-> r5.w < 0.001 ? true : false 
    if_nz r7.w 					-> 如果 
      break 
    endif 
    iadd r7.w, r0.z, r6.w 
    ld_indexable(buffer)(uint,uint,uint,uint) r7.w, r7.wwww, t4.yzwx 	-> 使用 uint4 查看 T4 buffer 数据，这是张映射表 
    add r14.xyz, r4.xyzx, -cb4[r7.w + 0].xyzx 		-> 当前点世界空间坐标 - cb4[0-49] -> cb4前50组数据记录的是 IBL 探针的posWS 
    dp3 r9.w, r14.xyzx, r14.xyzx 
    sqrt r10.w, r9.w 
    lt r12.w, r10.w, cb4[r7.w + 0].w 				-> 探针距离是否在范围内 
    if_nz r12.w 
      div_sat r10.w, r10.w, cb4[r7.w + 0].w
      dp3 r12.w, r2.yzwy, r14.xyzx
      mad r9.w, -cb4[r7.w + 0].w, cb4[r7.w + 0].w, r9.w
      mad r9.w, r12.w, r12.w, -r9.w
      ge r13.w, r9.w, l(0.000000)
      sqrt r9.w, r9.w
      add r9.w, -r12.w, r9.w
      mad r14.xyz, r9.wwww, r2.yzwy, r14.xyzx
      add r14.yzw, r14.xxyz, -cb4[r7.w + 682].xxyz
      mad r9.w, r10.w, l(2.500000), l(-1.500000)
      max r9.w, r9.w, l(0.000000)
      mul r10.w, r9.w, r9.w
      mad r9.w, -r9.w, l(2.000000), l(3.000000)
      mad r14.x, -r10.w, r9.w, l(1.000000)
      movc r14.xyzw, r13.wwww, r14.xyzw, r2.xyzw
      mov r15.xyz, r14.yzwy 							->  
      mov r15.w, cb4[r7.w + 341].y 						-> 
      sample_l_indexable(texturecubearray)(float,float,float,float) r15.xyzw, r15.xyzw, t2.xyzw, s3, r5.z  -> 采样 IBL 探针纹理 
      mul r14.yzw, r15.xxyz, cb4[r7.w + 341].xxxx
      mul r14.yzw, r14.xxxx, r14.yyzw
      mul r14.yzw, r5.wwww, r14.yyzw
      mad r8.xyw, r14.yzyw, r1.yyyy, r8.xyxw
      mad r7.w, -r15.w, r14.x, l(1.000000)
      mul r5.w, r5.w, r7.w
    endif 
    iadd r6.w, r6.w, l(1)
  endloop 
  lt r1.x, l(0.000000), cb2[0].y
  if_nz r1.x
    add r1.w, -r1.w, cb2[0].x
    add r1.w, r1.w, l(-1.000000)
    sample_l_indexable(texturecube)(float,float,float,float) r14.xyz, r2.yzwy, t0.xyzw, s1, r1.w
    mul r14.xyz, r14.xyzx, cb1[180].xyzx
    lt r2.x, l(0.000000), cb2[0].w
    if_nz r2.x
      sample_l_indexable(texturecube)(float,float,float,float) r2.xyz, r2.yzwy, t1.xyzw, s2, r1.w
      mad r2.xyz, r2.xyzx, cb1[180].xyzx, -r14.xyzx
      mad r14.xyz, cb2[0].wwww, r2.xyzx, r14.xyzx
    endif 
    mad r7.xyz, r14.xyzx, r1.yyyy, r7.xyzx
  endif 
  mul r2.xyz, r5.wwww, r7.xyzx
  mad r2.xyz, r8.xywx, cb1[156].xyzx, r2.xyzx
  mad r2.xyz, cb1[134].yyyy, r2.xyzx, r12.xyzx
  if_nz r8.z
    mov r3.y, r3.w 							-> 推测 r3.w = Roughness    r3.x = NdotV 
    sample_l_indexable(texture2d)(float,float,float,float) r1.yw, r3.xyxx, t5.zxwy, s4, l(0.000000)  -> 采样 LUT 
    mul_sat r2.w, r9.y, l(50.000000)
    mul r1.w, r1.w, r2.w 					-> r1.w = LUT.bias 
    add r2.w, -r5.x, l(1.000000)
    mul r1.w, r1.w, r2.w
    mad r7.xyz, r9.xyzx, r1.yyyy, r1.wwww  	-> r1.y = LUT.scale  ->  推测 R9 = Specular 
    mul r7.xyz, r2.xyzx, r7.xyzx
    mov r3.z, r5.y 							-> 推测 r5.y = Roughness 	r3.x = NdotV 
    sample_l_indexable(texture2d)(float,float,float,float) r1.yw, r3.xzxx, t5.zxwy, s4, l(0.000000)
    mad r1.y, r1.y, l(0.040000), r1.w
    mul r1.w, r5.x, r1.y
    mad r1.y, -r1.y, r5.x, l(1.000000)
    mul r5.xzw, r1.wwww, r6.xxyz
    mad r5.xzw, r7.xxyz, r1.yyyy, r5.xxzw 	-> R7 = Specular 
    mul r0.x, r0.x, r1.w
    mul r0.x, r0.y, r0.x
    if_nz r1.z
      dp3 r0.y, r13.xyzx, r13.xyzx
      sqrt r0.y, r0.y
      if_nz cb1[189].x
        max r1.y, r5.y, l(0.100000)
        mul r1.z, r0.y, cb0[0].y
        mul r1.w, r1.z, l(3.141593)
        dp3 r2.w, r13.xyzx, r11.yzwy
        max r3.y, r0.y, l(0.001000)
        div r2.w, r2.w, r3.y
        add r3.y, -|r2.w|, l(1.000000)
        sqrt r3.y, r3.y
        mad r3.z, |r2.w|, l(-0.018729), l(0.074261)
        mad r3.z, r3.z, |r2.w|, l(-0.212114)
        mad r3.z, r3.z, |r2.w|, l(1.570729)
        mul r6.x, r3.y, r3.z
        mad r6.x, r6.x, l(-2.000000), l(3.141593)
        lt r2.w, r2.w, -r2.w
        and r2.w, r2.w, r6.x
        mad r2.w, r3.z, r3.y, r2.w
        mad r3.y, r1.y, l(3.141593), -r1.w
        add r2.w, r2.w, -|r3.y|
        mad r1.y, r1.y, l(3.141593), r1.w
        add r1.y, -|r3.y|, r1.y
        div_sat r1.y, r2.w, r1.y
        add r1.y, -r1.y, l(1.000000)
        mad r1.w, r1.y, l(-2.000000), l(3.000000)
        mul r1.y, r1.y, r1.y
        mul r1.y, r1.y, r1.w
        mad r1.z, r1.z, l(3.141593), l(-0.100000)
        mul_sat r1.z, r1.z, l(5.000000)
        mul r0.y, r1.y, r1.z
      endif 
      add r1.y, -r0.y, l(1.000000)
      mad r0.y, cb0[1].w, r1.y, r0.y
      add r1.y, -r0.y, l(1.000000)
      mul r1.yzw, r1.yyyy, cb0[1].xxyz
    else 
      mov r1.yzw, l(0,0,0,0)
      mov r0.y, l(1.000000)
    endif 
    log r2.w, r5.y
    mad r2.w, -r2.w, l(1.200000), l(1.000000)
    add r3.y, -r2.w, r4.w
    mov r11.x, l(0)
    mov r6.xyz, l(0,0,0,0)
    mov r3.z, r0.x
    mov r4.w, l(0)
    loop 
      uge r5.y, r4.w, r0.w
      breakc_nz r5.y
      lt r5.y, r3.z, l(0.001000)
      if_nz r5.y
        break 
      endif 
      iadd r5.y, r0.z, r4.w
      ld_indexable(buffer)(uint,uint,uint,uint) r5.y, r5.yyyy, t4.yxzw
      add r7.xyz, r4.xyzx, -cb4[r5.y + 0].xyzx
      dp3 r6.w, r7.xyzx, r7.xyzx
      sqrt r7.w, r6.w
      lt r8.x, r7.w, cb4[r5.y + 0].w
      if_nz r8.x
        div_sat r7.w, r7.w, cb4[r5.y + 0].w
        dp3 r8.x, r11.yzwy, r7.xyzx
        mad r6.w, -cb4[r5.y + 0].w, cb4[r5.y + 0].w, r6.w
        mad r6.w, r8.x, r8.x, -r6.w
        ge r8.y, r6.w, l(0.000000)
        sqrt r6.w, r6.w
        add r6.w, -r8.x, r6.w
        mad r7.xyz, r6.wwww, r11.yzwy, r7.xyzx
        add r12.yzw, r7.xxyz, -cb4[r5.y + 682].xxyz
        mad r6.w, r7.w, l(2.500000), l(-1.500000)
        max r6.w, r6.w, l(0.000000)
        mul r7.x, r6.w, r6.w
        mad r6.w, -r6.w, l(2.000000), l(3.000000)
        mad r12.x, -r7.x, r6.w, l(1.000000)
        movc r7.xyzw, r8.yyyy, r12.xyzw, r11.xyzw
        mov r8.xyz, r7.yzwy
        mov r8.w, cb4[r5.y + 341].y
        sample_l_indexable(texturecubearray)(float,float,float,float) r8.xyzw, r8.xyzw, t2.xyzw, s3, r3.y
        mul r7.yzw, r8.xxyz, cb4[r5.y + 341].xxxx
        mul r7.yzw, r7.xxxx, r7.yyzw
        mul r7.yzw, r3.zzzz, r7.yyzw
        mad r6.xyz, r7.yzwy, r0.yyyy, r6.xyzx
        mad r5.y, -r8.w, r7.x, l(1.000000)
        mul r3.z, r3.z, r5.y
      endif 
      iadd r4.w, r4.w, l(1)
    endloop 
    if_nz r1.x
      add r0.x, -r2.w, cb2[0].x
      add r0.x, r0.x, l(-1.000000)
      sample_l_indexable(texturecube)(float,float,float,float) r4.xyz, r11.yzwy, t0.xyzw, s1, r0.x
      mul r4.xyz, r4.xyzx, cb1[180].xyzx
      lt r0.z, l(0.000000), cb2[0].w
      if_nz r0.z
        sample_l_indexable(texturecube)(float,float,float,float) r0.xzw, r11.yzwy, t1.xwyz, s2, r0.x
        mad r0.xzw, r0.xxzw, cb1[180].xxyz, -r4.xxyz
        mad r4.xyz, cb2[0].wwww, r0.xzwx, r4.xyzx
      endif 
      mad r1.yzw, r4.xxyz, r0.yyyy, r1.yyzw
    endif 
    mul r0.xyz, r1.yzwy, r3.zzzz
    mad r0.xyz, r6.xyzx, cb1[156].xyzx, r0.xyzx
    mad r0.xyz, cb1[134].yyyy, r0.xyzx, r5.xzwx
  else 
    sample_l_indexable(texture2d)(float,float,float,float) r1.xy, r3.xwxx, t5.xyzw, s4, l(0.000000)
    mul_sat r0.w, r9.y, l(50.000000)
    mul r0.w, r1.y, r0.w
    mad r1.xyz, r9.xyzx, r1.xxxx, r0.wwww
    mul r0.xyz, r1.xyzx, r2.xyzx
  endif 
  min r0.xyz, -r0.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)
  add o0.xyz, -r0.xyzx, r10.xyzx
else 
  mov o0.xyz, r10.xyzx 		-> 对于 0号 或 7号 材质渲染方案来说，直接使用 R10.xyz的颜色输出值作为 GI 
endif 
ret 
// Approximately 0 instruction slots used
